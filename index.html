<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Bid Comparison Application</title>

  <!-- Tailwind (utility) + Excel libs (parsing + export) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/exceljs/dist/exceljs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver/dist/FileSaver.min.js"></script>

  <!-- Inter font -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet"/>

  <!-- ====== FULL CSS (web view fixes) ====== -->
  <style>
    /* --- Page base --- */
    body { font-family: "Inter", sans-serif; background: #0f172a; color: #f9fafb; }

    /* --- Variance inputs --- */
    .variance-input-group { display: flex; flex-direction: column; gap: 0.25rem; }
    .variance-input-label { font-size: 0.875rem; font-weight: 500; color: #d1d5db; }
    .variance-input {
      padding: 0.5rem 0.75rem; border: 1px solid #4b5563; border-radius: 0.375rem;
      font-size: 0.875rem; color: #f9fafb; background-color: #1f2937; outline: none;
      transition: border-color .2s, box-shadow .2s;
    }
    .variance-input:focus { border-color: #6366f1; box-shadow: 0 0 0 2px rgba(99,102,241,.4); }

    /* --- Variance legend --- */
    .variance-legend {
      display: flex; justify-content: flex-end; align-items: center;
      gap: 1.5rem; margin: 1rem 1rem 0 0; font-size: 0.875rem; font-weight: 600; color: #d1d5db;
    }
    .variance-box { width: 1.5rem; height: 1.5rem; border: 2px solid; border-radius: 0.375rem; }
    .variance-low  { background-color: #cce5ff; border-color: #007bff; }
    .variance-high { background-color: #ffe5b4; border-color: #ff9900; }

    /* --- Tabs --- */
    .tab-button.active { border-color: #4f46e5; background-color: #312e81; color: #c7d2fe; font-weight: 600; }

    /* --- Scroll wrappers --- */
    .table-container { position: relative; width: 100%; }
    .top-scrollbar {
      overflow-x: auto; overflow-y: hidden; height: 14px; position: sticky; top: 0; z-index: 50;
      background: #111827; border-bottom: 1px solid #374151;
    }
    .top-scrollbar-inner { height: 1px; }
    .table-viewport {
      max-height: 70vh; overflow: auto; background: #1f2937; border: 1px solid #374151; border-top: 0;
    }

    /* --- Table base --- */
    table { table-layout: fixed; width: max-content; min-width: 100%; border-collapse: collapse; color: #f9fafb; }
    th, td { border: 1px solid #374151; padding: 8px; font-size: 12px; white-space: nowrap; }
    th {
      background-color: #111827; color: #f3f4f6; font-weight: 600;
      position: sticky; top: 0; z-index: 10;
    }

    /* --- Sticky first two columns --- */
    .col-slno { width: 90px; min-width: 90px; }
    .col-desc { width: 420px; min-width: 420px; }
    .sticky-col-1 { position: sticky; left: 0; z-index: 12; background: #1f2937; }
    .sticky-col-2 { position: sticky; left: 90px; z-index: 12; background: #1f2937; }

    /* --- Description wraps --- */
    td:nth-child(2), th:nth-child(2) { white-space: normal; line-height: 1.3; }

    /* --- Numeric alignment --- */
    .amount-cell, .total-cell, .least-amount-cell { text-align: right; }

    /* --- Compact stacked Rate/Amount cell --- */
    .compact-cell { white-space: normal; padding: 6px 8px; }
    .compact-cell .label { display: block; font-size: 10px; color: #9ca3af; line-height: 1.1; }
    .compact-cell .val   { display: block; text-align: right; }

    /* --- Inputs --- */
    .rate-input {
      width: 100%; max-width: 90px; padding: 4px; border: 1px solid #4b5563; border-radius: 4px;
      text-align: right; background-color: #111827; color: #f9fafb;
    }
    .rate-input:disabled { background-color: #374151; border-color: transparent; color: #9ca3af; }

    /* --- Variance colors --- */
    .bg-blue-100   { background-color: #cce5ff; }
    .bg-orange-100 { background-color: #ffe5b4; }
    .rate-input.bg-blue-100   { border: 1px solid #007bff; }
    .rate-input.bg-orange-100 { border: 1px solid #ff9900; }

    /* --- Row highlights --- */
    .subtotal-row { font-weight: bold; background-color: #4b5563; }
    .grand-total-row { font-weight: bold; background-color: #047857; font-size: 14px; }
    .category-header { font-weight: bold; background-color: #374151; }
    .least-rate-cell, .least-amount-cell { background-color: #065f46 !important; font-weight: bold; }


    /* âœ… make highlighted inputs readable */
    .rate-input.bg-blue-100,
    .rate-input.bg-orange-100 {
      color: #111827 !important;     /* dark text */
      caret-color: #111827 !important;
      font-weight: 600;
    }

    /* consistent backgrounds for the two variance states */
    .rate-input.bg-blue-100 {
      background-color: #DBEAFE !important; /* Tailwind blue-100 */
      border-color: #3B82F6 !important;      /* blue-500 */
    }
    .rate-input.bg-orange-100 {
      background-color: #FFEDD5 !important; /* Tailwind orange-100 */
      border-color: #F59E0B !important;     /* amber-500 / orange-500 */
    }

    /* readable placeholder when inputs are empty */
    .rate-input.bg-blue-100::placeholder,
    .rate-input.bg-orange-100::placeholder {
      color: #6B7280; /* gray-500 */
      opacity: 1;
    }

    /* if you ever disable highlighted inputs, keep them readable too */
    .rate-input.bg-blue-100:disabled,
    .rate-input.bg-orange-100:disabled {
      color: #111827 !important;
      background-color: #E5E7EB !important;  /* gray-200 */
      border-color: #9CA3AF !important;      /* gray-400 */
    }
  </style>
</head>

<body class="text-gray-100">
  <div class="container mx-auto p-4 md:p-8">
    <header class="text-center mb-10">
      <h1 class="text-4xl font-extrabold tracking-tight sm:text-5xl">ðŸ“Š Bid Comparison Tool</h1>
      <p class="mt-4 text-lg text-gray-300">Upload your estimate and bidder Excel sheets to generate a detailed comparative statement.</p>
    </header>

    <!-- Upload Section -->
    <div id="upload-section" class="bg-gray-800 p-8 rounded-2xl shadow-lg mb-10 border border-gray-700">
      <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
        <div class="space-y-2">
          <label for="estimate-file" class="block text-sm font-medium text-gray-200">ðŸ“„ Estimate File (Baseline)</label>
          <input type="file" id="estimate-file" accept=".xlsx"
            class="block w-full text-sm text-gray-200 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:bg-indigo-200/20 file:text-indigo-200 hover:file:bg-indigo-200/30"/>
        </div>
        <div class="space-y-2">
          <label for="bidder-files" class="block text-sm font-medium text-gray-200">ðŸ‘¥ Bidder Files (Max 7)</label>
          <input type="file" id="bidder-files" accept=".xlsx" multiple
            class="block w-full text-sm text-gray-200 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:bg-violet-200/20 file:text-violet-200 hover:file:bg-violet-200/30"/>
        </div>
      </div>

      <!-- Variance Controls -->
      <div class="mt-8 grid grid-cols-1 md:grid-cols-2 gap-6">
        <div class="variance-input-group">
          <label for="lower-variance" class="variance-input-label">ðŸ“‰ Lower Variance Factor</label>
          <input type="number" id="lower-variance" step="0.01" min="0" max="1" value="0.8" class="variance-input"/>
          <small class="text-gray-400 mt-1">e.g., 0.8 means -20% below estimate</small>
        </div>
        <div class="variance-input-group">
          <label for="upper-variance" class="variance-input-label">ðŸ“ˆ Upper Variance Factor</label>
          <input type="number" id="upper-variance" step="0.01" min="1" max="2" value="1.2" class="variance-input"/>
          <small class="text-gray-400 mt-1">e.g., 1.2 means +20% above estimate</small>
        </div>
      </div>

      <!-- Action Buttons -->
      <div class="mt-10 flex flex-wrap justify-center gap-6">
        <button id="process-button"
          class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
          ðŸš€ Generate Comparison
        </button>
        <button id="download-button"
          class="bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-6 rounded-lg shadow-md hidden focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500">
          ðŸ“¥ Download as Excel
        </button>
      </div>

      <!-- Loader -->
      <div id="loader" class="text-center mt-6 hidden">
        <div role="status" class="flex flex-col items-center gap-2">
          <svg class="w-8 h-8 text-indigo-400 animate-spin" viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg">
            <circle cx="50" cy="50" r="45" stroke="currentColor" stroke-width="10" opacity=".2"/>
            <path d="M95 50a45 45 0 10-45 45" fill="currentColor"/>
          </svg>
          <p class="text-sm text-gray-400">Processing files, please wait...</p>
        </div>
      </div>
    </div>

    <!-- Output Section -->
    <div id="output-section" class="hidden">
      <div class="border-b border-gray-700">
        <nav id="tabs-container" class="-mb-px flex space-x-4 overflow-x-auto" aria-label="Tabs"></nav>
      </div>

      <div class="variance-legend">
        <div class="flex items-center gap-2">
          <div class="variance-box variance-low"></div>
          <span id="lower-variance-label">0.8</span>
        </div>
        <div class="flex items-center gap-2">
          <div class="variance-box variance-high"></div>
          <span id="upper-variance-label">1.2</span>
        </div>
      </div>

      <div id="tables-container" class="mt-4 bg-gray-800 rounded-lg shadow-md"></div>
    </div>
  </div>

  <!-- ====== JAVASCRIPT LOGIC ====== -->
<script>
/* ===================== Compatibility & helpers ===================== */
const EXCLUDE_SHEETS = [/^summary$/i, /^measure/i];

const HEADER_SYNONYMS = {
  slNo:   [/^(s(\.|\/)?\s*)?(item\s*)?no\.?$/i, /^s\s*no/i, /^serial/i, /^item\s*no/i],
  desc:   [/^description/i, /^item\s*description/i, /^desc$/i],
  unit:   [/^unit$/i, /^uom$/i, /^units?$/i],
  qty:    [/^qty$/i, /^quantity$/i, /^qtty$/i],
  rate:   [/^rate$/i, /^unit\s*rate$/i, /^quoted\s*rate$/i, /^basic\s*rate$/i],
  amount: [/^amount$/i, /^amt$/i, /^total$/i, /^line\s*amount$/i]
};

function looksLike(name, patterns){ return patterns.some(re => re.test(String(name||"").trim())); }
function normalizeDesc(s){
  return String(s ?? "")
    .toLowerCase()
    .replace(/\s+/g, " ")
    .replace(/[^\p{L}\p{N}\s]/gu, "")
    .trim();
}

function inferSheetConfigFromWorksheet(worksheet) {
  const rows = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: false, defval: "" });
  let headerRow = -1, cols = {};

  for (let r = 0; r < Math.min(20, rows.length); r++) {
    const row = rows[r] || [];
    const found = {};
    for (let c = 0; c < row.length; c++) {
      const cell = String(row[c]).trim();
      if (!cell) continue;
      if (looksLike(cell, HEADER_SYNONYMS.slNo))   found.slNoCol   = c;
      if (looksLike(cell, HEADER_SYNONYMS.desc))   found.descCol   = c;
      if (looksLike(cell, HEADER_SYNONYMS.unit))   found.unitCol   = c;
      if (looksLike(cell, HEADER_SYNONYMS.qty))    found.qtyCol    = c;
      if (looksLike(cell, HEADER_SYNONYMS.rate))   found.rateCol   = c;
      if (looksLike(cell, HEADER_SYNONYMS.amount)) found.amountCol = c;
    }

    // Normal BOQ: Sl.No + Description
    if (found.descCol != null && found.slNoCol != null) {
      // If no Rate but there is Amount â†’ treat as amount-only rates when needed
      if (found.rateCol == null && found.amountCol != null) {
        found.rateCol = found.amountCol;
        found.assumeQty1 = true;
        found.amountAsRate = true;
        found.amountOnly = true;
      }
      headerRow = r; cols = found; break;
    }

    // ABSTRACT-like: Description + Amount only (no Sl.No / Qty / Rate)
    if (
      found.descCol != null &&
      found.amountCol != null &&
      found.slNoCol == null &&
      found.qtyCol == null &&
      found.rateCol == null
    ) {
      cols = {
        ...found,
        slNoCol: null,
        qtyCol: null,
        rateCol: found.amountCol,
        assumeQty1: true,
        amountAsRate: true,
        amountOnly: true
      };
      headerRow = r; break;
    }
  }
  if (headerRow >= 0) return { startRow: headerRow + 1, ...cols };
  return DEFAULT_BOQ_CONFIG;
}

/* ===================== Config ===================== */
const DEFAULT_BOQ_CONFIG = { startRow: 5, slNoCol: 0, descCol: 1, unitCol: 2, qtyCol: 3, rateCol: 4, amountCol: 5 };
const DATA_CONFIG = {
  "BOQ-Compound Wall": { startRow: 3, slNoCol: 0, descCol: 1, unitCol: 2, qtyCol: 3, rateCol: 4, amountCol: 5 }
};
const ESTIMATE_CONFIG = {
  "BOQ-Compound Wall": { startRow: 4, slNoCol: 0, descCol: 1, unitCol: 2, qtyCol: 3, rateCol: 4, amountCol: 5 }
};

/* ===================== State & DOM ===================== */
let consolidatedData = {};
let bidderNames = [];
let processedSheetNames = [];

const processButton = document.getElementById("process-button");
const downloadButton = document.getElementById("download-button");
const estimateFileInput = document.getElementById("estimate-file");
const bidderFilesInput = document.getElementById("bidder-files");
const outputSection = document.getElementById("output-section");
const loader = document.getElementById("loader");

processButton.addEventListener("click", handleProcessFiles);
downloadButton.addEventListener("click", () => {
  if (typeof window.handleDownloadExcelJS === "function") window.handleDownloadExcelJS();
});

function parseNumber(v) {
  if (v === null || typeof v === "undefined") return 0;
  const num = parseFloat(String(v).replace(/,/g, ""));
  return isNaN(num) ? 0 : num;
}

/* ===================== Main processing ===================== */
async function handleProcessFiles() {
  const estimateFile = estimateFileInput.files[0];
  const bidderFiles = bidderFilesInput.files;

  if (!estimateFile || bidderFiles.length === 0) {
    alert("Please select an estimate file and at least one bidder file.");
    return;
  }
  if (bidderFiles.length > 7) {
    alert("You can select a maximum of 7 bidder files.");
    return;
  }

  loader.classList.remove("hidden");
  outputSection.classList.add("hidden");

  try {
    bidderNames = Array.from(bidderFiles).map((f) =>
      f.name.split(".")[0].replace(/DGG_BIDDER_/i, "BIDDER ").trim()
    );

    const estimateData = await parseExcelFile(estimateFile, true);
    const biddersData = await Promise.all(Array.from(bidderFiles).map((file) => parseExcelFile(file, false)));

    const boqSheetNames = Object.keys(estimateData).sort();
    processedSheetNames = ["Summary", ...boqSheetNames];

    consolidateAllData(estimateData, biddersData);

    const { lower, upper } = getVarianceThresholds();
    document.getElementById("lower-variance-label").textContent = `Low < ${lower}`;
    document.getElementById("upper-variance-label").textContent = `High > ${upper}`;

    renderUI();
    outputSection.classList.remove("hidden");
    downloadButton.classList.remove("hidden");
  } catch (e) {
    console.error("Error during file processing:", e);
    alert("An error occurred while processing the files. Please check the console for details.");
  } finally {
    loader.classList.add("hidden");
  }
}

// read excel (formatted text, blanks -> "")
function parseExcelFile(file, isEstimate) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const workbook = XLSX.read(new Uint8Array(e.target.result), { type: "array" });
        const parsed = {};
        workbook.SheetNames.forEach((sheetName) => {
          if (EXCLUDE_SHEETS.some(re => re.test(sheetName))) return;
          const worksheet = workbook.Sheets[sheetName];
          if (!worksheet) return;

          const explicit = getConfigForSheet(sheetName, isEstimate);
          const cfg = explicit || inferSheetConfigFromWorksheet(worksheet);

          const rows = XLSX.utils.sheet_to_json(worksheet, {
            header: 1,
            range: Math.max(0, (cfg.startRow ?? 1) - 1),
            raw: false,
            defval: ""
          });

          rows._cfg = cfg;
          parsed[sheetName] = rows;
        });
        resolve(parsed);
      } catch (err) { reject(err); }
    };
    reader.onerror = reject;
    reader.readAsArrayBuffer(file);
  });
}

function normalizeSrNo(value) {
  const s = String(value ?? "").trim();
  if (!s) return "";
  const cleaned = s.replace(/[^\d.]/g, "");
  if (!cleaned) return "";
  if (!cleaned.includes(".")) return cleaned.replace(/^0+/, "") || "0";
  const [intPart, decPartRaw] = cleaned.split(".");
  const dec = (decPartRaw || "").replace(/[^0-9]/g, "");
  if (dec && /^0+$/.test(dec)) return (intPart.replace(/^0+/, "") || "0");
  return `${intPart.replace(/^0+/, "") || "0"}.${dec}`;
}

/* ---------- Build consolidated structure ---------- */
function consolidateAllData(estimateData, biddersData) {
  consolidatedData = {};

  // regex rules: treat "Total Amount ..." as subtotal, keep GRAND TOTAL for real grand total
  const SUBTOTAL_RE = /sub[\s-]?total/i;
  const TOTAL_AMOUNT_RE = /^total\s*amount/i;
  const TOTAL_OF_RE = /^total\s+of/i;
  const GRAND_RE = /\bgrand\s*total\b|^total\s+including\s+gst/i;

  for (const sheetName in estimateData) {
    const estimateRows = estimateData[sheetName];
    if (!estimateRows) continue;

    const cfg =
      (estimateRows && estimateRows._cfg) ||
      getConfigForSheet(sheetName, true) ||
      DEFAULT_BOQ_CONFIG;

    const isAmountOnly = !!(
      cfg.amountOnly || cfg.amountAsRate ||
      (cfg.slNoCol == null && cfg.qtyCol == null && cfg.rateCol === cfg.amountCol)
    );

    const items = estimateRows
      .map((row) => {
        // keep EXACT serial number from file (no auto-fill)
        const slNoRaw = cfg.slNoCol != null ? row[cfg.slNoCol] : "";
        const slNo = String(slNoRaw || "").trim();
        const description = row[cfg.descCol] || "";
        if (!slNo && !description) return null;

        // quantity / rate / raw amount
        let qty = parseQty(cfg.qtyCol != null ? row[cfg.qtyCol] : "");
        if (cfg.assumeQty1) qty = 1;

        const rateFromFile = cfg.amountAsRate ? parseNumber(row[cfg.amountCol]) : parseNumber(row[cfg.rateCol]);
        const rawAmountFromFile = isAmountOnly ? parseNumber(row[cfg.amountCol]) : 0;

        const item = {
          slNo,
          description,
          unit: row[cfg.unitCol] || "",
          qty,
          estimate: { rate: isAmountOnly ? 0 : rateFromFile, amount: 0, rawAmount: rawAmountFromFile },
          bidders: [],
          isSubtotal: SUBTOTAL_RE.test(description) || TOTAL_AMOUNT_RE.test(description) || TOTAL_OF_RE.test(description),
          isGrandTotal: GRAND_RE.test(description),
          isCategory: !isAmountOnly && /^\d+(?:\.0+)?$/.test(slNo),
          amountOnly: isAmountOnly
        };

        const estimateKeySr   = normalizeSrNo(slNo);
        const estimateKeyDesc = normalizeDesc(description);

        biddersData.forEach((bidder, index) => {
          const bidderSheet = bidder[sheetName];
          let bRate = 0, bRawAmt = 0;

          if (bidderSheet) {
            const bcfg =
              (bidderSheet && bidderSheet._cfg) ||
              getConfigForSheet(sheetName, false) ||
              cfg;

            const match = bidderSheet.find((bRow) => {
              const keySr   = bcfg.slNoCol != null ? normalizeSrNo(bRow[bcfg.slNoCol]) : "";
              const keyDesc = bcfg.descCol != null ? normalizeDesc(bRow[bcfg.descCol]) : "";
              return (estimateKeySr && keySr && keySr === estimateKeySr) ||
                     (estimateKeyDesc && keyDesc && keyDesc === estimateKeyDesc);
            });

            if (match) {
              const useAmount = bcfg.amountAsRate || (bcfg.rateCol == null && bcfg.amountCol != null);
              if (isAmountOnly || useAmount) {
                bRawAmt = parseNumber(match[bcfg.amountCol]) || 0;
                bRate = 0;
              } else {
                bRate = parseNumber(match[bcfg.rateCol]) || 0;
              }
            }
          }
          item.bidders.push({ name: bidderNames[index], rate: bRate, amount: 0, rawAmount: bRawAmt });
        });

        return item;
      })
      .filter(Boolean);

    items._cfg = cfg;
    items._isAmountOnly = isAmountOnly;

    consolidatedData[sheetName] = items;
  }

  calculateAllTotals();
}

/* ---------- Totals ---------- */
function calculateAllTotals() {
  let summarySheetData = {};

  for (const sheetName of Object.keys(consolidatedData)) {
    const sheetData = consolidatedData[sheetName];

    // row amounts
    sheetData.forEach((item) => {
      if (!item.isSubtotal && !item.isGrandTotal && !item.isCategory) {
        if (item.amountOnly) {
          item.estimate.amount = item.estimate.rawAmount || 0;
          item.bidders.forEach((b) => (b.amount = b.rawAmount || 0));
        } else {
          item.estimate.amount = (item.qty || 0) * (item.estimate.rate || 0);
          item.bidders.forEach((b) => (b.amount = (item.qty || 0) * (b.rate || 0)));
        }
      }
    });

    // rolling subtotals
    let currentSubTotal = { estimate: 0, bidders: Array(bidderNames.length).fill(0) };
    sheetData.forEach((item) => {
      if (item.isCategory) {
        currentSubTotal = { estimate: 0, bidders: Array(bidderNames.length).fill(0) };
      } else if (item.isSubtotal) {
        item.estimate.amount = currentSubTotal.estimate;
        item.bidders.forEach((b, i) => (b.amount = currentSubTotal.bidders[i]));
        currentSubTotal = { estimate: 0, bidders: Array(bidderNames.length).fill(0) };
      } else if (!item.isGrandTotal) {
        currentSubTotal.estimate += item.estimate.amount || 0;
        item.bidders.forEach((b, i) => (currentSubTotal.bidders[i] += b.amount || 0));
      }
    });

    // category totals (1.01 + 1.02 â†’ header "1")
    const categoryTotalsMap = {};
    sheetData.forEach((item) => {
      if (item.slNo && String(item.slNo).includes(".") && !item.isCategory) {
        const key = String(item.slNo).split(".")[0];
        if (!categoryTotalsMap[key]) categoryTotalsMap[key] = { estimate: 0, bidders: Array(bidderNames.length).fill(0) };
        categoryTotalsMap[key].estimate += item.estimate.amount || 0;
        item.bidders.forEach((b, i) => (categoryTotalsMap[key].bidders[i] += b.amount || 0));
      }
    });
    sheetData.forEach((item) => {
      const key = normalizeSrNo(item.slNo);
      if (item.isCategory && categoryTotalsMap[key]) {
        item.estimate.amount = categoryTotalsMap[key].estimate;
        item.bidders.forEach((b, i) => (b.amount = categoryTotalsMap[key].bidders[i]));
      }
    });

    // grand total (robust)
    const grand = { estimate: 0, bidders: Array(bidderNames.length).fill(0) };
    sheetData.forEach((item) => {
      const isDetail = !item.isSubtotal && !item.isGrandTotal && !item.isCategory;
      if (isDetail) {
        grand.estimate += item.estimate.amount || 0;
        item.bidders.forEach((b, i) => (grand.bidders[i] += b.amount || 0));
      }
    });

    let grandRow = sheetData.find((i) => i.isGrandTotal);
    if (!grandRow) {
      grandRow = {
        slNo: "", description: "GRAND TOTAL", unit: "", qty: "",
        estimate: { rate: 0, amount: 0 },
        bidders: bidderNames.map(n => ({ name: n, rate: 0, amount: 0 })),
        isSubtotal: false, isGrandTotal: true, isCategory: false, amountOnly: sheetData._isAmountOnly
      };
      sheetData.push(grandRow);
    }
    grandRow.estimate.amount = grand.estimate;
    grandRow.bidders.forEach((b, i) => (b.amount = grand.bidders[i]));

    summarySheetData[sheetName] = { estimateAmount: grand.estimate, bidderAmounts: grand.bidders };
  }

  buildSummarySheet(summarySheetData);
}

/* ---------- Summary builder ---------- */
function buildSummarySheet(summaryData) {
  const addArr = (a, b) => a.map((v, i) => v + (b[i] || 0));
  const bidderZero = () => Array(bidderNames.length).fill(0);

  const rows = [];
  let totalABC = { estimateAmount: 0, bidderAmounts: bidderZero() };

  const sheetOrder = processedSheetNames.slice(1);

  const createRow = (kind, slNo, description, amounts) => {
    const validBids = (amounts.bidderAmounts || []).filter((a) => a > 0);
    return {
      kind,
      slNo,
      description,
      ...amounts,
      leastAmount: validBids.length > 0 ? Math.min(...validBids) : 0
    };
  };

  const groupAKeys = sheetOrder.filter((s) => s.includes("Main Bldg") || s.includes("Admin"));
  const groupBKeys = sheetOrder.filter(
    (s) => s.includes("Roads") || s.includes("Compound Wall") || s.includes("UG Sump") || s.includes("Storm Water")
  );
  const groupCKeys = sheetOrder.filter((s) => !groupAKeys.includes(s) && !groupBKeys.includes(s));

  // A
  rows.push(createRow("category", "A", "Building Works", { estimateAmount: 0, bidderAmounts: bidderZero() }));
  let totalA = { estimateAmount: 0, bidderAmounts: bidderZero() };
  groupAKeys.forEach((key, idx) => {
    const data = summaryData[key];
    if (data) {
      rows.push(createRow("item", idx + 1, key.replace(/BOQ-?/i, ""), data));
      totalA.estimateAmount += data.estimateAmount;
      totalA.bidderAmounts = addArr(totalA.bidderAmounts, data.bidderAmounts);
    }
  });
  rows.push(createRow("subtotal", "", "Total of A (Rs.)", totalA));
  totalABC.estimateAmount += totalA.estimateAmount;
  totalABC.bidderAmounts = addArr(totalABC.bidderAmounts, totalA.bidderAmounts);

  // B
  rows.push(createRow("category", "B", "External Development", { estimateAmount: 0, bidderAmounts: bidderZero() }));
  let totalB = { estimateAmount: 0, bidderAmounts: bidderZero() };
  groupBKeys.forEach((key, idx) => {
    const data = summaryData[key];
    if (data) {
      rows.push(createRow("item", idx + 3, key.replace(/BOQ-?/i, ""), data));
      totalB.estimateAmount += data.estimateAmount;
      totalB.bidderAmounts = addArr(totalB.bidderAmounts, data.bidderAmounts);
    }
  });
  rows.push(createRow("subtotal", "", "Total of B (Rs.)", totalB));
  totalABC.estimateAmount += totalB.estimateAmount;
  totalABC.bidderAmounts = addArr(totalABC.bidderAmounts, totalB.bidderAmounts);

  // C
  rows.push(createRow("category", "C", "B/F Plumbing and sanitary works", { estimateAmount: 0, bidderAmounts: bidderZero() }));
  let totalC = { estimateAmount: 0, bidderAmounts: bidderZero() };
  groupCKeys.forEach((key) => {
    const data = summaryData[key];
    if (data) {
      rows.push(createRow("item", "", key.replace(/BOQ-?/i, ""), data));
      totalC.estimateAmount += data.estimateAmount;
      totalC.bidderAmounts = addArr(totalC.bidderAmounts, data.bidderAmounts);
    }
  });
  if (totalC.estimateAmount > 0 || totalC.bidderAmounts.some((a) => a > 0)) {
    rows.push(createRow("subtotal", "", "Total of C (Rs.)", totalC));
    totalABC.estimateAmount += totalC.estimateAmount;
    totalABC.bidderAmounts = addArr(totalABC.bidderAmounts, totalC.bidderAmounts);
  }

  // Difference, grand and GST
  const difference = {
    estimateAmount: 0,
    bidderAmounts: totalABC.bidderAmounts.map((b) => b - totalABC.estimateAmount),
    leastAmount: 0
  };
  rows.push(createRow("item", "", "Difference in value", difference));

  rows.push(createRow("grand", "D", "Total Of (A+B+C)", totalABC));

  const gst = {
    estimateAmount: totalABC.estimateAmount * 0.18,
    bidderAmounts: totalABC.bidderAmounts.map((b) => b * 0.18)
  };
  rows.push(createRow("item", "", "GST @ 18%", gst));

  const finalTotal = {
    estimateAmount: totalABC.estimateAmount + gst.estimateAmount,
    bidderAmounts: totalABC.bidderAmounts.map((b, i) => b + gst.bidderAmounts[i])
  };
  rows.push(createRow("grand", "", "Total including GST Rs.", finalTotal));

  consolidatedData.Summary = rows;
}

/* ===================== UI ===================== */
function renderUI() {
  renderTabs();
  const firstSheet = processedSheetNames[0];
  renderTableForSheet(firstSheet);
  const firstTab = document.querySelector(".tab-button");
  if (firstTab) firstTab.classList.add("active");
}

function renderTabs() {
  const tabsContainer = document.getElementById("tabs-container");
  tabsContainer.innerHTML = "";
  processedSheetNames.forEach((sheetName) => {
    const btn = document.createElement("button");
    btn.textContent = sheetName.replace(/BOQ-?/i, "");
    btn.className =
      "tab-button border-b-2 border-transparent py-2 px-4 text-sm font-medium text-gray-300 hover:text-gray-100 hover:border-gray-500";
    btn.dataset.sheet = sheetName;
    btn.addEventListener("click", (e) => {
      document.querySelectorAll(".tab-button").forEach((b) => b.classList.remove("active"));
      e.target.classList.add("active");
      renderTableForSheet(sheetName);
    });
    tabsContainer.appendChild(btn);
  });
}

function renderTableForSheet(sheetName) {
  const tablesContainer = document.getElementById("tables-container");
  tablesContainer.innerHTML = "";
  const data = consolidatedData[sheetName];
  if (!data) {
    tablesContainer.innerHTML = `<p class="p-4">No data available for ${sheetName}.</p>`;
    return;
  }

  const tableContainer = document.createElement("div");
  tableContainer.className = "table-container";
  const topBar = document.createElement("div"); topBar.className = "top-scrollbar";
  const topInner = document.createElement("div"); topInner.className = "top-scrollbar-inner";
  topBar.appendChild(topInner);
  const viewport = document.createElement("div"); viewport.className = "table-viewport";
  const table = document.createElement("table"); table.id = `table-${sheetName.replace(/[\s&]/g, "-")}`;
  const thead = document.createElement("thead");
  const tbody = document.createElement("tbody");

  if (sheetName === "Summary") {
    renderSummaryTable(thead, tbody, data);
  } else {
    renderBoqTable(thead, tbody, data, sheetName);
  }

  table.append(thead, tbody);
  viewport.appendChild(table);
  tableContainer.appendChild(topBar);
  tableContainer.appendChild(viewport);
  tablesContainer.appendChild(tableContainer);

  topInner.style.width = table.scrollWidth + "px";
  let syncing = false;
  topBar.addEventListener("scroll", () => {
    if (syncing) return; syncing = true; viewport.scrollLeft = topBar.scrollLeft; syncing = false;
  });
  viewport.addEventListener("scroll", () => {
    if (syncing) return; syncing = true; topBar.scrollLeft = viewport.scrollLeft; syncing = false;
  });
}

function renderSummaryTable(thead, tbody, data) {
  const headerRow = document.createElement("tr");
  const cols = ["Sl. No", "Description", "Estimate", ...bidderNames, "Least Amount"];
  cols.forEach((c, i) => {
    const th = document.createElement("th");
    th.textContent = c;
    if (i === 0) th.classList.add("sticky-col-1", "col-slno");
    if (i === 1) th.classList.add("sticky-col-2", "col-desc");
    headerRow.appendChild(th);
  });
  thead.appendChild(headerRow);

  data.forEach((row) => {
    const tr = document.createElement("tr");
    if (row.kind === "category") tr.className = "category-header";
    else if (row.kind === "subtotal") tr.className = "subtotal-row";
    else if (row.kind === "grand") tr.className = "grand-total-row";

    tr.innerHTML = `
      <td class="sticky-col-1 col-slno">${row.slNo || ""}</td>
      <td class="sticky-col-2 col-desc">${row.description || ""}</td>
      <td class="amount-cell">${formatCurrency(row.estimateAmount || 0)}</td>
      ${bidderNames
        .map((_, i) => `<td class="amount-cell">${formatCurrency((row.bidderAmounts || [])[i] || 0)}</td>`)
        .join("")}
      <td class="least-amount-cell">${formatCurrency(row.leastAmount || 0)}</td>
    `;
    tbody.appendChild(tr);
  });
}

function renderBoqTable(thead, tbody, data, sheetName) {
  const amountOnlySheet = !!data._isAmountOnly;

  const h1 = document.createElement("tr");
  h1.innerHTML = `
    <th rowspan="2" class="sticky-col-1 col-slno">Sl. No.</th>
    <th rowspan="2" class="sticky-col-2 col-desc">Description of Items</th>
    <th rowspan="2">Unit</th>
    <th rowspan="2">Qty</th>
    <th colspan="2">Estimate</th>
    ${bidderNames.map((name) => `<th colspan="2">${name}</th>`).join("")}
    <th colspan="2">Least Bid</th>
  `;
  const h2 = document.createElement("tr");
  const ra = `<th class="amount-cell">Rate</th><th class="amount-cell">Amount</th>`;
  h2.innerHTML = `${ra.repeat(1 + bidderNames.length + 1)}`;
  thead.append(h1, h2);

  const { lower, upper } = getVarianceThresholds();

  data.forEach((item, rowIndex) => {
    const tr = document.createElement("tr");
    if (item.isSubtotal) tr.className = "subtotal-row";
    else if (item.isGrandTotal) tr.className = "grand-total-row";
    else if (item.isCategory) tr.className = "category-header";

    const isEditable = !item.isSubtotal && !item.isGrandTotal && !item.isCategory;
    const least = isEditable ? findLeastBid(item) : { rate: 0, amount: 0 };

    let bidderCellsHtml = "";
    item.bidders.forEach((b, i) => {
      let varianceClass = "";
      if (!amountOnlySheet && isEditable && item.estimate.rate > 0 && b.rate > 0) {
        const ratio = b.rate / item.estimate.rate;
        if (ratio < lower) varianceClass = "bg-blue-100";
        else if (ratio > upper) varianceClass = "bg-orange-100";
      }

      let rateHtml;
      if (amountOnlySheet) {
        rateHtml = `<span class="val"></span>`; // blank
      } else {
        rateHtml = isEditable
          ? `<input type="number" class="rate-input ${varianceClass}" value="${b.rate || 0}"
               data-row-index="${rowIndex}" data-bidder-index="${i}"
               onchange="handleRateChange(this, '${sheetName}')" />`
          : `<span class="val">${formatCurrency(b.rate || 0)}</span>`;
      }

      bidderCellsHtml += `
        <td class="compact-cell">
          <span class="label">Rate</span>${rateHtml}
          <span class="label">Amt</span><span class="val">${formatCurrency(b.amount || 0)}</span>
        </td>`;
    });

    tr.innerHTML = `
      <td class="sticky-col-1 col-slno">${item.slNo || ""}</td>
      <td class="sticky-col-2 col-desc">${item.description || ""}</td>
      <td>${item.unit || ""}</td>
      <td class="amount-cell">${item.qty || ""}</td>
      <td class="compact-cell">
        <span class="label">Rate</span><span class="val">${amountOnlySheet ? "" : formatCurrency(item.estimate.rate || 0)}</span>
        <span class="label">Amt</span><span class="val">${formatCurrency(item.estimate.amount || 0)}</span>
      </td>
      ${bidderCellsHtml}
      <td class="compact-cell least-rate-cell">
        <span class="label">Rate</span><span class="val">${amountOnlySheet ? "" : formatCurrency(least.rate)}</span>
        <span class="label">Amt</span><span class="val">${formatCurrency(least.amount)}</span>
      </td>
    `;
    tbody.appendChild(tr);
  });
}

/* ===================== Utils ===================== */
function handleRateChange(input, sheetName) {
  const rowIndex = parseInt(input.dataset.rowIndex);
  const bidderIndex = parseInt(input.dataset.bidderIndex);
  const newRate = parseFloat(input.value) || 0;
  if (consolidatedData[sheetName]?.[rowIndex]) {
    consolidatedData[sheetName][rowIndex].bidders[bidderIndex].rate = newRate;
  }
  calculateAllTotals();
  const activeTab = document.querySelector(".tab-button.active").dataset.sheet;
  renderTableForSheet(activeTab);

  setTimeout(() => {
    const selector = `#tables-container input[data-row-index="${rowIndex}"][data-bidder-index="${bidderIndex}"]`;
    const el = document.querySelector(selector);
    if (el) { el.focus(); el.setSelectionRange(el.value.length, el.value.length); }
  }, 0);
}

function findLeastBid(item) {
  if (!item.bidders || item.bidders.length === 0) return { rate: 0, amount: 0 };
  if (item.amountOnly) {
    const valid = item.bidders.filter((b) => b.amount > 0);
    if (valid.length === 0) return { rate: 0, amount: 0 };
    const min = valid.reduce((m, c) => (c.amount < m.amount ? c : m), valid[0]);
    return { rate: 0, amount: min.amount };
  } else {
    if (!item.qty) return { rate: 0, amount: 0 };
    const valid = item.bidders.filter((b) => b.rate > 0);
    if (valid.length === 0) return { rate: 0, amount: 0 };
    const min = valid.reduce((m, c) => (c.rate < m.rate ? c : m), valid[0]);
    return { rate: min.rate, amount: min.rate * item.qty };
  }
}

function getConfigForSheet(sheetName, isEstimate) {
  const set = isEstimate ? ESTIMATE_CONFIG : DATA_CONFIG;
  const lower = String(sheetName || "").toLowerCase();
  for (const key in set) if (lower.includes(key.toLowerCase())) return set[key];
  return null;
}

function getVarianceThresholds() {
  const lower = parseFloat(document.getElementById("lower-variance").value) || 0.8;
  const upper = parseFloat(document.getElementById("upper-variance").value) || 1.2;
  return { lower, upper };
}

function parseQty(value) {
  if (typeof value === "string" && value.toUpperCase() === "QRO") return 0;
  const parsedValue = parseFloat(String(value).replace(/[^0-9.-]+/g, ""));
  return isNaN(parsedValue) ? 0 : parsedValue;
}

function formatCurrency(num) {
  if (typeof num !== "number" || !isFinite(num)) return "0";
  return new Intl.NumberFormat("en-IN", { maximumFractionDigits: 0 }).format(Math.round(num));
}

/* ===================== Excel export ===================== */
async function handleDownloadExcelJS() {
  const defaultProject =
    "Proposed Industrial Building for M/s DGG Exports Pvt. Ltd At Shiggaon, Karnataka";
  const projectNameInput = prompt("Enter Project Name:", defaultProject);
  if (projectNameInput === null) return;
  const projectName = (projectNameInput || defaultProject).trim();

  const lowerEl = document.getElementById("lower-variance");
  const upperEl = document.getElementById("upper-variance");
  const currentLower = parseFloat(lowerEl?.value) || 0.8;
  const currentUpper = parseFloat(upperEl?.value) || 1.2;

  const varianceInput = prompt(
    'Enter variance thresholds as "lower,upper"\nExample: 0.80, 1.20',
    `${currentLower}, ${currentUpper}`
  );
  if (varianceInput === null) return;

  let [lStr, uStr] = varianceInput.split(/[,\s]+/).filter(Boolean);
  let l = parseFloat(lStr), u = parseFloat(uStr);
  if (!isFinite(l) || !isFinite(u)) { alert("Invalid variance values. Please enter two numbers like: 0.80, 1.20"); return; }
  l = Math.max(0, Math.min(l, 10));
  u = Math.max(0, Math.min(u, 10));
  if (l > u) [l, u] = [u, l];

  if (lowerEl) lowerEl.value = l.toFixed(2);
  if (upperEl) upperEl.value = u.toFixed(2);
  const lowerLbl = document.getElementById("lower-variance-label");
  const upperLbl = document.getElementById("upper-variance-label");
  if (lowerLbl) lowerLbl.textContent = `Low < ${l}`;
  if (upperLbl) upperLbl.textContent = `High > ${u}`;

  const selectedVarianceLow = l;
  const selectedVarianceHigh = u;

  const RATE_FMT = "#,##0.00";
  const AMT_FMT = "#,##0";
  const GREY_200 = "FFE5E7EB";
  const HEADER_PEACH = "FFFCE4D6";
  const TOP_CATEGORY_MIN_HEIGHT = 28;
  const SPACER_ROW_HEIGHT = 15;

  const isSummary = (n) => n === "Summary";
  const isSubtotalText = (txt = "") => /sub[\s-]?total/i.test(String(txt));
  const insertWrapHints = (txt) => txt == null ? "" : String(txt).replace(/\s+/g, " ").replace(/\//g, "/\u200b").replace(/-/g, "-\u200b").trim();
  const formatSrNo = (val) => (val == null ? "" : String(val).trim());

  const estimateRowHeight = (text, colWidth, lineHeight = 16, min = 18, max = 120) => {
    const s = (text || "").toString();
    if (!s) return min;
    const hardLines = s.split(/\r\n|\n/);
    const perLineCap = Math.max(1, Math.floor(colWidth * 1.1));
    let logicalLines = 0;
    for (const ln of hardLines) logicalLines += Math.max(1, Math.ceil(ln.length / perLineCap));
    return Math.min(max, Math.max(min, logicalLines * lineHeight));
  };

  const workbook = new ExcelJS.Workbook();
  const sheetsToDownload = processedSheetNames.filter(
    (name) => consolidatedData[name] && consolidatedData[name].length > 0
  );

  const ANP_LOGO_BASE64 = "";
  let logoId = null;
  if (ANP_LOGO_BASE64 && ANP_LOGO_BASE64.includes("base64")) {
    logoId = workbook.addImage({
      base64: ANP_LOGO_BASE64.replace(/^data:image\/(png|jpeg);base64,/, ""),
      extension: ANP_LOGO_BASE64.includes("png") ? "png" : "jpeg"
    });
  }

  for (const sheetName of sheetsToDownload) {
    const sheet = workbook.addWorksheet(sheetName.substring(0, 31));
    const spacerRowNumbers = new Set();

    sheet.mergeCells("A1", "D1");
    sheet.getCell("A1").value = `Project  : ${projectName}`;
    sheet.getCell("A1").font = { bold: true };
    sheet.getCell("A1").alignment = { horizontal: "left", vertical: "middle" };
    sheet.mergeCells("A2", "D2");
    sheet.getCell("A2").value = `Scope : Civil Works`;
    sheet.getCell("A2").font = { bold: true };
    sheet.getCell("A2").alignment = { horizontal: "left", vertical: "middle" };

    sheet.getCell("E1").value = `Low: ${selectedVarianceLow}`;
    sheet.getCell("E1").fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFBFD7EA" } };
    sheet.getCell("F1").value = `High: ${selectedVarianceHigh}`;
    sheet.getCell("F1").fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFFFD2B3" } };
    sheet.getCell("E2").value = `Date: ${new Date().toLocaleDateString()}`;
    sheet.getCell("F2").value = `Rev: R0`;
    sheet.getRow(1).height = 48;
    sheet.getRow(2).height = 44;
    sheet.getColumn("E").width = 18;
    sheet.getColumn("F").width = 18;
    sheet.getColumn("G").width = 20;

    if (logoId) {
      sheet.addImage(logoId, { tl: { col: 6.8, row: 0.2 }, ext: { width: 95, height: 95 } });
    }

    if (isSummary(sheetName)) {
      sheet.addRow([]);
      const headers = ["Sl. No", "Description", "Estimate", ...bidderNames, "Least Amount"];
      const headerRow = sheet.addRow(headers);
      headerRow.font = { bold: true, color: { argb: "FF000000" } };
      headerRow.fill = { type: "pattern", pattern: "solid", fgColor: { argb: HEADER_PEACH } };
      headerRow.alignment = { horizontal: "center", vertical: "middle", wrapText: true };
      headerRow.height = 28;

      sheet.getColumn(1).width = 14;
      sheet.getColumn(1).numFmt = "@";
      sheet.getColumn(2).width = 60;
      for (let c = 3; c <= 3 + bidderNames.length; c++) {
        sheet.getColumn(c).width = 18;
        sheet.getColumn(c).numFmt = AMT_FMT;
      }
      const lastCol = 4 + bidderNames.length;
      sheet.getColumn(lastCol).width = 18;
      sheet.getColumn(lastCol).numFmt = AMT_FMT;

      const rows = consolidatedData.Summary || [];
      rows.forEach((row) => {
        const xlsRow = sheet.addRow([
          formatSrNo(row.slNo ?? ""),
          insertWrapHints(row.description || ""),
          row.estimateAmount || 0,
          ...(row.bidderAmounts || Array(bidderNames.length).fill(0)),
          row.leastAmount || 0
        ]);

        xlsRow.getCell(1).numFmt = "@";
        xlsRow.getCell(1).alignment = { horizontal: "left", vertical: "top", wrapText: true };
        xlsRow.getCell(2).alignment = { horizontal: "left", vertical: "top", wrapText: true };
        for (let c = 3; c <= lastCol; c++) xlsRow.getCell(c).alignment = { vertical: "top", horizontal: "right" };
        xlsRow.height = Math.max(28, estimateRowHeight(xlsRow.getCell(2).value, 60));

        if (row.kind === "category" || row.kind === "subtotal" || row.kind === "grand") {
          xlsRow.font = { bold: true };
          xlsRow.eachCell({ includeEmpty: true }, (cell) => {
            cell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: GREY_200 } };
            cell.alignment = { ...cell.alignment, vertical: "top" };
          });
        }
      });
      sheet.views = [{ state: "frozen", ySplit: 4 }];
    } else {
      sheet.addRow([]);
      const h1 = sheet.addRow([
        "Sl. No.","Description of Items","Unit","Estimated",null,null,
        ...bidderNames.flatMap((name) => [name, null]),"Least Bid",null
      ]);
      const h2 = sheet.addRow([
        null,null,null,"Qty","Rate","Amount",
        ...Array(bidderNames.length + 1).fill(null).flatMap(() => ["Rate","Amount"])
      ]);

      sheet.mergeCells("D4:F4");
      bidderNames.forEach((_, i) => sheet.mergeCells(4, 7 + i * 2, 4, 8 + i * 2));
      sheet.mergeCells(4, 7 + bidderNames.length * 2, 4, 8 + bidderNames.length * 2);

      [h1, h2].forEach((r) => {
        r.font = { bold: true, color: { argb: "FF000000" } };
        r.fill = { type: "pattern", pattern: "solid", fgColor: { argb: HEADER_PEACH } };
        r.alignment = { horizontal: "center", vertical: "middle", wrapText: true };
        r.height = 28;
      });

      const descWidth = 72;
      [14, descWidth, 10, 12, 12, 14, ...bidderNames.flatMap(() => [12, 14]), 12, 14]
        .forEach((w, i) => (sheet.getColumn(i + 1).width = w));
      sheet.getColumn(1).numFmt = "@";

      const isAmtOnlySheet = !!(consolidatedData[sheetName]?._isAmountOnly);

      const seenTop = new Set();
      consolidatedData[sheetName].forEach((item) => {
        const slNoStr = formatSrNo(item.slNo);
        const topKey = String(item.slNo).split('.')[0];
        const isTopCategory = item.isCategory && /^\d+(?:\.0+)?$/.test(String(item.slNo)) && !seenTop.has(topKey);
        const leastBid = findLeastBid(item);
        const isEditable = !item.isSubtotal && !item.isGrandTotal && !item.isCategory;

        const rowVals = [
          slNoStr,
          insertWrapHints(item.description),
          item.unit,
          item.qty ?? null,
          isAmtOnlySheet ? null : (isEditable ? item.estimate.rate : null),
          item.estimate.amount,
          ...item.bidders.flatMap((b) => [isAmtOnlySheet ? null : (isEditable ? b.rate : null), b.amount]),
          isAmtOnlySheet ? null : leastBid.rate,
          leastBid.amount
        ];
        const newRow = sheet.addRow(rowVals);

        newRow.getCell(1).numFmt = "@";
        newRow.getCell(1).alignment = { vertical: "top", horizontal: "left", wrapText: true };
        newRow.getCell(2).alignment = { vertical: "top", horizontal: "left", wrapText: true };
        newRow.getCell(3).alignment = { vertical: "top", horizontal: "center", wrapText: true };
        newRow.getCell(4).alignment = { vertical: "top", horizontal: "right" }; newRow.getCell(4).numFmt = AMT_FMT;
        newRow.getCell(5).alignment = { vertical: "top", horizontal: "right" }; newRow.getCell(5).numFmt = RATE_FMT;
        newRow.getCell(6).alignment = { vertical: "top", horizontal: "right" }; newRow.getCell(6).numFmt = AMT_FMT;

        for (let i = 0; i < bidderNames.length; i++) {
          newRow.getCell(7 + i * 2).alignment = { vertical: "top", horizontal: "right" };
          newRow.getCell(7 + i * 2).numFmt = RATE_FMT;
          newRow.getCell(8 + i * 2).alignment = { vertical: "top", horizontal: "right" };
          newRow.getCell(8 + i * 2).numFmt = AMT_FMT;
        }
        const leastStartCol = 7 + bidderNames.length * 2;
        newRow.getCell(leastStartCol).alignment = { vertical: "top", horizontal: "right" };
        newRow.getCell(leastStartCol).numFmt = RATE_FMT;
        newRow.getCell(leastStartCol + 1).alignment = { vertical: "top", horizontal: "right" };
        newRow.getCell(leastStartCol + 1).numFmt = AMT_FMT;

        // variance coloring (skip for amount-only)
        if (!isAmtOnlySheet) {
          item.bidders.forEach((b, i) => {
            if (item.estimate.rate && b.rate) {
              const variance = b.rate / item.estimate.rate;
              const rateCell = newRow.getCell(7 + i * 2);
              if (variance < selectedVarianceLow) {
                rateCell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFBFD7EA" } };
              } else if (variance > selectedVarianceHigh) {
                rateCell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFFFD2B3" } };
              }
            }
          });
        }

        const isSubtotal = item.isSubtotal || isSubtotalText(item.description);
        if (isSubtotal || item.isGrandTotal || isTopCategory) {
          newRow.font = { bold: true };
          newRow.eachCell({ includeEmpty: true }, (cell) => {
            cell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: GREY_200 } };
            cell.alignment = { ...cell.alignment, vertical: "top" };
          });
          newRow.height = Math.max(estimateRowHeight(item.description, descWidth), TOP_CATEGORY_MIN_HEIGHT);
          if (isTopCategory) seenTop.add(String(item.slNo));
          if (isSubtotal) {
            const spacer = sheet.addRow([]); spacer.height = SPACER_ROW_HEIGHT; spacerRowNumbers.add(spacer.number);
          }
        } else {
          newRow.height = estimateRowHeight(item.description, descWidth);
        }
      });
      sheet.views = [{ state: "frozen", ySplit: 5 }];
    }

    // borders
    sheet.eachRow((row) => {
      if (spacerRowNumbers.has(row.number)) return;
      row.eachCell({ includeEmpty: true }, (cell) => {
        cell.border = { top:{style:"thin"}, left:{style:"thin"}, bottom:{style:"thin"}, right:{style:"thin"} };
        if (cell.value == null) cell.value = "";
      });
    });
  }

  const buffer = await workbook.xlsx.writeBuffer();
  saveAs(
    new Blob([buffer], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" }),
    "DGG_Civil_CS_Consolidated_Output.xlsx"
  );
}
window.handleDownloadExcelJS = handleDownloadExcelJS;
</script>




</body>
</html>
