<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bid Comparison Application</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/exceljs/dist/exceljs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver/dist/FileSaver.min.js"></script>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />

  <style>
    /* ============================================================
       PREMIUM DARK-THEME DESIGN SYSTEM
       ============================================================ */

    /* --- Keyframe Animations --- */
    @keyframes gradientShift {
      0% {
        background-position: 0% 50%;
      }

      50% {
        background-position: 100% 50%;
      }

      100% {
        background-position: 0% 50%;
      }
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(16px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes shimmer {
      0% {
        background-position: -200% 0;
      }

      100% {
        background-position: 200% 0;
      }
    }

    @keyframes pulse-ring {
      0% {
        box-shadow: 0 0 0 0 rgba(99, 102, 241, 0.5);
      }

      70% {
        box-shadow: 0 0 0 10px rgba(99, 102, 241, 0);
      }

      100% {
        box-shadow: 0 0 0 0 rgba(99, 102, 241, 0);
      }
    }

    @keyframes slideInRight {
      from {
        opacity: 0;
        transform: translateX(20px);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    @keyframes barProgress {
      0% {
        background-position: 0% 0;
      }

      100% {
        background-position: 200% 0;
      }
    }

    @keyframes floatBadge {

      0%,
      100% {
        transform: translateY(0);
      }

      50% {
        transform: translateY(-2px);
      }
    }

    /* --- Custom Scrollbars --- */
    ::-webkit-scrollbar {
      width: 7px;
      height: 7px;
    }

    ::-webkit-scrollbar-track {
      background: #0f172a;
    }

    ::-webkit-scrollbar-thumb {
      background: #334155;
      border-radius: 10px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #475569;
    }

    * {
      scrollbar-width: thin;
      scrollbar-color: #334155 #0f172a;
    }

    /* --- Page base --- */
    body {
      font-family: "Inter", sans-serif;
      background: #060b18;
      background-image:
        radial-gradient(ellipse at 20% 0%, rgba(99, 102, 241, 0.08) 0%, transparent 60%),
        radial-gradient(ellipse at 80% 100%, rgba(139, 92, 246, 0.06) 0%, transparent 60%);
      color: #e2e8f0;
      min-height: 100vh;
    }

    /* --- Global Transitions --- */
    *,
    *::before,
    *::after {
      transition-property: background-color, border-color, color, fill, stroke, opacity, box-shadow, transform;
      transition-duration: 0.15s;
      transition-timing-function: ease;
    }

    /* --- QRO / RO / R/O rows --- */
    .qro-row td {
      background: rgba(233, 213, 255, 0.18) !important;
      border-color: rgba(233, 213, 255, 0.25) !important;
    }

    .qro-row,
    .qro-row .val {
      color: inherit !important;
    }

    /* --- Missing bidder rate --- */
    .missing-rate {
      background-color: #7f1d1d !important;
      border-color: #ef4444 !important;
      color: #ffffff !important;
    }

    /* 0-value text */
    .zero-text {
      color: #94a3b8 !important;
      opacity: .7;
    }

    .rate-input.zero-value {
      color: #94a3b8 !important;
    }

    /* ============================================================
       HEADER STYLES
       ============================================================ */
    .app-header {
      text-align: center;
      padding: 2.5rem 1rem 2rem;
      animation: fadeInUp 0.6s ease-out;
    }

    .app-header h1 {
      font-size: 2.75rem;
      font-weight: 800;
      letter-spacing: -0.025em;
      background: linear-gradient(135deg, #818cf8, #a78bfa, #c084fc);
      background-size: 200% 200%;
      animation: gradientShift 4s ease infinite;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .app-header .subtitle {
      margin-top: 0.75rem;
      font-size: 1.05rem;
      color: #94a3b8;
      font-weight: 400;
    }

    .header-accent {
      width: 80px;
      height: 3px;
      margin: 1rem auto 0;
      background: linear-gradient(90deg, #6366f1, #a78bfa, #6366f1);
      background-size: 200% 100%;
      animation: gradientShift 3s ease infinite;
      border-radius: 2px;
    }

    /* ============================================================
       UPLOAD SECTION ‚Äî GLASSMORPHISM
       ============================================================ */
    .upload-card {
      background: rgba(15, 23, 42, 0.6);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid rgba(99, 102, 241, 0.15);
      border-radius: 20px;
      padding: 2rem 2.25rem;
      box-shadow:
        0 4px 30px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.04);
      animation: fadeInUp 0.5s ease-out;
    }

    /* Drop zone styling */
    .drop-zone {
      position: relative;
      border: 2px dashed rgba(99, 102, 241, 0.3);
      border-radius: 14px;
      padding: 1.75rem 1.5rem;
      text-align: center;
      transition: all 0.25s ease;
      background: rgba(30, 41, 59, 0.4);
      cursor: pointer;
    }

    .drop-zone:hover,
    .drop-zone.drag-over {
      border-color: rgba(99, 102, 241, 0.6);
      background: rgba(99, 102, 241, 0.06);
      box-shadow: 0 0 30px rgba(99, 102, 241, 0.1);
    }

    .drop-zone .drop-icon {
      font-size: 2rem;
      margin-bottom: 0.5rem;
      display: block;
      transition: transform 0.3s ease;
    }

    .drop-zone:hover .drop-icon {
      transform: translateY(-4px) scale(1.1);
    }

    .drop-zone .drop-text {
      font-size: 0.85rem;
      color: #94a3b8;
    }

    .drop-zone .drop-text strong {
      color: #a5b4fc;
      font-weight: 600;
    }

    .drop-zone input[type="file"] {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
    }

    .section-label {
      font-size: 0.85rem;
      font-weight: 600;
      color: #cbd5e1;
      margin-bottom: 0.6rem;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .section-label .icon {
      font-size: 1rem;
    }

    /* ============================================================
       FILE CHIPS ‚Äî ENHANCED
       ============================================================ */
    .file-chip {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: linear-gradient(135deg, rgba(30, 41, 59, 0.9), rgba(51, 65, 85, 0.7));
      color: #e2e8f0;
      border: 1px solid rgba(99, 102, 241, 0.2);
      border-radius: 12px;
      padding: 8px 14px;
      font-size: 0.85rem;
      min-width: 220px;
      max-width: 320px;
      margin: 5px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.25);
      animation: slideInRight 0.3s ease-out;
    }

    .file-chip:hover {
      border-color: rgba(99, 102, 241, 0.45);
      background: linear-gradient(135deg, rgba(30, 41, 59, 1), rgba(51, 65, 85, 0.9));
      transform: translateY(-1px);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.35);
    }

    .file-chip .file-info {
      display: flex;
      flex-direction: column;
      gap: 1px;
    }

    .file-chip .file-name {
      font-weight: 600;
      color: #e2e8f0;
      font-size: 0.82rem;
    }

    .file-chip .file-size {
      font-size: 0.72rem;
      color: #64748b;
    }

    .file-chip button {
      background: rgba(239, 68, 68, 0.15);
      color: #f87171;
      border: 1px solid rgba(239, 68, 68, 0.3);
      border-radius: 6px;
      padding: 4px 8px;
      margin-left: 12px;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 600;
      transition: all 0.2s ease;
    }

    .file-chip button:hover {
      background: #ef4444;
      color: #fff;
      border-color: #ef4444;
    }

    /* ============================================================
       VARIANCE INPUTS ‚Äî MODERNIZED
       ============================================================ */
    .variance-section {
      margin-top: 1.75rem;
      padding-top: 1.5rem;
      border-top: 1px solid rgba(99, 102, 241, 0.12);
    }

    .variance-input-group {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    .variance-input-label {
      font-size: 0.8rem;
      font-weight: 600;
      color: #94a3b8;
      letter-spacing: 0.01em;
    }

    .variance-input {
      padding: 0.55rem 0.85rem;
      border: 1px solid rgba(71, 85, 105, 0.6);
      border-radius: 10px;
      font-size: 0.875rem;
      color: #e2e8f0;
      background: rgba(15, 23, 42, 0.7);
      outline: none;
      transition: all .25s ease;
      font-weight: 500;
    }

    .variance-input:focus {
      border-color: #6366f1;
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2), 0 0 20px rgba(99, 102, 241, 0.08);
      background: rgba(15, 23, 42, 0.9);
    }

    /* --- Variance legend (output section) --- */
    .variance-legend {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 1.25rem;
      margin: 0.75rem 1rem 0 0;
      font-size: 0.8rem;
      font-weight: 600;
      color: #94a3b8;
    }

    .variance-legend>div {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      padding: 4px 10px;
      background: rgba(30, 41, 59, 0.6);
      border-radius: 8px;
      border: 1px solid rgba(71, 85, 105, 0.3);
    }

    .variance-box {
      width: 14px;
      height: 14px;
      border: 2px solid;
      border-radius: 4px;
    }

    .variance-low {
      background-color: #dbeafe;
      border-color: #3b82f6;
    }

    .variance-high {
      background-color: #fed7aa;
      border-color: #f59e0b;
    }

    /* ============================================================
       ACTION BUTTONS ‚Äî PREMIUM
       ============================================================ */
    .btn-primary {
      position: relative;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.8rem 1.75rem;
      border-radius: 12px;
      font-weight: 700;
      font-size: 0.95rem;
      letter-spacing: 0.01em;
      border: none;
      cursor: pointer;
      overflow: hidden;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }

    .btn-generate {
      background: linear-gradient(135deg, #4f46e5, #7c3aed);
      color: #fff;
    }

    .btn-generate:hover {
      background: linear-gradient(135deg, #4338ca, #6d28d9);
      box-shadow: 0 6px 25px rgba(99, 102, 241, 0.4);
      transform: translateY(-2px);
    }

    .btn-generate::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
      background-size: 200% 100%;
      animation: shimmer 2.5s ease-in-out infinite;
    }

    .btn-download {
      background: linear-gradient(135deg, #059669, #10b981);
      color: #fff;
    }

    .btn-download:hover {
      background: linear-gradient(135deg, #047857, #059669);
      box-shadow: 0 6px 25px rgba(16, 185, 129, 0.35);
      transform: translateY(-2px);
    }

    /* --- Reload Button --- */
    .reload-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 44px;
      height: 44px;
      border-radius: 12px;
      border: 1px solid rgba(71, 85, 105, 0.5);
      background: rgba(30, 41, 59, 0.7);
      color: #94a3b8;
      font-size: 1.1rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .reload-btn:hover {
      background: rgba(99, 102, 241, 0.15);
      border-color: #6366f1;
      color: #a5b4fc;
      transform: rotate(180deg);
      box-shadow: 0 0 20px rgba(99, 102, 241, 0.15);
    }

    /* ============================================================
       LOADER ‚Äî ANIMATED PROGRESS BAR
       ============================================================ */
    .loader-bar {
      width: 100%;
      max-width: 400px;
      height: 4px;
      background: rgba(30, 41, 59, 0.6);
      border-radius: 4px;
      overflow: hidden;
      margin: 0 auto;
    }

    .loader-bar-inner {
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, #4f46e5, #7c3aed, #a78bfa, #7c3aed, #4f46e5);
      background-size: 200% 100%;
      animation: barProgress 1.5s ease-in-out infinite;
      border-radius: 4px;
    }

    /* ============================================================
       TABS ‚Äî PILL STYLE
       ============================================================ */
    .tab-button {
      padding: 0.7rem 1.25rem;
      border: 1px solid transparent;
      border-radius: 10px;
      font-size: 0.85rem;
      font-weight: 500;
      color: #64748b;
      background: transparent;
      cursor: pointer;
      transition: all 0.25s ease;
      white-space: nowrap;
    }

    .tab-button:hover {
      color: #a5b4fc;
      background: rgba(99, 102, 241, 0.08);
    }

    .tab-button.active {
      background: linear-gradient(135deg, rgba(79, 70, 229, 0.25), rgba(124, 58, 237, 0.2));
      border-color: rgba(99, 102, 241, 0.4);
      color: #c7d2fe;
      font-weight: 700;
      box-shadow: 0 0 20px rgba(99, 102, 241, 0.12);
    }

    /* ============================================================
       TABLE STYLES
       ============================================================ */
    .table-container {
      max-width: 1600px;
      margin: 0 auto;
      padding: 0 1rem;
      padding-bottom: 100px;
    }

    .top-scrollbar {
      overflow-x: auto;
      overflow-y: hidden;
      height: 10px;
      position: sticky;
      top: 0;
      z-index: 50;
      background: rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(4px);
      border-bottom: 1px solid rgba(55, 65, 81, 0.5);
    }

    .top-scrollbar-inner {
      height: 1px;
    }

    .table-viewport {
      max-height: 70vh;
      overflow: auto;
      background: transparent;
      border: 1px solid rgba(55, 65, 81, 0.5);
      border-top: 0;
      border-radius: 0 0 12px 12px;
    }

    table {
      border-collapse: separate;
      border-spacing: 0;
      width: max-content;
      min-width: 100%;
      font-size: 12.5px;
      line-height: 1.35;
      color: #e2e8f0;
    }

    /* Generic th/td fallback */
    th,
    td {
      border: 1px solid rgba(55, 65, 81, 0.5);
      padding: 12px 8px;
      font-size: 12px;
      white-space: nowrap;
    }

    th {
      background: linear-gradient(180deg, #1e293b, #172033);
      color: #cbd5e1;
      font-weight: 700;
      position: sticky;
      top: 0;
      z-index: 10;
      text-align: center;
      letter-spacing: .02em;
      text-transform: uppercase;
      font-size: 11px;
    }

    thead th {
      z-index: 40;
    }

    tbody td {
      vertical-align: top;
    }

    /* Alternating row stripes */
    tbody tr:nth-child(even) td {
      background-color: rgba(30, 41, 59, 0.25);
    }

    tbody tr:hover td {
      background-color: rgba(99, 102, 241, 0.04) !important;
    }

    /* --- Sticky columns --- */
    .sticky-col-1 {
      position: sticky;
      left: 0;
      z-index: 30;
      background-color: inherit;
    }

    .sticky-col-2 {
      position: sticky;
      left: 80px;
      z-index: 30;
      background-color: inherit;
    }

    td.sticky-col-1,
    td.sticky-col-2 {
      background-color: #0c1222;
    }

    td.sticky-col-2 {
      box-shadow: 4px 0 12px rgba(0, 0, 0, 0.3);
    }

    .col-slno {
      width: 80px;
      min-width: 80px;
      max-width: 120px;
    }

    .col-desc {
      width: 340px;
      min-width: 340px;
      max-width: 500px;
      white-space: normal;
      word-break: break-word;
      line-height: 1.3;
    }

    /* Description column wraps */
    td:nth-child(2),
    th:nth-child(2) {
      white-space: normal;
      line-height: 1.3;
    }

    /* --- Numeric alignment --- */
    .amount-cell,
    .total-cell,
    .least-amount-cell {
      text-align: right;
    }

    /* --- Compact stacked Rate/Amount cell --- */
    .compact-cell {
      white-space: normal;
      padding: 6px 8px;
    }

    .compact-cell .label {
      display: block;
      font-size: 10px;
      color: #64748b;
      line-height: 1.1;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    .compact-cell .val {
      display: block;
      text-align: right;
    }

    /* --- Rate Inputs --- */
    .rate-input {
      width: 100%;
      max-width: 90px;
      padding: 4px 6px;
      border: 1px solid rgba(71, 85, 105, 0.5);
      border-radius: 6px;
      text-align: right;
      background-color: rgba(15, 23, 42, 0.7);
      color: #e2e8f0;
      font-size: 12px;
      transition: all 0.2s ease;
    }

    .rate-input:focus {
      border-color: #6366f1;
      box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
      outline: none;
    }

    .rate-input:disabled {
      background-color: rgba(55, 65, 81, 0.4);
      border-color: transparent;
      color: #64748b;
    }

    /* --- Variance input colors --- */
    .bg-blue-100 {
      background-color: #dbeafe;
    }

    .bg-orange-100 {
      background-color: #fed7aa;
    }

    .rate-input.bg-blue-100 {
      border: 1px solid #3b82f6;
    }

    .rate-input.bg-orange-100 {
      border: 1px solid #f59e0b;
    }

    /* --- Row highlights --- */
    .subtotal-row {
      font-weight: bold;
      background-color: rgba(71, 85, 105, 0.6);
    }

    .grand-total-row {
      font-weight: bold;
      background-color: rgba(4, 120, 87, 0.7);
      font-size: 13.5px;
    }

    .category-header {
      font-weight: bold;
      background-color: rgba(55, 65, 81, 0.5);
    }

    .least-rate-cell,
    .least-amount-cell {
      background-color: rgba(6, 95, 70, 0.7) !important;
      font-weight: bold;
    }

    /* --- Variance input readable --- */
    .rate-input.bg-blue-100,
    .rate-input.bg-orange-100 {
      color: #111827 !important;
      caret-color: #111827 !important;
      font-weight: 600;
    }

    .rate-input.bg-blue-100 {
      background-color: #DBEAFE !important;
      border-color: #3B82F6 !important;
    }

    .rate-input.bg-orange-100 {
      background-color: #FFEDD5 !important;
      border-color: #F59E0B !important;
    }

    .rate-input.bg-blue-100::placeholder,
    .rate-input.bg-orange-100::placeholder {
      color: #6B7280;
      opacity: 1;
    }

    .rate-input.bg-blue-100:disabled,
    .rate-input.bg-orange-100:disabled {
      color: #111827 !important;
      background-color: #E5E7EB !important;
      border-color: #9CA3AF !important;
    }

    /* ============================================================
       L1 BIDDER HIGHLIGHT STYLES
       ============================================================ */
    .l1-highlight {
      background: rgba(16, 185, 129, 0.12) !important;
      box-shadow: inset 0 0 0 2px #10b981;
    }

    .l1-badge {
      display: inline-block;
      background: linear-gradient(135deg, #10b981, #059669);
      color: #fff;
      font-size: 9px;
      font-weight: 800;
      letter-spacing: 0.5px;
      padding: 2px 7px;
      border-radius: 5px;
      margin-left: 4px;
      vertical-align: middle;
      line-height: 1.4;
      text-transform: uppercase;
      box-shadow: 0 2px 6px rgba(16, 185, 129, 0.35);
      animation: floatBadge 2s ease-in-out infinite;
    }

    .l1-banner {
      margin: 20px auto;
      max-width: 680px;
      background: linear-gradient(135deg, #064e3b, #065f46, #064e3b);
      background-size: 200% 200%;
      animation: gradientShift 4s ease infinite;
      border: 1px solid rgba(16, 185, 129, 0.5);
      border-radius: 16px;
      padding: 18px 28px;
      text-align: center;
      color: #ecfdf5;
      font-size: 1.05rem;
      box-shadow: 0 8px 32px rgba(16, 185, 129, 0.2);
    }

    .l1-banner strong {
      color: #34d399;
      font-size: 1.2rem;
    }

    .l1-banner .l1-amount {
      display: block;
      margin-top: 6px;
      font-size: 1.45rem;
      font-weight: 800;
      color: #6ee7b7;
      letter-spacing: -0.01em;
    }

    td.l1-cell-highlight {
      background: rgba(16, 185, 129, 0.12) !important;
      border-left: 2px solid rgba(16, 185, 129, 0.6) !important;
      border-right: 2px solid rgba(16, 185, 129, 0.6) !important;
    }

    tr td.l1-cell-highlight:first-of-type {
      border-top: 2px solid rgba(16, 185, 129, 0.6) !important;
    }

    /* ============================================================
       RESPONSIVE
       ============================================================ */
    @media (max-width: 768px) {
      .app-header h1 {
        font-size: 1.75rem;
      }

      .upload-card {
        padding: 1.25rem;
        border-radius: 16px;
      }
    }
  </style>
</head>

<body>
  <div class="container mx-auto p-4 md:p-8" style="max-width:1400px;">

    <!-- ========== HEADER ========== -->
    <header class="app-header">
      <h1>üìä Bid Comparison Tool</h1>
      <p class="subtitle">Upload your estimate and bidder Excel sheets to generate a detailed comparative statement.</p>
      <div class="header-accent"></div>
    </header>

    <!-- ========== UPLOAD SECTION ========== -->
    <div id="upload-section" class="upload-card" style="margin-bottom:2.5rem;">
      <div class="grid grid-cols-1 md:grid-cols-2 gap-8">

        <!-- Estimate File -->
        <div>
          <div class="section-label"><span class="icon">üìÑ</span> Estimate File (Baseline)</div>
          <div class="drop-zone" id="estimate-drop-zone">
            <span class="drop-icon">üìÅ</span>
            <div class="drop-text"><strong>Click to browse</strong> or drag & drop your .xlsx file</div>
            <input type="file" id="estimate-file" accept=".xlsx" />
          </div>
          <div class="mt-3">
            <div style="font-size:0.75rem; color:#64748b; margin-bottom:4px;">Selected:</div>
            <div id="estimate-file-list" class="flex flex-wrap gap-2"></div>
          </div>
        </div>

        <!-- Bidder Files -->
        <div>
          <div class="section-label"><span class="icon">üë•</span> Bidder Files (Max 7)</div>
          <div class="drop-zone" id="bidder-drop-zone">
            <span class="drop-icon">üìÇ</span>
            <div class="drop-text"><strong>Click to browse</strong> or drag & drop .xlsx files</div>
            <input type="file" id="bidder-files" accept=".xlsx" multiple />
          </div>
          <div class="mt-3">
            <div style="font-size:0.75rem; color:#64748b; margin-bottom:4px;">
              Selected Bidders (max 7):
              <span id="bidder-count" style="color:#a5b4fc; font-weight:600;">0/7</span>
            </div>
            <div id="bidder-file-list" class="flex flex-wrap gap-2"></div>
          </div>
        </div>
      </div>

      <!-- Variance Controls -->
      <div class="variance-section">
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div class="variance-input-group">
            <label for="lower-variance" class="variance-input-label">üìâ Lower Variance Factor</label>
            <input type="number" id="lower-variance" step="0.01" min="0" max="1" value="0.8" class="variance-input" />
            <small style="color:#64748b; font-size:0.75rem; margin-top:2px;">e.g., 0.8 means -20% below estimate</small>
          </div>
          <div class="variance-input-group">
            <label for="upper-variance" class="variance-input-label">üìà Upper Variance Factor</label>
            <input type="number" id="upper-variance" step="0.01" min="1" max="2" value="1.2" class="variance-input" />
            <small style="color:#64748b; font-size:0.75rem; margin-top:2px;">e.g., 1.2 means +20% above estimate</small>
          </div>
        </div>
      </div>
    </div>

    <!-- ========== ACTION BUTTONS ========== -->
    <div style="display:flex; flex-wrap:wrap; justify-content:center; gap:1rem; margin-bottom:1.5rem;">
      <button id="process-button" class="btn-primary btn-generate">
        üöÄ Generate Comparison
      </button>
      <button id="download-button" class="btn-primary btn-download hidden">
        üì• Download as Excel
      </button>
      <button id="reload-page" class="reload-btn hidden" title="Reload Page">‚ü≥</button>
    </div>

    <!-- ========== LOADER ========== -->
    <div id="loader" class="hidden" style="text-align:center; margin-top:1.5rem;">
      <div style="display:flex; flex-direction:column; align-items:center; gap:0.75rem;">
        <div class="loader-bar">
          <div class="loader-bar-inner"></div>
        </div>
        <p style="font-size:0.85rem; color:#94a3b8;">Processing files, please wait...</p>
      </div>
    </div>
  </div>

  <!-- ========== OUTPUT SECTION ========== -->
  <div id="output-section" class="hidden">
    <div
      style="border-bottom:1px solid rgba(55,65,81,0.5); padding:0.5rem 1rem; background:rgba(15,23,42,0.5); backdrop-filter:blur(4px); position:sticky; top:0; z-index:60;">
      <nav id="tabs-container" style="display:flex; gap:0.5rem; overflow-x:auto; padding:0.25rem 0;" aria-label="Tabs">
      </nav>
    </div>

    <div class="variance-legend">
      <div class="flex items-center gap-2">
        <div class="variance-box variance-low"></div>
        <span id="lower-variance-label">0.8</span>
      </div>
      <div class="flex items-center gap-2">
        <div class="variance-box variance-high"></div>
        <span id="upper-variance-label">1.2</span>
      </div>
    </div>

    <div id="tables-container" class="mt-4" style="background:rgba(15,23,42,0.4); border-radius:12px;"></div>
  </div>
  </div>

  <script>


    /* --- VALIDATION LOGIC ENGINE --- */

    let validationErrors = [];

    // Helper to normalize strings for comparison (removes spaces, lowercase)
    const normStr = (str) => String(str || "").toLowerCase().replace(/[^a-z0-9]/g, "")


    function isLikelyHeader(cellValue) {
      if (!cellValue) return false;
      const s = String(cellValue).trim();
      // If it's a pure number like "15000" or "1.01", it's likely data, not a header
      if (/^[\d,.]+$/.test(s)) return false;
      return true;
    }

    function performDetailedValidation(estimateData, biddersData) {
      validationErrors = []; // Reset
      const sheetKeys = Object.keys(estimateData).filter(k => k !== "Summary");

      biddersData.forEach((bidderData, bIdx) => {
        const bidderName = bidderNames[bIdx];

        sheetKeys.forEach(sheetKey => {
          const estRows = estimateData[sheetKey];
          const bidRows = bidderData[sheetKey];
          const displaySheet = displayNameFor(sheetKey);

          if (!bidRows) {
            validationErrors.push({
              bidder: bidderName,
              sheet: displaySheet,
              type: "CRITICAL: Missing Sheet",
              location: "N/A",
              details: `The sheet "${displaySheet}" exists in Estimate but not in this Bidder file.`
            });
            return;
          }

          const estCfg = estRows._cfg || DEFAULT_BOQ_CONFIG;
          const bidCfg = bidRows._cfg || estCfg;

          // ... (Header Validation Logic Skipped for brevity - keep your existing header logic here if you want) ...

          // --- 3. Row-by-Row / Sl.No Validation ---

          const estMap = new Map();
          estRows.forEach(row => {
            const sl = normalizeSrNo(row[estCfg.slNoCol]);
            if (!sl) return; // FIX: Strict check (0 or "" are skipped)

            if (row[estCfg.descCol]) {
              estMap.set(sl, {
                desc: String(row[estCfg.descCol]).trim(),
                unit: String(row[estCfg.unitCol] || "").trim()
              });
            }
          });

          const bidSlNosFound = new Set();

          bidRows.forEach((row, rIdx) => {
            const sl = normalizeSrNo(row[bidCfg.slNoCol]);
            if (!sl) return; // FIX: Strict check

            bidSlNosFound.add(sl);
            const bidDesc = String(row[bidCfg.descCol] || "").trim();

            // FIX: Ignore if the bidder row is accidentally a Header row (contains "Description")
            if (/^(description|particulars|desc|items?)$/i.test(bidDesc)) return;

            // A. Check: Extra Item
            if (!estMap.has(sl)) {
              if (bidDesc && bidDesc.length > 3) { // Only flag if it has substantial text
                validationErrors.push({
                  bidder: bidderName,
                  sheet: displaySheet,
                  type: "Extra Item",
                  location: sl,
                  details: `Item '${sl}' found in Bidder, but not in Estimate.`
                });
              }
              return;
            }

            // B. Check: Data Mismatch (Description)
            const estItem = estMap.get(sl);

            if (estItem.desc && bidDesc) {
              // FIX: Increase match length to 50 chars to handle long notes properly
              const cleanEst = normStr(estItem.desc).substring(0, 50);
              const cleanBid = normStr(bidDesc).substring(0, 50);

              if (!cleanEst.includes(cleanBid) && !cleanBid.includes(cleanEst)) {
                validationErrors.push({
                  bidder: bidderName,
                  sheet: displaySheet,
                  type: "Description Mismatch",
                  location: sl,
                  details: `Estimate: "${estItem.desc.substring(0, 30)}..." \nBidder: "${bidDesc.substring(0, 30)}..."`
                });
              }
            }
          });

          // C. Check: Missing Item
          for (const [sl, info] of estMap) {
            if (!bidSlNosFound.has(sl)) {
              validationErrors.push({
                bidder: bidderName,
                sheet: displaySheet,
                type: "Missing Item",
                location: sl,
                details: `Item '${sl}' (${info.desc.substring(0, 20)}...) missing in Bidder file.`
              });
            }
          }

        });
      });

      return validationErrors.length === 0;
    }
    /* --- UI RENDERING FOR VALIDATION --- */

    /* --- UI RENDERING FOR VALIDATION --- */
    /* --- UI RENDERING FOR VALIDATION --- */
    function showValidationReport() {
      const tbody = document.getElementById("validation-table-body");
      tbody.innerHTML = "";

      validationErrors.forEach(err => {
        const tr = document.createElement("tr");

        // Define Color Classes
        let typeClass = "text-yellow-400"; // Default warning

        // üî¥ RED for Critical breaking errors and Missing items
        if (err.type.includes("CRITICAL") || err.type.includes("Missing") || err.type.includes("Mismatch")) {
          typeClass = "text-red-400 font-bold uppercase";
        }
        // üîµ BLUE for Extra items (Information only)
        if (err.type.includes("Extra")) {
          typeClass = "text-blue-300";
        }

        tr.className = "hover:bg-slate-800/50 transition-colors border-b border-slate-800";
        tr.innerHTML = `
      <td class="p-3 font-medium text-slate-200 break-words">${err.bidder}</td>
      <td class="p-3 text-slate-400 break-words">${err.sheet}</td>
      <td class="p-3 ${typeClass} break-words">${err.type}</td>
      <td class="p-3 font-mono text-slate-300 break-all">${err.location}</td>
      <td class="p-3 text-slate-400 text-xs whitespace-pre-wrap break-words">${err.details}</td>
    `;
        tbody.appendChild(tr);
      });

      // Update table header with explicitly wider Issue Type column
      const thead = document.querySelector("#validation-modal thead tr");
      if (thead) {
        thead.innerHTML = `
      <th class="p-3 text-xs font-bold uppercase tracking-wider border-b border-slate-700 w-1/12">Bidder</th>
      <th class="p-3 text-xs font-bold uppercase tracking-wider border-b border-slate-700 w-2/12">Sheet</th>
      <th class="p-3 text-xs font-bold uppercase tracking-wider border-b border-slate-700 w-3/12">Issue Type</th> <th class="p-3 text-xs font-bold uppercase tracking-wider border-b border-slate-700 w-2/12">Location</th>
      <th class="p-3 text-xs font-bold uppercase tracking-wider border-b border-slate-700 w-4/12">Details</th> `;
      }

      document.getElementById("validation-modal").classList.remove("hidden");
      document.getElementById("loader").classList.add("hidden");
      document.getElementById("btn-force-proceed").classList.remove("hidden");
    }


    function closeValidationModal() {
      document.getElementById("validation-modal").classList.add("hidden");
    }

    function forceProceedComparison() {
      closeValidationModal();
      // We need to re-trigger the consolidation step from where we paused
      finishProcessing();
    }



    /* --- ERROR MODAL FUNCTIONS --- */
    function showErrorModal(message, tip) {
      document.getElementById("error-msg-text").textContent = message;
      document.getElementById("error-tip-text").textContent = tip || "Please check your Excel files and try again.";
      document.getElementById("error-modal").classList.remove("hidden");
      document.getElementById("loader").classList.add("hidden"); // Hide loader if error
    }

    function closeErrorModal() {
      document.getElementById("error-modal").classList.add("hidden");
    }

    /* --- VALIDATION LOGIC --- */
    function validateSheets(estimateData, biddersData) {
      const estSheets = Object.keys(estimateData).filter(k => k !== "Summary");

      biddersData.forEach((bidder, idx) => {
        const bidderName = bidderNames[idx];
        const bidderSheets = Object.keys(bidder);

        estSheets.forEach(estKey => {
          // If bidder is missing a sheet that exists in estimate
          if (!bidder[estKey]) {

            // Check for "Similar" names to give a hint
            const similar = bidderSheets.find(bk => bk.includes(estKey) || estKey.includes(bk));

            let msg = `Critical Error: Bidder "${bidderName}" is missing the sheet matching "${displayNameFor(estKey)}".`;
            let tip = `The Estimate file has a sheet named "${displayNameFor(estKey)}", but the Bidder file does not.\n\n`;

            if (similar) {
              tip += `Found a similar sheet in Bidder file: "${displayNameFor(similar)}".\nPlease rename it to match exactly.`;
            } else {
              tip += `Please ensure all Bidders have the same sheet names as the Estimate.`;
            }

            throw { message: msg, tip: tip }; // Throw custom error object
          }
        });
      });
    }


    // üü¢ Global variable to track what the app is doing
    let processingContext = "Ready";



    let selectedEstimateFile = null;
    let selectedBidderFiles = [];

    const estimateListEl = document.getElementById("estimate-file-list");
    const bidderListEl = document.getElementById("bidder-file-list");
    const bidderCountEl = document.getElementById("bidder-count");

    function renderFileLists() {
      // Estimate
      estimateListEl.innerHTML = "";
      if (selectedEstimateFile) {
        const chip = document.createElement("div");
        chip.className = "file-chip";
        chip.innerHTML = `${selectedEstimateFile.name}
      <button onclick="removeEstimateFile()">√ó</button>`;
        estimateListEl.appendChild(chip);
      }

      // Bidders
      bidderListEl.innerHTML = "";
      selectedBidderFiles.forEach((file, idx) => {
        const chip = document.createElement("div");
        chip.className = "file-chip";
        chip.innerHTML = `${file.name}
      <button onclick="removeBidderFile(${idx})">√ó</button>`;
        bidderListEl.appendChild(chip);
      });
      bidderCountEl.textContent = `${selectedBidderFiles.length}/7`;
    }

    function removeEstimateFile() {
      selectedEstimateFile = null;
      document.getElementById("estimate-file").value = "";
      renderFileLists();
    }

    function removeBidderFile(index) {
      selectedBidderFiles.splice(index, 1);
      renderFileLists();
    }

    document.getElementById("estimate-file").addEventListener("change", (e) => {
      selectedEstimateFile = e.target.files[0] || null;
      renderFileLists();
    });

    document.getElementById("bidder-files").addEventListener("change", (e) => {
      const newFiles = Array.from(e.target.files);
      selectedBidderFiles = [...selectedBidderFiles, ...newFiles].slice(0, 7); // limit 7
      renderFileLists();
    });



    // ---- Professional modal flow for export ----
    const defaultProjectName =
      "Proposed Industrial Building for M/s DGG Exports Pvt. Ltd At Shiggaon, Karnataka";

    function openExportModal() {
      const modal = document.getElementById("export-modal");
      const lowIn = document.getElementById("modal-low");
      const highIn = document.getElementById("modal-high");
      const projIn = document.getElementById("modal-project");
      const scopeIn = document.getElementById("modal-scope");   // üî• new
      const errBox = document.getElementById("modal-error");

      // prefill from current UI values
      lowIn.value = document.getElementById("lower-variance").value || "0.80";
      highIn.value = document.getElementById("upper-variance").value || "1.20";
      projIn.value = projIn.value || defaultProjectName;
      scopeIn.value = scopeIn.value || "";   // üî• prefill empty or last scope if you want

      errBox.classList.add("hidden");
      errBox.textContent = "";

      modal.classList.remove("hidden");
      projIn.focus();
    }

    function closeExportModal() {
      document.getElementById("export-modal").classList.add("hidden");
    }

    function showModalError(msg) {
      const errBox = document.getElementById("modal-error");
      errBox.textContent = msg;
      errBox.classList.remove("hidden");
    }

    async function submitExportModal() {
      const projIn = document.getElementById("modal-project");
      const projectScope = document.getElementById("modal-scope").value || "Not specified"; // üî• new
      const lowInput = document.getElementById("modal-low");
      const highInput = document.getElementById("modal-high");

      let low = parseFloat(lowInput.value);
      let high = parseFloat(highInput.value);

      // --- basic validation ---
      const name = (projIn.value || "").trim();
      if (!name) return showModalError("Please enter a project name.");
      if (!isFinite(low) || !isFinite(high)) {
        return showModalError("Enter valid numbers for variance (e.g., 0.80 and 1.20).");
      }

      // clamp & normalize
      low = Math.max(0, Math.min(low, 10));
      high = Math.max(0, Math.min(high, 10));
      if (low > high) [low, high] = [high, low];

      // reflect variance into the on-screen legend/inputs
      const lowEl = document.getElementById("lower-variance");
      const highEl = document.getElementById("upper-variance");
      if (lowEl) lowEl.value = low.toFixed(2);
      if (highEl) highEl.value = high.toFixed(2);
      const lowLbl = document.getElementById("lower-variance-label");
      const highLbl = document.getElementById("upper-variance-label");
      if (lowLbl) lowLbl.textContent = `Low < ${low.toFixed(2)}`;
      if (highLbl) highLbl.textContent = `High > ${high.toFixed(2)}`;

      // must have generated a comparison first
      if (!Array.isArray(processedSheetNames) || processedSheetNames.length === 0) {
        return showModalError("Generate the comparison first, then export.");
      }

      // --- kick off the export with the chosen values ---
      const exportBtn = document.querySelector('#export-modal button[onclick="submitExportModal()"]');
      try {
        if (exportBtn) exportBtn.disabled = true;
        setUiBusy(true);                    // show spinner during export
        closeExportModal();                 // close the modal right away (optional)
        await handleDownloadExcelJS(name, low, high, projectScope);
      } catch (err) {
        console.error(err);
        showModalError("Export failed. See console for details.");
      } finally {
        setUiBusy(false);                   // hide spinner
        if (exportBtn) exportBtn.disabled = false;
      }
    }


    function validateSheets(estimateData, biddersData) {
      // Get list of data sheets (exclude Summary)
      const estSheets = Object.keys(estimateData).filter(k => k !== "Summary");

      biddersData.forEach((bidder, idx) => {
        const bidderName = bidderNames[idx];

        estSheets.forEach(estKey => {
          // If the bidder does NOT have the sheet found in Estimate
          if (!bidder[estKey]) {

            // Check if there is a sheet with a similar name (e.g. "CivilWorks" vs "Civil Works")
            // Note: Your normalizeName function handles spaces now, but this catches other typos
            const bidderSheets = Object.keys(bidder);
            const similar = bidderSheets.find(bk => bk.includes(estKey) || estKey.includes(bk));

            let msg = `Missing Sheet: The Bidder "${bidderName}" does not have a sheet matching "${displayNameFor(estKey)}".`;
            let tip = `The Estimate file has a sheet named "${displayNameFor(estKey)}".\n`;

            if (similar) {
              tip += `\nWe found a similar sheet named "${displayNameFor(similar)}".\nPlease rename it in the Excel file to match exactly.`;
            } else {
              tip += `\nPlease check the Excel file for "${bidderName}" and ensure sheet names match the Estimate.`;
            }

            // Throw custom error to be caught by handleProcessFiles
            throw { message: msg, tip: tip };
          }
        });
      });
    }



    /* ===================== Compatibility & helpers ===================== */


    // map normalized key -> real Excel sheet name (for display/export)
    let sheetDisplayNameMap = {};
    // ordered list of normalized keys from the Estimate workbook
    let estimateSheetKeysOrdered = [];

    function displayNameFor(key) {
      return (key === "Summary") ? "Summary" : (sheetDisplayNameMap[key] || key);
    }



    // recognises the Roads & Drains sheet
    const RD_BREAK_LABELS = {
      roads: [
        /\binternal\s*roads?\b/i,
        /\broads?\b/i
      ],
      swd: [
        /\bstorm\s*water\s*(?:drain|drains)\b/i,
        /\bswd\b/i,
        /\bs\/?\s*w\s*\/?\s*d\b/i
      ]
    };


    const EXCLUDE_SHEETS = [/^summary$/i, /^measure/i];

    const HEADER_SYNONYMS = {
      slNo: [
        /^(sr|sl|si|s1)\.?\s*no\.?$/i,   // ‚úÖ Added "s1" just in case
        /^(sr|sl)\.?\s*no\.?$/i,
        /^s\.?\s*no\.?$/i,
        /^s\s*no/i,
        /^serial/i,
        /^(?:item\s*)?no\.?$/i,
        /^item\s*no/i
      ],
      desc: [/^description/i, /^item\s*description/i, /^desc$/i, /^particulars/i],
      unit: [/^unit$/i, /^uom$/i, /^units?$/i],
      qty: [/^qty$/i, /^quantity$/i, /^qtty$/i],
      rate: [/^rate$/i, /^unit\s*rate$/i, /^quoted\s*rate$/i, /^basic\s*rate$/i],
      amount: [
        /^amount(?:\s*\(rs\.?\))?$/i,
        /^amt\.?$/i,
        /^line\s*amount$/i,
        /^total\s*amount$/i,
        /^amount\s*total$/i
      ]
    };

    const MEP_HEADER_SYNONYMS = {
      gf: [/^gf$/i, /ground\s*floor/i],
      oneF: [/^(1f|1\s*floor)$/i],
      tf: [/^(tf|top\s*floor|terrace\s*floor)$/i],
      tqty: [/^total\s*q(?:ty)?$/i, /^t\s*qty$/i, /^qty\s*total$/i],
      qtyAlt: [/^academic\s*qty$/i],   // <‚Äî add this

      supplyRate: [/^supply\s*rate$/i, /^s\.?\s*rate$/i],
      labourRate: [/^labou?r\s*rate$/i, /^installation\s*rate$/i, /^install(?:ation)?\s*rate$/i],
      supplyAmount: [/^supply\s*amount$/i, /^s\.?\s*amt$/i, /^supply\s*amt\.?$/i],
      labourAmount: [/^labou?r\s*amount$/i, /^installation\s*amount$/i, /^install(?:ation)?\s*amount$/i],
    };


    // Detect both the ‚ÄúQty‚Äù (simple) and ‚ÄúTotal Qty‚Äù (TQTY) styles.
    function inferSheetConfigFromWorksheetMEP(worksheet) {
      const rows = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: false, defval: "" });

      const looks = (v, re) => re.test(String(v || "").trim());
      const findIdx = (arr, re) => arr.findIndex(v => looks(v, re));

      // ---------- Two-row header: Row A has RATE/AMOUNT, Row B has SUPPLY/INSTALLATION ----------
      for (let r = 0; r < Math.min(30, rows.length - 1); r++) {
        const A = rows[r] || [];
        const B = rows[r + 1] || [];

        // Core labels on row A
        // üü¢ FIXED: Use global synonym list to catch "SI. NO."
        const sl = A.findIndex(v => looksLike(v, HEADER_SYNONYMS.slNo));

        const desc = findIdx(A, /^d(?:escr|escription)/i);
        const unit = findIdx(A, /^unit$/i);
        let qty = findIdx(A, /^(qty|quantity|qtty|total\s*q(?:ty)?|t\s*qty|academic\s*qty)$/i);
        const rate = findIdx(A, /^rate$/i);
        const amt = findIdx(A, /^amount/i);

        // ... (rest of the function remains the same)
        // Subheaders on row B (must sit under RATE/AMOUNT columns)
        const supRateCol = B.findIndex((v, i) => looks(v, /supply/i) && i >= 0 && looks(A[i], /^rate$/i));
        const insRateCol = B.findIndex((v, i) => looks(v, /install/i) && i >= 0 && looks(A[i], /^rate$/i));
        const supAmtCol = B.findIndex((v, i) => looks(v, /supply/i) && i >= 0 && looks(A[i], /^amount/i));
        const insAmtCol = B.findIndex((v, i) => looks(v, /install/i) && i >= 0 && looks(A[i], /^amount/i));

        if (qty < 0) qty = findIdx(B, /^(qty|quantity|qtty|total\s*q(?:ty)?|t\s*qty|academic\s*qty)$/i);

        const hasCore = (desc >= 0) && (qty >= 0 || supRateCol >= 0 || supAmtCol >= 0);
        const hasAnyRatesAmts = (supRateCol >= 0 || insRateCol >= 0 || supAmtCol >= 0 || insAmtCol >= 0);

        if (hasCore && hasAnyRatesAmts) {
          return {
            isMEP: true,
            startRow: r + 2,
            simpleQtyOnly: true,
            slNoCol: (sl >= 0 ? sl : undefined),
            descCol: desc,
            unitCol: (unit >= 0 ? unit : undefined),
            qtyCol: (qty >= 0 ? qty : undefined),
            supplyRateCol: (supRateCol >= 0 ? supRateCol : undefined),
            labourRateCol: (insRateCol >= 0 ? insRateCol : undefined),
            supplyAmountCol: (supAmtCol >= 0 ? supAmtCol : undefined),
            labourAmountCol: (insAmtCol >= 0 ? insAmtCol : undefined),
          };
        }
      }

      // ... (keep the rest of the function: One-row fallback) ...
      // ---------- One-row MEP header fallback (plain ‚ÄúSupply Rate‚Äù, ‚ÄúInstallation Amount‚Äù, etc.) ----------
      for (let r = 0; r < Math.min(30, rows.length); r++) {
        const row = rows[r] || [];
        const found = {};

        for (let c = 0; c < row.length; c++) {
          const cell = String(row[c]).trim();
          if (!cell) continue;

          // üü¢ FIXED: Use global synonym list here too
          if (looksLike(cell, HEADER_SYNONYMS.slNo)) found.slNoCol = c;

          if (/^d(?:escr|escription)/i.test(cell)) found.descCol = c;
          if (/^unit$/i.test(cell)) found.unitCol = c;
          if (/^(qty|quantity|qtty|total\s*q(?:ty)?|t\s*qty|academic\s*qty)$/i.test(cell)) found.qtyCol = c;

          if (/^supply\s*rate$/i.test(cell) || /^s\.?\s*rate$/i.test(cell)) found.supplyRateCol = c;
          if (/^labou?r\s*rate$/i.test(cell) || /^install(?:ation)?\s*rate$/i.test(cell)) found.labourRateCol = c;
          if (/^supply\s*amount$/i.test(cell) || /^s\.?\s*amt$/i.test(cell)) found.supplyAmountCol = c;
          if (/^labou?r\s*amount$/i.test(cell) || /^install(?:ation)?\s*amount$/i.test(cell)) found.labourAmountCol = c;
        }

        const hasQtyOrRates = (found.qtyCol != null) || (found.supplyRateCol != null) || (found.supplyAmountCol != null);
        if (found.descCol != null && hasQtyOrRates) {
          return { startRow: r + 1, ...found, isMEP: true, simpleQtyOnly: true };
        }
      }

      return null;
    }

    // ‚úÖ NEW: Removes BOM and non-printable characters before checking
    function looksLike(name, patterns) {
      const clean = String(name || "").replace(/^\uFEFF/, "").trim(); // Strip BOM & whitespace
      return patterns.some(re => re.test(clean));
    }


    function normalizeDesc(s) {
      return String(s ?? "")
        .toLowerCase()
        .replace(/\s+/g, " ")
        .replace(/[^\p{L}\p{N}\s]/gu, "")
        .trim();
    }

    function inferSheetConfigFromWorksheet(worksheet) {
      const rows = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: false, defval: "" });

      // ---- single-row header pass ----
      let best = null;
      for (let r = 0; r < Math.min(30, rows.length); r++) {
        const row = rows[r] || [];
        const found = {};

        for (let c = 0; c < row.length; c++) {
          const cell = String(row[c]).trim();
          if (!cell) continue;

          if (looksLike(cell, HEADER_SYNONYMS.slNo)) found.slNoCol = c;
          if (looksLike(cell, HEADER_SYNONYMS.desc)) found.descCol = c;
          if (looksLike(cell, HEADER_SYNONYMS.unit)) found.unitCol = c;
          if (looksLike(cell, HEADER_SYNONYMS.qty)) found.qtyCol = c;
          if (looksLike(cell, HEADER_SYNONYMS.rate)) found.rateCol = c;

          if (looksLike(cell, HEADER_SYNONYMS.amount)) {
            (found.amountCandidates ||= []).push(c);
          }
        }
        if (found.amountCandidates && found.amountCandidates.length) {
          found.amountCol = Math.max(...found.amountCandidates); // rightmost "Amount"
          delete found.amountCandidates;
        }

        const hasCore = found.slNoCol != null && found.descCol != null;
        const hasValues = found.qtyCol != null || found.rateCol != null || found.amountCol != null;
        if (!hasCore) continue;

        const score =
          (hasValues ? 10 : 0) +
          (found.unitCol != null ? 2 : 0) +
          (found.qtyCol != null ? 3 : 0) +
          (found.rateCol != null ? 3 : 0) +
          (found.amountCol != null ? 3 : 0);

        if (!best || score > best.score) best = { row: r, cols: found, score };
      }

      // ---- two-row header fallback (row r has Sl.No/Desc; row r+1 has Qty/Rate/Amount) ----
      if (!best || !(best.cols.qtyCol != null || best.cols.rateCol != null || best.cols.amountCol != null)) {
        for (let r = 0; r < Math.min(30, rows.length - 1); r++) {
          const rowA = rows[r] || [];
          const rowB = rows[r + 1] || [];
          const A = {}, B = {};

          for (let c = 0; c < rowA.length; c++) {
            const cell = String(rowA[c]).trim();
            if (!cell) continue;
            if (looksLike(cell, HEADER_SYNONYMS.slNo)) A.slNoCol = c;
            if (looksLike(cell, HEADER_SYNONYMS.desc)) A.descCol = c;
            if (looksLike(cell, HEADER_SYNONYMS.unit)) A.unitCol = c;
          }
          for (let c = 0; c < rowB.length; c++) {
            const cell = String(rowB[c]).trim();
            if (!cell) continue;
            if (looksLike(cell, HEADER_SYNONYMS.qty)) B.qtyCol = c;
            if (looksLike(cell, HEADER_SYNONYMS.rate)) B.rateCol = c;
            if (looksLike(cell, HEADER_SYNONYMS.amount)) (B.amountCandidates ||= []).push(c);
          }
          if (B.amountCandidates && B.amountCandidates.length) {
            B.amountCol = Math.max(...B.amountCandidates);
          }

          const hasCore = A.slNoCol != null && A.descCol != null;
          const hasValues = B.qtyCol != null || B.rateCol != null || B.amountCol != null;

          if (hasCore && hasValues) {
            return { startRow: r + 2, ...A, ...B }; // data starts after the subheader row
          }
        }
      }

      // ---- use best single-row header if we found one ----
      if (best) {
        const cols = { ...best.cols };

        // amount-only abstracts (no Rate/Qty but have Amount)
        if (cols.rateCol == null && cols.amountCol != null && cols.qtyCol == null) {
          cols.rateCol = cols.amountCol;
          cols.assumeQty1 = true;
          cols.amountAsRate = true;
          cols.amountOnly = true;
        }
        return { startRow: best.row + 1, ...cols };
      }

      // last resort
      return DEFAULT_BOQ_CONFIG;
    }






    // Wrapper used by parseExcelFile:
    function inferSheetConfigAuto(worksheet) {
      if (COMPARISON_MODE === 'mep') {
        const mep = inferSheetConfigFromWorksheetMEP(worksheet);
        if (mep) return mep;
      }
      // fallback to your existing logic
      return inferSheetConfigFromWorksheet(worksheet);
    }


    /* ===================== Config ===================== */
    const DEFAULT_BOQ_CONFIG = { startRow: 5, slNoCol: 0, descCol: 1, unitCol: 2, qtyCol: 3, rateCol: 4, amountCol: 5 };
    const DATA_CONFIG = {
      "BOQ-Compound Wall": { startRow: 3, slNoCol: 0, descCol: 1, unitCol: 2, qtyCol: 3, rateCol: 4, amountCol: 5 }
    };
    const ESTIMATE_CONFIG = {
      "BOQ-Compound Wall": { startRow: 4, slNoCol: 0, descCol: 1, unitCol: 2, qtyCol: 3, rateCol: 4, amountCol: 5 }
    };

    /* ===================== State & DOM ===================== */
    let consolidatedData = {};
    let bidderNames = [];
    let processedSheetNames = [];

    const processButton = document.getElementById("process-button");
    const downloadButton = document.getElementById("download-button");
    const estimateFileInput = document.getElementById("estimate-file");
    const bidderFilesInput = document.getElementById("bidder-files");
    const outputSection = document.getElementById("output-section");
    const loader = document.getElementById("loader");

    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") closeExportModal();
    });


    let COMPARISON_MODE = 'civil'; // or 'mep'

    function openModeModal() { document.getElementById('mode-modal').classList.remove('hidden'); }
    function closeModeModal() { document.getElementById('mode-modal').classList.add('hidden'); }
    function startProcessing(mode) {
      COMPARISON_MODE = (mode === 'mep') ? 'mep' : 'civil';
      closeModeModal();
      handleProcessFiles(); // continues your original flow
    }



    function setUiBusy(busy) {
      // Show/hide the same loader used by "Generate Comparison"
      loader.classList.toggle("hidden", !busy);
      // Optionally prevent double clicks
      processButton.disabled = busy;
      downloadButton.disabled = busy;
    }

    function delayedOpenExportModal(delayMs = 800) {
      // Make sure data is ready (so we don't show a modal with empty state)
      if (!Array.isArray(processedSheetNames) || processedSheetNames.length === 0) {
        alert("Generate the comparison first, then export.");
        return;
      }

      setUiBusy(true);                // show spinner
      requestAnimationFrame(() => {   // ensure the spinner paints
        setTimeout(() => {            // keep it visible for a short moment
          setUiBusy(false);           // hide spinner
          openExportModal();          // then open your modal
        }, delayMs);
      });
    }


    processButton.addEventListener("click", openModeModal);



    downloadButton.addEventListener("click", () => delayedOpenExportModal(900)); // tweak delay as you like


    function parseNumber(v) {
      if (v === null || typeof v === "undefined") return 0;
      const num = parseFloat(String(v).replace(/,/g, ""));
      return isNaN(num) ? 0 : num;
    }

    /* ===================== Main processing ===================== */
    /* ===================== Main processing ===================== */
    // We store temp data here to allow "Force Proceed"
    let tempEstimateData = null;
    let tempBiddersData = null;

    async function handleProcessFiles() {
      const estimateFile = estimateFileInput.files[0];
      const bidderFiles = bidderFilesInput.files;

      if (!estimateFile || bidderFiles.length === 0) {
        showErrorModal("Missing Files", "Please select an estimate file and at least one bidder file.");
        return;
      }
      if (bidderFiles.length > 7) {
        showErrorModal("Too Many Files", "You can select a maximum of 7 bidder files.");
        return;
      }

      loader.classList.remove("hidden");
      outputSection.classList.add("hidden");

      try {
        processingContext = "Preparing Bidder Names";
        bidderNames = Array.from(bidderFiles).map((f) =>
          f.name.split(".")[0].replace(/DGG_BIDDER_/i, "BIDDER ").trim()
        );

        // 2. Parse Estimate
        processingContext = `Parsing Estimate File: ${estimateFile.name}`;
        const estimateData = await parseExcelFile(estimateFile, true);

        // 3. Parse Bidders
        processingContext = "Parsing Bidder Files";
        const biddersData = await Promise.all(Array.from(bidderFiles).map((file) => {
          processingContext = `Parsing Bidder File: ${file.name}`;
          return parseExcelFile(file, false);
        }));

        // --- 4. NEW: DETAILED VALIDATION ---
        processingContext = "Auditing Files for Mismatches";
        const isValid = performDetailedValidation(estimateData, biddersData);

        // Store data globally in case we force proceed
        tempEstimateData = estimateData;
        tempBiddersData = biddersData;

        if (!isValid) {
          // If errors found, show report and PAUSE execution
          showValidationReport();
          return;
        }

        // If valid, proceed immediately
        finishProcessing();

      } catch (e) {
        console.error("App Error:", e);
        const msg = e.message || "Unknown Error";
        const tip = e.tip || `Error occurred during: ${processingContext}.\nCheck the browser console (F12) for technical details.`;
        showErrorModal(msg, tip);
        loader.classList.add("hidden");
      }
    }

    // Separate function to finish the job (called automatically or via "Proceed Anyway")
    function finishProcessing() {
      try {
        loader.classList.remove("hidden"); // Ensure loader is back on if we came from modal

        // 5. Consolidate
        processingContext = "Consolidating Data & Calculating Totals";

        // Use the global temp data
        const estimateData = tempEstimateData;
        const biddersData = tempBiddersData;

        processedSheetNames = [
          "Summary",
          ...estimateSheetKeysOrdered.filter((key) => !!estimateData[key])
        ];

        consolidateAllData(estimateData, biddersData);

        // 6. Update UI
        processingContext = "Rendering User Interface";
        const { lower, upper } = getVarianceThresholds();
        document.getElementById("lower-variance-label").textContent = `Low < ${lower}`;
        document.getElementById("upper-variance-label").textContent = `High > ${upper}`;

        renderUI();

        outputSection.classList.remove("hidden");
        downloadButton.classList.remove("hidden");
        document.getElementById("reload-page").classList.remove("hidden");
        processButton.classList.add("hidden");
      } catch (e) {
        showErrorModal("Processing Failed", e.message);
      } finally {
        loader.classList.add("hidden");
        processingContext = "Idle";
      }
    }


    function normalizeName(s) {
      return String(s || "").toLowerCase().replace(/\s+/g, "").trim();
    }


    // read excel (formatted text, blanks -> "")

    // read excel (formatted text, blanks -> "")
    function parseExcelFile(file, isEstimate) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();

        reader.onload = (e) => {
          try {
            const workbook = XLSX.read(new Uint8Array(e.target.result), { type: "array" });
            const parsed = {};

            // keep the estimate sheet order from this workbook, but only after filtering
            const seenEstimateKeys = new Set();

            workbook.SheetNames.forEach((sheetName) => {
              const norm = normalizeName(sheetName);

              // ‚õî skip summary/measurement tabs entirely
              if (EXCLUDE_SHEETS.some((re) => re.test(norm))) return;

              // remember original display name (proper case) for UI/Excel
              sheetDisplayNameMap[norm] = sheetName;

              // for the estimate file, remember order of *only* kept sheets
              if (isEstimate && !seenEstimateKeys.has(norm)) {
                seenEstimateKeys.add(norm);
              }

              const worksheet = workbook.Sheets[sheetName];
              if (!worksheet) return;

              const cfg =
                getConfigForSheet(sheetName, isEstimate) ||
                inferSheetConfigAuto(worksheet);

              const rows = XLSX.utils.sheet_to_json(worksheet, {
                header: 1,
                range: Math.max(0, (cfg.startRow ?? 1) - 1),
                raw: false,
                defval: "",
              });
              rows._cfg = cfg;

              parsed[norm] = rows; // store using normalized key
            });

            // update the global order list only after we‚Äôve filtered
            if (isEstimate) {
              estimateSheetKeysOrdered = Array.from(seenEstimateKeys);
            }

            resolve(parsed);
          } catch (err) {
            reject(err);
          }
        };

        reader.onerror = reject;
        reader.readAsArrayBuffer(file);
      });
    }



    function normalizeSrNo(value) {
      const s = String(value ?? "").trim();
      if (!s) return "";

      // FIX: If the cell contains only text (like "NO." or "Sr.No"), return empty to skip it
      if (/^[^0-9]+$/.test(s)) return "";

      const cleaned = s.replace(/[^\d.]/g, "");
      if (!cleaned) return "";

      if (!cleaned.includes(".")) return cleaned.replace(/^0+/, "") || "0";

      const [intPart, decPartRaw] = cleaned.split(".");
      const dec = (decPartRaw || "").replace(/[^0-9]/g, "");

      const finalVal = (dec && /^0+$/.test(dec))
        ? (intPart.replace(/^0+/, "") || "0")
        : `${intPart.replace(/^0+/, "") || "0"}.${dec}`;

      // FIX: Explicitly ignore "0", "0.", or empty results to prevent comparing Header/Note rows
      if (finalVal === "0" || finalVal === "0." || finalVal === ".") return "";

      return finalVal;
    }


    /* ---------- Build consolidated structure ---------- */

    /* ---------- Build consolidated structure (FIXED isCategory for MEP too) ---------- */

    /* ---------- Build consolidated structure (fixed bcfg typo + MEP category/abstract handling) ---------- */


    /* ---------- Totals ---------- */
    function consolidateAllData(estimateData, biddersData) {
      consolidatedData = {};

      // local regexes for markers
      const SUBTOTAL_RE = /sub[\s-]?total/i;
      const TOTAL_AMOUNT_RE = /total\s*amount/i;
      const TOTAL_OF_RE = /^total\s+of/i;
      const GRAND_RE = /\bgrand\s*total\b|^total\s+including\s+gst/i;

      for (const sheetName in estimateData) {
        const estimateRows = estimateData[sheetName];
        if (!estimateRows) continue;

        const cfg =
          (estimateRows && estimateRows._cfg) ||
          getConfigForSheet(sheetName, true) ||
          DEFAULT_BOQ_CONFIG;

        // is this an MEP-style sheet?
        const isMEPSheet = !!(cfg.isMEP || COMPARISON_MODE === "mep");

        // amount-only (CIVIL only)
        const isAmountOnlySheet =
          isMEPSheet
            ? false
            : !!(
              cfg.amountOnly ||
              cfg.amountAsRate ||
              (cfg.slNoCol == null && cfg.qtyCol == null && cfg.rateCol === cfg.amountCol)
            );

        const items = (estimateRows || [])
          .map((row) => {
            const slNoRaw = cfg.slNoCol != null ? row[cfg.slNoCol] : "";
            const slNo = String(slNoRaw || "").trim();
            const description = row[cfg.descCol] || "";
            if (!slNo && !description) return null;

            const label = String(description || "").trim();

            // Roads & Drains summary rows
            const isRoadsLine = RD_BREAK_LABELS.roads.some(re => re.test(label));
            const isSWDLine = RD_BREAK_LABELS.swd.some(re => re.test(label));
            const isRDSummaryLine = isRoadsLine || isSWDLine;

            // detect ABSTRACT anywhere
            const isAbstractRow = /\babstract\b/i.test(label);

            // ------------------- read estimate side -------------------
            let qty = 0;
            let rateFromFile = 0;
            let rawAmountFromFile = 0;

            // MEP extras
            let estSRate = 0, estLRate = 0, estSAmt = 0, estLAmt = 0;
            let gfQty = 0, oneFQty = 0, tfQty = 0;

            // detect remark qty in CIVIL (QRO/RO/R/O)
            let remarkQtyText = "";

            if (isMEPSheet) {
              const f = extractMEPFields(row, cfg);
              qty = f.qty;
              rateFromFile = f.unitRate;
              rawAmountFromFile = f.amount;
              estSRate = f.sRate; estLRate = f.lRate;
              estSAmt = f.sAmt; estLAmt = f.lAmt;
              gfQty = f.gfQty; oneFQty = f.oneFQty; tfQty = f.tfQty;
            } else {
              // CIVIL (Qty √ó Rate)
              const rawQtyCell = (cfg.qtyCol != null) ? row[cfg.qtyCol] : "";
              const maybeRemark = detectRemarkQty(rawQtyCell);
              remarkQtyText = maybeRemark || "";
              qty = parseQty(rawQtyCell);
              if (cfg.assumeQty1) qty = 1;

              // treat ABSTRACT + R/D summary as amount-only lines
              if (isRDSummaryLine || isAbstractRow) {
                const byAmount = (cfg.amountCol != null) ? parseNumber(row[cfg.amountCol]) : 0;
                const byCalc = (qty || 0) * (parseNumber(row[cfg.rateCol]) || 0);
                rateFromFile = 0;
                rawAmountFromFile = byAmount > 0 ? byAmount : byCalc;
              } else {
                const useAmtAsRate = cfg.amountAsRate;
                rateFromFile = useAmtAsRate ? parseNumber(row[cfg.amountCol]) : parseNumber(row[cfg.rateCol]);
                rawAmountFromFile = isAmountOnlySheet ? parseNumber(row[cfg.amountCol]) : 0;
              }
            }

            // mark top-level numbers (1/2/3/‚Ä¶) as category for BOTH Civil & MEP
            const isTopNumber = /^\d+(?:\.0+)?$/.test(slNo);
            const hasQty = qty > 0 || !!remarkQtyText;

            const item = {
              slNo,
              description,
              unit: row[cfg.unitCol] || "",
              qty,
              // üëá NEW: keep the exact remark text + a flag
              qtyRemark: !!remarkQtyText,
              qtyText: remarkQtyText || "",
              gfQty: gfQty || 0,
              oneFQty: oneFQty || 0,
              tfQty: tfQty || 0,
              estimate: {
                rate: (isMEPSheet || isRDSummaryLine || isAbstractRow) ? 0 : (isAmountOnlySheet ? 0 : rateFromFile),
                amount: 0,
                rawAmount: rawAmountFromFile,
                sRate: estSRate || 0,
                lRate: estLRate || 0,
                sAmount: estSAmt || 0,
                lAmount: estLAmt || 0
              },

              bidders: [],
              isSubtotal: SUBTOTAL_RE.test(description) || TOTAL_AMOUNT_RE.test(description) || TOTAL_OF_RE.test(description),
              isGrandTotal: GRAND_RE.test(description),
              isCategory: (!isAmountOnlySheet && isTopNumber && !hasQty),
              amountOnly: isMEPSheet ? false : (isAmountOnlySheet || isRDSummaryLine || isAbstractRow),
              isSummaryRow: !!isRDSummaryLine,
              isAbstract: !!isAbstractRow
            };

            const estimateKeySr = normalizeSrNo(slNo);
            const estimateKeyDesc = normalizeDesc(description);

            // ------------------- read bidders side -------------------
            biddersData.forEach((bidder, index) => {
              const bidderSheet = bidder[sheetName];
              let bRate = 0, bRawAmt = 0;
              let bSRate = 0, bLRate = 0, bSAmt = 0, bLAmt = 0;

              if (bidderSheet) {
                const bcfg =
                  (bidderSheet && bidderSheet._cfg) ||
                  getConfigForSheet(sheetName, false) ||
                  cfg;

                const estTopPrefix = (estimateKeySr && estimateKeySr.includes("."))
                  ? estimateKeySr.split(".")[0] + "."
                  : "";

                // 1) strict Sr.No match
                let match = bidderSheet.find((bRow) => {
                  const keySr = (bcfg.slNoCol != null) ? normalizeSrNo(bRow[bcfg.slNoCol]) : "";
                  return (estimateKeySr && keySr && keySr === estimateKeySr);
                });

                // 2) fallback description match
                if (!match) {
                  match = bidderSheet.find((bRow) => {
                    const keyDesc = (bcfg.descCol != null) ? normalizeDesc(bRow[bcfg.descCol]) : "";
                    const keySr = (bcfg.slNoCol != null) ? normalizeSrNo(bRow[bcfg.slNoCol]) : "";
                    if (estimateKeyDesc && keyDesc && keyDesc === estimateKeyDesc) {
                      if (estTopPrefix && keySr) return keySr.startsWith(estTopPrefix);
                      return true;
                    }
                    return false;
                  });
                }

                if (match) {
                  if (bcfg.isMEP || COMPARISON_MODE === "mep") {
                    const f = extractMEPFields(match, bcfg);
                    bRawAmt = f.amount;
                    bRate = f.unitRate;
                    bSRate = f.sRate; bLRate = f.lRate;
                    bSAmt = f.sAmt; bLAmt = f.lAmt;
                  } else {
                    if (isAbstractRow || isRDSummaryLine) {
                      const byAmount = (bcfg.amountCol != null) ? parseNumber(match[bcfg.amountCol]) : 0;
                      const byCalc = (qty || 0) * (parseNumber(match[bcfg.rateCol]) || 0);
                      bRawAmt = byAmount > 0 ? byAmount : byCalc;
                      bRate = 0;
                    } else {
                      const useAmount = bcfg.amountAsRate || (bcfg.rateCol == null && bcfg.amountCol != null);
                      if (useAmount) {
                        bRawAmt = parseNumber(match[bcfg.amountCol]) || 0;
                        bRate = 0;
                      } else {
                        bRate = parseNumber(match[bcfg.rateCol]) || 0;
                      }
                    }
                  }
                }
              }

              item.bidders.push({
                name: bidderNames[index],
                rate: bRate,
                amount: 0,
                rawAmount: bRawAmt,
                sRate: bSRate || 0, lRate: bLRate || 0, sAmount: bSAmt || 0, lAmount: bLAmt || 0
              });
            });

            return item;
          })
          .filter(Boolean);

        items._cfg = cfg;
        items._isAmountOnly = isAmountOnlySheet;

        consolidatedData[sheetName] = items;
      }

      // compute all totals & summary
      calculateAllTotals();
    }



    /* ---------- Totals (FIXED category totals for MEP S/L + ABSTRACT behavior) ---------- */
    function calculateAllTotals() {
      const summarySheetData = {};

      // -------- helper: if an ABSTRACT has no values, sum its following details --------
      function fillAbstractAmounts(sheetData) {
        for (let i = 0; i < sheetData.length; i++) {
          const row = sheetData[i];
          if (!row) continue;

          const label = String(row.description || "").trim();
          if (!/\babstract\b/i.test(label)) continue;

          // already has numbers? keep them
          const hasAny =
            Number(row.estimate?.amount || 0) > 0 ||
            (row.bidders || []).some((b) => Number(b.amount || 0) > 0);
          if (hasAny) continue;

          let est = 0;
          const bids = Array(bidderNames.length).fill(0);

          for (let j = i + 1; j < sheetData.length; j++) {
            const r = sheetData[j];
            if (!r) break;

            const rLabel = String(r.description || "").trim();

            // stop conditions
            if (r.isGrandTotal) break;
            if (/^total\s*amount/i.test(rLabel)) break;
            if (/\babstract\b/i.test(rLabel)) break;

            // skip headings & subtotals; still keep summing details
            if (r.isCategory || r.isSubtotal) continue;

            est += Number(r.estimate?.amount || 0);
            (r.bidders || []).forEach((b, k) => (bids[k] += Number(b.amount || 0)));
          }

          row.estimate.amount = est;
          (row.bidders || []).forEach((b, k) => (b.amount = bids[k]));
        }
      }

      // -------- helper: tie ABSTRACTS to the nearest neighbor SUB-TOTALS --------
      function linkAbstractsToNeighborSubtotals(sheetData) {
        if (!Array.isArray(sheetData)) return;

        // pass 1: copy the NEAREST SUB-TOTAL *above* each ABSTRACT
        let lastSubtotal = null; // {est:number, bids:number[]}
        for (let i = 0; i < sheetData.length; i++) {
          const row = sheetData[i];
          if (!row) continue;

          const label = String(row.description || "");
          const isTotalAmt = /^total\s*amount/i.test(label);

          if (row.isSubtotal && !isTotalAmt && !row.isGrandTotal) {
            lastSubtotal = {
              est: Number(row?.estimate?.amount || 0),
              bids: (row?.bidders || []).map((b) => Number(b.amount || 0)),
            };
            continue;
          }

          if (/\babstract\b/i.test(label)) {
            const abs = row;
            const alreadyHas =
              Number(abs?.estimate?.amount || 0) > 0 ||
              (abs?.bidders || []).some((b) => Number(b.amount || 0) > 0);

            if (!alreadyHas && lastSubtotal) {
              abs.estimate.amount = lastSubtotal.est || 0;
              (abs.bidders || []).forEach((b, k) => {
                b.amount = lastSubtotal.bids?.[k] || 0;
              });
            }

            // use each subtotal at most once (typical layout)
            lastSubtotal = null;
          }
        }

        // pass 2: if an ABSTRACT still has nothing, copy the FIRST SUB-TOTAL *below* it
        let pendingAbstractIdx = -1;
        for (let i = 0; i < sheetData.length; i++) {
          const row = sheetData[i];
          if (!row) continue;

          const label = String(row.description || "");
          const isAbstract = /\babstract\b/i.test(label);
          const isTotalAmt = /^total\s*amount/i.test(label);
          const isRegularSub = row.isSubtotal && !isTotalAmt && !row.isGrandTotal;

          if (isAbstract) {
            pendingAbstractIdx = i;
            continue;
          }
          if (pendingAbstractIdx >= 0 && isRegularSub) {
            const abs = sheetData[pendingAbstractIdx];
            const alreadyHas =
              Number(abs?.estimate?.amount || 0) > 0 ||
              (abs?.bidders || []).some((b) => Number(b.amount || 0) > 0);
            if (!alreadyHas) {
              abs.estimate.amount = Number(row?.estimate?.amount || 0);
              (abs.bidders || []).forEach((b, k) => {
                b.amount = Number(row?.bidders?.[k]?.amount || 0);
              });
            }
            pendingAbstractIdx = -1; // done for this ABSTRACT
          }
        }
      }

      // -------- per-sheet processing --------
      for (const sheetName of Object.keys(consolidatedData)) {
        const sheetData = consolidatedData[sheetName];
        if (!Array.isArray(sheetData)) continue;

        // ---- 1) row amounts ----
        sheetData.forEach((item) => {
          if (item.isSubtotal || item.isGrandTotal || item.isCategory) return;

          const isMEPSheet =
            COMPARISON_MODE === "mep" ||
            (consolidatedData[sheetName]?._cfg && consolidatedData[sheetName]._cfg.isMEP);

          // ‚õîÔ∏è do NOT blank rows that have remark-qty (QRO/RO/R/O)
          if (!item.amountOnly) {
            const q = Number(item.qty || 0);
            if (q === 0 && !isMEPSheet && !item.qtyRemark) {
              item.estimate.rate = "";
              item.estimate.amount = "";
              item.estimate.rawAmount = "";
              if (isMEPSheet) {
                item.estimate.sRate = "";
                item.estimate.lRate = "";
                item.estimate.sAmount = "";
                item.estimate.lAmount = "";
              }
              item.bidders.forEach((b) => {
                b.rate = "";
                b.amount = "";
                b.rawAmount = "";
                if (isMEPSheet) {
                  b.sRate = "";
                  b.lRate = "";
                  b.sAmount = "";
                  b.lAmount = "";
                }
              });
              return;
            }
          }

          if (isMEPSheet) {
            const qty = Number(item.qty || 0);
            const sRateEst = Number(item.estimate?.sRate || 0);
            const lRateEst = Number(item.estimate?.lRate || 0);
            let sAmtEst = Number(item.estimate?.sAmount || 0);
            let lAmtEst = Number(item.estimate?.lAmount || 0);

            if (sAmtEst <= 0 && sRateEst > 0 && qty > 0) sAmtEst = sRateEst * qty;
            if (lAmtEst <= 0 && lRateEst > 0 && qty > 0) lAmtEst = lRateEst * qty;

            item.estimate.sAmount = sAmtEst;
            item.estimate.lAmount = lAmtEst;

            if (!item.estimate.rate || item.estimate.rate === 0) {
              const comb = sRateEst + lRateEst;
              if (comb > 0) item.estimate.rate = comb;
              else if (qty > 0 && (sAmtEst + lAmtEst) > 0)
                item.estimate.rate = (sAmtEst + lAmtEst) / qty;
            }

            const estRaw = Number(item.estimate?.rawAmount || 0);
            if (estRaw > 0) item.estimate.amount = estRaw;
            else if (sAmtEst + lAmtEst > 0) item.estimate.amount = sAmtEst + lAmtEst;
            else item.estimate.amount = qty * Number(item.estimate.rate || 0);

            item.bidders.forEach((b) => {
              const bQty = qty;
              const sRateB = Number(b.sRate || 0);
              const lRateB = Number(b.lRate || 0);
              let sAmtB = Number(b.sAmount || 0);
              let lAmtB = Number(b.lAmount || 0);

              if (sAmtB <= 0 && sRateB > 0 && bQty > 0) sAmtB = sRateB * bQty;
              if (lAmtB <= 0 && lRateB > 0 && bQty > 0) lAmtB = lRateB * bQty;

              b.sAmount = sAmtB;
              b.lAmount = lAmtB;

              if (!b.rate || b.rate === 0) {
                const r = sRateB + lRateB;
                if (r > 0) b.rate = r;
                else if (bQty > 0 && (sAmtB + lAmtB) > 0) b.rate = (sAmtB + lAmtB) / bQty;
              }

              const raw = Number(b.rawAmount || 0);
              if (raw > 0) b.amount = raw;
              else if (sAmtB + lAmtB > 0) b.amount = sAmtB + lAmtB;
              else b.amount = bQty * Number(b.rate || 0);
            });
          } else if (item.amountOnly) {
            item.estimate.amount = Number(item.estimate.rawAmount || 0);
            item.bidders.forEach((b) => (b.amount = Number(b.rawAmount || 0)));
          } else {
            // CIVIL: here remark-qty rows keep their rate but qty=0, so amount will be 0
            const qty = Number(item.qty || 0);
            item.estimate.amount = qty * Number(item.estimate.rate || 0);
            item.bidders.forEach((b) => (b.amount = qty * Number(b.rate || 0)));
          }
        });

        // ---- 2) running subtotals ----
        let running = { estimate: 0, bidders: Array(bidderNames.length).fill(0) };

        sheetData.forEach((item) => {
          const isMEPSheet =
            COMPARISON_MODE === "mep" ||
            (sheetData?._cfg && sheetData._cfg.isMEP);

          if (item.isCategory) {
            running = { estimate: 0, bidders: Array(bidderNames.length).fill(0) };
            return;
          }

          if (item.isSubtotal) {
            const isTotalAmountLine = /^total\s*amount/i.test(String(item.description || ""));

            if (isMEPSheet && isTotalAmountLine) {
              const estFromFile =
                Number(item.estimate?.rawAmount || 0) ||
                (Number(item.estimate?.sAmount || 0) + Number(item.estimate?.lAmount || 0));
              item.estimate.amount = estFromFile > 0 ? estFromFile : running.estimate;

              item.bidders.forEach((b, i) => {
                const bidFromFile =
                  Number(b.rawAmount || 0) ||
                  (Number(b.sAmount || 0) + Number(b.lAmount || 0));
                b.amount = bidFromFile > 0 ? bidFromFile : running.bidders[i];
              });
            } else {
              item.estimate.amount = running.estimate;
              item.bidders.forEach((b, i) => (b.amount = running.bidders[i]));
            }

            running = { estimate: 0, bidders: Array(bidderNames.length).fill(0) };
            return;
          }

          // NOTE: do not add ABSTRACT rows to running totals
          if (!item.isGrandTotal && !item.isAbstract) {
            running.estimate += Number(item.estimate.amount || 0);
            item.bidders.forEach((b, i) => (running.bidders[i] += Number(b.amount || 0)));
          }
        });

        // ‚ûï bind ABSTRACT rows to neighbor subtotals (above or below)
        linkAbstractsToNeighborSubtotals(sheetData);

        // ---- 3) category totals (CIVIL & MEP) ----
        const isMEPSheet_here =
          COMPARISON_MODE === "mep" || (sheetData?._cfg && sheetData._cfg.isMEP);

        const categoryTotals = {};

        sheetData.forEach((item) => {
          const sr = String(item.slNo || "");

          const contributes =
            sr.includes(".") &&
            !item.isCategory &&
            !item.isSubtotal &&
            !item.isGrandTotal &&
            !item.isAbstract;

          if (!contributes) return;

          const top = sr.split(".")[0];
          if (!categoryTotals[top]) {
            categoryTotals[top] = {
              estimate: 0,
              bidders: Array(bidderNames.length).fill(0),
              // S/L splits for MEP views
              sEst: 0,
              lEst: 0,
              sBidders: Array(bidderNames.length).fill(0),
              lBidders: Array(bidderNames.length).fill(0),
            };
          }

          // Combined
          const estAmt = Number(item.estimate?.amount || 0);
          categoryTotals[top].estimate += estAmt;
          item.bidders.forEach((b, i) => {
            categoryTotals[top].bidders[i] += Number(b.amount || 0);
          });

          // S/L split for MEP
          if (isMEPSheet_here) {
            categoryTotals[top].sEst += Number(item.estimate?.sAmount || 0);
            categoryTotals[top].lEst += Number(item.estimate?.lAmount || 0);
            item.bidders.forEach((b, i) => {
              categoryTotals[top].sBidders[i] += Number(b.sAmount || 0);
              categoryTotals[top].lBidders[i] += Number(b.lAmount || 0);
            });
          }
        });

        // write totals back into the category header rows
        sheetData.forEach((item) => {
          const key = String(item.slNo || "").split(".")[0];
          const cat = categoryTotals[key];
          if (!item.isCategory || !cat) return;

          // combined totals
          item.estimate.amount = cat.estimate;
          item.bidders.forEach((b, i) => (b.amount = cat.bidders[i]));

          // MEP split
          if (isMEPSheet_here) {
            item.estimate.sAmount = cat.sEst;
            item.estimate.lAmount = cat.lEst;
            item.bidders.forEach((b, i) => {
              b.sAmount = cat.sBidders[i];
              b.lAmount = cat.lBidders[i];
            });
          }
        });

        // üîπ if any ABSTRACT still has no numbers, fill by summing its details
        fillAbstractAmounts(sheetData);

        // ---- 4) Handle Not Quoted Items ----
        const notQuotedItemsMap = new Map();
        const notQuotedSubTotals = Array(bidderNames.length).fill(0);
        const isMEPSheetForNq = COMPARISON_MODE === 'mep' || (sheetData?._cfg && sheetData._cfg.isMEP);

        if (!isMEPSheetForNq) { // This logic is for CIVIL mode only
          sheetData.forEach(item => {
            const isDetail = !item.isSubtotal && !item.isGrandTotal && !item.isCategory && !item.isAbstract;
            if (isDetail && Number(item.qty || 0) > 0) {
              item.bidders.forEach((b, bidderIndex) => {
                if (!b.rate || Number(b.rate) === 0) {
                  const estimateAmount = Number(item.estimate.amount || 0);
                  if (estimateAmount > 0) {
                    const key = item.slNo;

                    if (!notQuotedItemsMap.has(key)) {
                      notQuotedItemsMap.set(key, {
                        slNo: item.slNo,
                        description: item.description,
                        isNotQuotedItem: true,
                        bidders: Array(bidderNames.length).fill(null).map(() => ({ amount: '' })),
                        unit: '', qty: '', estimate: { rate: '', amount: '' },
                      });
                    }

                    const nqRowData = notQuotedItemsMap.get(key);
                    nqRowData.bidders[bidderIndex].amount = estimateAmount;

                    notQuotedSubTotals[bidderIndex] += estimateAmount;
                  }
                }
              });
            }
          });
        }
        const notQuotedItemsForDisplay = Array.from(notQuotedItemsMap.values());

        // ---- 5) grand & summary pick ----
        const isMEPSheet =
          COMPARISON_MODE === "mep" ||
          (sheetData?._cfg && sheetData._cfg.isMEP);

        const grand = { estimate: 0, bidders: Array(bidderNames.length).fill(0) };
        sheetData.forEach((item) => {
          const isDetail =
            !item.isSubtotal && !item.isGrandTotal && !item.isCategory && !item.isAbstract;
          if (isDetail) {
            grand.estimate += Number(item.estimate.amount || 0);
            item.bidders.forEach((b, i) => (grand.bidders[i] += Number(b.amount || 0)));
          }
        });

        if (!isMEPSheet) {
          // Add "not quoted" subtotals to the bidders' grand totals
          grand.bidders = grand.bidders.map((total, i) => total + notQuotedSubTotals[i]);

          let grandRowIndex = sheetData.findIndex((r) => r.isGrandTotal);
          if (grandRowIndex === -1) {
            grandRowIndex = sheetData.length;
          }

          const sectionToInsert = [];
          if (notQuotedItemsForDisplay.length > 0) {
            sectionToInsert.push({
              slNo: '', description: 'Not Quoted Items', isCategory: true,
              bidders: Array(bidderNames.length).fill(null).map(() => ({ amount: "" })),
              estimate: { amount: '' }
            });
            sectionToInsert.push(...notQuotedItemsForDisplay);
            sectionToInsert.push({
              slNo: '', description: 'Sub-Total of Not Quoted Items', isSubtotal: true,
              estimate: { amount: '' },
              bidders: notQuotedSubTotals.map(amount => ({ amount: amount }))
            });
          }

          if (sectionToInsert.length > 0) {
            sheetData.splice(grandRowIndex, 0, ...sectionToInsert);
          }

          let grandRow = sheetData.find((r) => r.isGrandTotal);
          if (!grandRow) {
            grandRow = {
              slNo: "", description: "GRAND TOTAL", unit: "", qty: "",
              estimate: { rate: 0, amount: 0 },
              bidders: bidderNames.map((n) => ({ name: n, rate: 0, amount: 0 })),
              isSubtotal: false, isGrandTotal: true, isCategory: false,
              amountOnly: sheetData._isAmountOnly,
            };
            sheetData.push(grandRow);
          }
          grandRow.estimate.amount = grand.estimate;
          grandRow.bidders.forEach((b, i) => (b.amount = grand.bidders[i]));

        } else {
          const idx = sheetData.findIndex((r) => r.isGrandTotal);
          if (idx >= 0) sheetData.splice(idx, 1);
        }

        let summaryEst = grand.estimate;
        let summaryBids = grand.bidders;

        if (isMEPSheet) {
          const totalAmtRow = sheetData.find(
            (r) => r.isSubtotal && /^total\s*amount/i.test(String(r.description || ""))
          );
          if (totalAmtRow) {
            summaryEst = Number(totalAmtRow.estimate?.amount || 0);
            summaryBids = totalAmtRow.bidders.map((b) => Number(b.amount || 0));
          }
        } else {
          // For Civil, ensure the summary reflects the grand total INCLUDING not-quoted items
          const finalGrandRow = sheetData.find(r => r.isGrandTotal);
          if (finalGrandRow) {
            summaryEst = Number(finalGrandRow.estimate.amount || 0);
            summaryBids = finalGrandRow.bidders.map(b => Number(b.amount || 0));
          }
        }

        summarySheetData[sheetName] = {
          estimateAmount: summaryEst,
          bidderAmounts: summaryBids,
        };

        // Roads/Drains breakdown
        const rdRows = sheetData.filter((r) => r.isSummaryRow);
        if (rdRows.length) {
          const breakdown = {};
          rdRows.forEach((r) => {
            breakdown[String(r.description).trim()] = {
              estimateAmount: Number(r.estimate.amount || 0),
              bidderAmounts: r.bidders.map((b) => Number(b.amount || 0)),
            };
          });
          summarySheetData.__roadsBreakdown = breakdown;
        }
      }

      // ---- 6) build summary sheet ----
      buildSummarySheet(summarySheetData);
    }


    /* ---------- Summary builder ---------- */

    function buildSummarySheet(summaryData) {
      const rows = [];
      const bidderZero = () => Array(bidderNames.length).fill(0);
      const addArr = (a, b) => a.map((v, i) => v + (b[i] || 0));

      // one row per sheet from the Estimate file, exact names, same order
      let serial = 1;
      let running = { estimateAmount: 0, bidderAmounts: bidderZero() };

      estimateSheetKeysOrdered.forEach((key) => {
        const d = summaryData[key];
        if (!d) return;
        const bids = d.bidderAmounts || bidderZero();
        const least = Math.min(...bids.filter(v => v > 0), Infinity);
        // L1 per sheet: find bidder with lowest positive amount
        const validBids = bids.map((v, i) => ({ v, i })).filter(x => x.v > 0);
        const l1Idx = validBids.length ? validBids.reduce((m, c) => c.v < m.v ? c : m, validBids[0]).i : -1;
        rows.push({
          kind: "item",
          slNo: serial++,
          description: displayNameFor(key),
          estimateAmount: d.estimateAmount || 0,
          bidderAmounts: bids,
          leastAmount: isFinite(least) ? least : 0,
          l1BidderIndex: l1Idx
        });
        running.estimateAmount += d.estimateAmount || 0;
        running.bidderAmounts = addArr(running.bidderAmounts, bids);
      });

      // TOTAL ‚Äî find overall L1
      const totalLeast = Math.min(...running.bidderAmounts.filter(v => v > 0), Infinity);
      const overallValid = running.bidderAmounts.map((v, i) => ({ v, i })).filter(x => x.v > 0);
      const overallL1Idx = overallValid.length ? overallValid.reduce((m, c) => c.v < m.v ? c : m, overallValid[0]).i : -1;
      rows.push({
        kind: "grand",
        slNo: "",
        description: "TOTAL",
        estimateAmount: running.estimateAmount,
        bidderAmounts: running.bidderAmounts,
        leastAmount: isFinite(totalLeast) ? totalLeast : 0,
        l1BidderIndex: overallL1Idx
      });

      // GST @ 18%
      const GST_RATE = 0.18;
      const gstRow = {
        kind: "item",
        slNo: "",
        description: "GST @ 18%",
        estimateAmount: running.estimateAmount * GST_RATE,
        bidderAmounts: running.bidderAmounts.map(v => v * GST_RATE),
        leastAmount: 0,
        l1BidderIndex: -1
      };
      rows.push(gstRow);

      // Total including GST
      const gstBids = running.bidderAmounts.map((v, i) => v + gstRow.bidderAmounts[i]);
      const gstValid = gstBids.map((v, i) => ({ v, i })).filter(x => x.v > 0);
      const gstL1Idx = gstValid.length ? gstValid.reduce((m, c) => c.v < m.v ? c : m, gstValid[0]).i : -1;
      rows.push({
        kind: "grand",
        slNo: "",
        description: "Total including GST Rs.",
        estimateAmount: running.estimateAmount + gstRow.estimateAmount,
        bidderAmounts: gstBids,
        leastAmount: 0,
        l1BidderIndex: gstL1Idx
      });

      consolidatedData.Summary = rows;
    }


    /* ===================== UI ===================== */

    // Friendly display names for sheets (fallback: strip "BOQ-" only)
    const SHEET_NAME_ALIASES = [
      { test: /main\s*bldg/i, name: "Main Building" },
      { test: /admin.*other.*building/i, name: "Admin‚ÄìGuest and Other Buildings" },
      { test: /admin.*&.*other/i, name: "Admin‚ÄìGuest and Other Buildings" },
      { test: /roads.*drains?|internal\s*roads?/i, name: "Internal Roads" },
      { test: /storm\s*water/i, name: "Storm Water Drain" },
      { test: /compound\s*wall/i, name: "Compound wall ‚Äì Chain Link Fence" },
      { test: /ug\s*sump/i, name: "UG Sump" }
    ];

    function prettySheetName(sheetName) {
      const raw = String(sheetName || "");
      const cleaned = raw.replace(/^\s*BOQ-?\s*/i, "");
      const hit = SHEET_NAME_ALIASES.find(a => a.test.test(cleaned));
      return hit ? hit.name : cleaned;
    }


    function renderUI() {
      renderTabs();
      const firstSheet = processedSheetNames[0];
      renderTableForSheet(firstSheet);
      const firstTab = document.querySelector(".tab-button");
      if (firstTab) firstTab.classList.add("active");
    }

    function renderTabs() {
      const tabsContainer = document.getElementById("tabs-container");
      tabsContainer.innerHTML = "";

      processedSheetNames
        .filter((key) => key === "Summary" || consolidatedData[key]) // üëà guard
        .forEach((sheetKey) => {
          const btn = document.createElement("button");
          btn.textContent = displayNameFor(sheetKey);
          btn.className =
            "tab-button border-b-2 border-transparent py-2 px-4 text-sm font-medium text-gray-300 hover:text-gray-100 hover:border-gray-500";
          btn.dataset.sheet = sheetKey;
          btn.addEventListener("click", (e) => {
            document.querySelectorAll(".tab-button").forEach((b) => b.classList.remove("active"));
            e.target.classList.add("active");
            renderTableForSheet(sheetKey);
          });
          tabsContainer.appendChild(btn);
        });
    }



    function renderTableForSheet(sheetName) {
      const tablesContainer = document.getElementById("tables-container");
      tablesContainer.innerHTML = "";
      const data = consolidatedData[sheetName];
      if (!data) {
        tablesContainer.innerHTML = `<p class="p-4">No data available for ${sheetName}.</p>`;
        return;
      }

      const tableContainer = document.createElement("div");
      tableContainer.className = "table-container";
      const topBar = document.createElement("div"); topBar.className = "top-scrollbar";
      const topInner = document.createElement("div"); topInner.className = "top-scrollbar-inner";
      topBar.appendChild(topInner);
      const viewport = document.createElement("div"); viewport.className = "table-viewport";
      const table = document.createElement("table"); table.id = `table-${sheetName.replace(/[\s&]/g, "-")}`;
      const thead = document.createElement("thead");
      const tbody = document.createElement("tbody");

      if (sheetName === "Summary") {
        renderSummaryTable(thead, tbody, data);
      } else {
        if (COMPARISON_MODE === 'mep') renderBoqTableMEP(thead, tbody, data, sheetName);
        else renderBoqTable(thead, tbody, data, sheetName); // your existing Civil layout
      }

      table.append(thead, tbody);
      viewport.appendChild(table);
      tableContainer.appendChild(topBar);
      tableContainer.appendChild(viewport);
      tablesContainer.appendChild(tableContainer);

      topInner.style.width = table.scrollWidth + "px";
      let syncing = false;
      topBar.addEventListener("scroll", () => {
        if (syncing) return; syncing = true; viewport.scrollLeft = topBar.scrollLeft; syncing = false;
      });
      viewport.addEventListener("scroll", () => {
        if (syncing) return; syncing = true; topBar.scrollLeft = viewport.scrollLeft; syncing = false;
      });

      // L1 Banner for Summary tab
      if (sheetName === "Summary" && consolidatedData.Summary) {
        const grandRow = consolidatedData.Summary.find(r => r.kind === "grand" && /total including gst/i.test(r.description || ""));
        const totalRow = grandRow || consolidatedData.Summary.find(r => r.kind === "grand");
        if (totalRow && totalRow.l1BidderIndex >= 0) {
          const l1Name = bidderNames[totalRow.l1BidderIndex];
          const l1Amount = totalRow.bidderAmounts[totalRow.l1BidderIndex] || 0;
          const bannerDiv = document.createElement("div");
          bannerDiv.className = "l1-banner";
          bannerDiv.innerHTML = `üèÜ Overall L1 Bidder: <strong>${l1Name}</strong><span class="l1-amount">‚Çπ ${formatCurrency(l1Amount)}</span>`;
          tablesContainer.appendChild(bannerDiv);
        }
      }
    }

    function renderSummaryTable(thead, tbody, data) {
      const headerRow = document.createElement("tr");
      const cols = ["Sl. No", "Description", "Estimate", ...bidderNames, "Least Amount", "L1 Bidder"];
      cols.forEach((c, i) => {
        const th = document.createElement("th");
        th.textContent = c;
        if (i === 0) th.classList.add("sticky-col-1", "col-slno");
        if (i === 1) th.classList.add("sticky-col-2", "col-desc");
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);

      data.forEach((row) => {
        const tr = document.createElement("tr");
        if (row.kind === "category") tr.className = "category-header";
        else if (row.kind === "subtotal") tr.className = "subtotal-row";
        else if (row.kind === "grand") tr.className = "grand-total-row";

        const est = row.estimateAmount || 0;
        const least = row.leastAmount || 0;
        const l1Idx = row.l1BidderIndex ?? -1;

        tr.innerHTML = `
      <td class="sticky-col-1 col-slno">${row.slNo || ""}</td>
      <td class="sticky-col-2 col-desc">${row.description || ""}</td>
      <td class="amount-cell"><span class="${zeroCls(est)}">${formatCurrency(est)}</span></td>
      ${bidderNames
            .map((_, i) => {
              const v = ((row.bidderAmounts || [])[i] || 0);
              const isL1 = (i === l1Idx);
              return `<td class="amount-cell${isL1 ? ' l1-cell-highlight' : ''}"><span class="${zeroCls(v)}">${formatCurrency(v)}</span>${isL1 ? '<span class="l1-badge">L1</span>' : ''}</td>`;
            })
            .join("")}
      <td class="least-amount-cell"><span class="${zeroCls(least)}">${formatCurrency(least)}</span></td>
      <td class="amount-cell" style="text-align:center;">${l1Idx >= 0 ? `<span class="l1-badge">${bidderNames[l1Idx]}</span>` : ''}</td>
    `;
        tbody.appendChild(tr);
      });
    }


    function renderBoqTable(thead, tbody, data, sheetName) {
      // Generate the main header for the BOQ table.
      const h1 = document.createElement("tr");
      h1.innerHTML = `
        <th rowspan="2" class="sticky-col-1 col-slno">Sl. No.</th>
        <th rowspan="2" class="sticky-col-2 col-desc">Description of Items</th>
        <th rowspan="2">Unit</th>
        <th colspan="3">Estimated</th>
        ${bidderNames.map(name => `<th colspan="2">${name}</th>`).join('')}
        <th colspan="2">Least Bid</th>
    `;
      const h2 = document.createElement("tr");
      h2.innerHTML = `
        <th>Qty</th>
        <th>Rate</th>
        <th>Amount</th>
        ${bidderNames.map(() => `<th>Rate</th><th>Amount</th>`).join('')}
        <th>Rate</th>
        <th>Amount</th>
    `;
      thead.append(h1, h2);

      const amountOnlySheet = !!data._isAmountOnly;
      const { lower, upper } = getVarianceThresholds();

      data.forEach((item, rowIndex) => {
        const tr = document.createElement("tr");
        if (item.isSubtotal) tr.className = "subtotal-row";
        else if (item.isGrandTotal) tr.className = "grand-total-row";
        else if (item.isCategory) tr.className = "category-header";

        // --- NEW: Render "Not Quoted Item" rows differently ---
        if (item.isNotQuotedItem) {
          let bidderCellsHtml = "";
          item.bidders.forEach(b => {
            const amount = b.amount ? formatCurrency(b.amount) : '';
            // These cells are for display only, not inputs
            bidderCellsHtml += `
                    <td class="compact-cell" colspan="2">
                      <span class="label">Rate</span><span class="val"></span>
                      <span class="label">Amt</span><span class="val">${amount}</span>
                    </td>`;
          });

          tr.innerHTML = `
              <td class="sticky-col-1 col-slno">${item.slNo || ""}</td>
              <td class="sticky-col-2 col-desc">${item.description || ""}</td>
              <td></td> <td class="amount-cell"></td> <td class="compact-cell" colspan="2">
                <span class="label">Rate</span><span class="val"></span>
                <span class="label">Amt</span><span class="val"></span>
              </td> ${bidderCellsHtml}
              <td class="compact-cell least-rate-cell" colspan="2">
                <span class="label">Rate</span><span class="val"></span>
                <span class="label">Amt</span><span class="val"></span>
              </td> `;
          tbody.appendChild(tr);
          return; // Done with this row, continue to the next item
        }

        const isEditable = !item.isSubtotal && !item.isGrandTotal && !item.isCategory;
        const isAbstractRow = /\babstract\b/i.test(String(item.description || ""));
        const showBlank = isEditable && !isAbstractRow && Number(item.qty || 0) === 0 && !item.qtyRemark;
        if (isAbstractRow && !tr.className) tr.className = "subtotal-row";

        const least = isEditable ? findLeastBid(item) : { rate: 0, amount: 0, l1Index: -1 };
        const l1Idx = least.l1Index ?? -1;

        let bidderCellsHtml = "";
        item.bidders.forEach((b, i) => {
          let varianceClass = "";
          if (!amountOnlySheet && isEditable && item.estimate.rate > 0 && b.rate > 0) {
            const ratio = b.rate / item.estimate.rate;
            if (ratio < lower) varianceClass = "bg-blue-100";
            else if (ratio > upper) varianceClass = "bg-orange-100";
          }
          const missing = (!amountOnlySheet && isEditable && !showBlank && isPositiveQty(item.qty) && (!b.rate || b.rate === 0));
          const isL1 = (i === l1Idx && isEditable && !showBlank);

          const rateHtml = amountOnlySheet ? `<span class="val"></span>` : (isEditable ?
            `<input type="number"
                     class="rate-input ${varianceClass} ${missing ? "missing-rate" : ""} ${(b.rate || 0) === 0 ? "zero-value" : ""}"
                     value="${showBlank ? "" : (b.rate || 0)}"
                     data-row-index="${rowIndex}" data-bidder-index="${i}"
                     onchange="handleRateChange(this, '${sheetName}')" />` :
            `<span class="val ${showBlank ? "" : zeroCls(b.rate || 0)}">${showBlank ? "" : formatCurrency(b.rate || 0)}</span>`);

          const amountVal = (item.isSubtotal || item.isGrandTotal || item.isCategory) ? b.amount : (b.amount || 0);

          bidderCellsHtml += `
            <td class="compact-cell${isL1 ? ' l1-cell-highlight' : ''}" colspan="2">
              <span class="label">Rate</span>${rateHtml}
              <span class="label">Amt</span><span class="val ${showBlank ? "" : zeroCls(amountVal)}">${showBlank ? "" : formatCurrency(amountVal)}${isL1 ? '<span class="l1-badge">L1</span>' : ''}</span>
            </td>`;
        });

        const estRate = amountOnlySheet ? "" : (showBlank ? "" : formatCurrency(item.estimate.rate || 0));
        const estAmt = showBlank ? "" : formatCurrency(item.estimate.amount || 0);

        tr.innerHTML = `
          <td class="sticky-col-1 col-slno">${item.slNo || ""}</td>
          <td class="sticky-col-2 col-desc">${item.description || ""}</td>
          <td>${item.unit || ""}</td>
          <td class="amount-cell ${showBlank ? "" : zeroCls(item.qty || 0)}">${showBlank ? "" : (item.qtyText || item.qty || "")}</td>
          <td class="compact-cell" colspan="2">
            <span class="label">Rate</span><span class="val ${showBlank ? "" : zeroCls(item.estimate.rate || 0)}">${amountOnlySheet ? "" : estRate}</span>
            <span class="label">Amt</span><span class="val ${showBlank ? "" : zeroCls(item.estimate.amount || 0)}">${estAmt}</span>
          </td>
          ${bidderCellsHtml}
          <td class="compact-cell least-rate-cell" colspan="2">
            <span class="label">Rate</span><span class="val ${showBlank ? "" : zeroCls(least.rate)}">${amountOnlySheet ? "" : (showBlank ? "" : formatCurrency(least.rate))}</span>
            <span class="label">Amt</span><span class="val ${showBlank ? "" : zeroCls(least.amount)}">${showBlank ? "" : formatCurrency(least.amount)}</span>
          </td>
        `;
        tbody.appendChild(tr);
      });
    }

    function renderBoqTableMEP(thead, tbody, data, sheetName) {
      const cfg = data._cfg || {};
      const SIMPLE = !!cfg.simpleQtyOnly || (!cfg.gfCol && !cfg.oneFCol && !cfg.tfCol);

      const h1 = document.createElement("tr");
      const h2 = document.createElement("tr");

      if (SIMPLE) {
        h1.innerHTML = `
      <th rowspan="2" class="sticky-col-1 col-slno">Sr.No.</th>
      <th rowspan="2" class="sticky-col-2 col-desc">Description of Work</th>
      <th colspan="6">Estimate</th>
      ${bidderNames.map(n => `<th colspan="4">${n}</th>`).join("")}
      <th rowspan="2">Least Amount</th>`;
        h2.innerHTML = `
      <th>Unit</th><th>Qty</th>
      <th>Supply Rate</th><th>Installation Rate</th>
      <th>Supply Amount</th><th>Installation Amount</th>
      ${bidderNames.map(() => `<th>Supply Rate</th><th>Installation Rate</th><th>Supply Amount</th><th>Installation Amount</th>`).join("")}
    `;
      } else {
        h1.innerHTML = `
      <th rowspan="2" class="sticky-col-1 col-slno">Sr.No.</th>
      <th rowspan="2" class="sticky-col-2 col-desc">Description of Work</th>
      <th colspan="9">Estimate</th>
      ${bidderNames.map(n => `<th colspan="4">${n}</th>`).join("")}
      <th rowspan="2">Least Amount</th>`;
        h2.innerHTML = `
      <th>UNIT</th><th>GF</th><th>1F</th><th>TF</th><th>TOTAL QTY</th>
      <th>Supply Rate</th><th>Installation Rate</th>
      <th>Supply Amount</th><th>Installation Amount</th>
      ${bidderNames.map(() => `<th>Supply Rate</th><th>Installation Rate</th><th>Supply Amount</th><th>Installation Amount</th>`).join("")}
    `;
      }
      thead.append(h1, h2);

      const { lower, upper } = getVarianceThresholds();

      data.forEach((item, rowIndex) => {
        const tr = document.createElement("tr");
        if (item.isSubtotal) tr.className = "subtotal-row";
        else if (item.isGrandTotal) tr.className = "grand-total-row";
        else if (item.isCategory) tr.className = "category-header";

        const isDetail = !item.isSubtotal && !item.isGrandTotal && !item.isCategory;

        // üîπ do NOT blank ABSTRACT rows
        const isAbstractRow = /\babstract\b/i.test(String(item.description || ""));
        const estUnitRate = Number(item.estimate?.sRate || 0) + Number(item.estimate?.lRate || 0);
        const blankAllMEP = (!isAbstractRow) && isDetail &&
          (Number(item.qty || 0) === 0 || estUnitRate === 0);
        if (isAbstractRow && !tr.className) tr.className = "subtotal-row";

        const least = (!item.isSubtotal && !item.isGrandTotal && !item.isCategory) ? findLeastBid(item) : { amount: 0, l1Index: -1 };
        const l1Idx = least.l1Index ?? -1;

        let bidderCellsHtml = "";

        item.bidders.forEach((b, bidderIndex) => {
          // 1. Get Values
          const sEst = Number(item.estimate.sRate || 0);
          const lEst = Number(item.estimate.lRate || 0);
          const sBid = Number(b.sRate || 0);
          const lBid = Number(b.lRate || 0);
          const hasQty = Number(item.qty || 0) > 0;
          const isL1 = (bidderIndex === l1Idx && isDetail);

          let sClass = "";
          let lClass = "";

          // 2. Supply Variance (Independent)
          if (sEst > 0 && sBid > 0) {
            const ratio = sBid / sEst;
            if (ratio < lower) sClass = "bg-blue-100";
            else if (ratio > upper) sClass = "bg-orange-100";
          }

          // 3. Installation Variance (Independent)
          if (lEst > 0 && lBid > 0) {
            const ratio = lBid / lEst;
            if (ratio < lower) lClass = "bg-blue-100";
            else if (ratio > upper) lClass = "bg-orange-100";
          }

          // 4. Missing Rate (Red) - Independent check for 0
          // If Qty > 0 and the specific rate is 0, flag it as missing/red
          const missS = hasQty && sBid === 0;
          const missL = hasQty && lBid === 0;

          bidderCellsHtml += `
        <td class="amount-cell${isL1 ? ' l1-cell-highlight' : ''}">
          <input type="number" class="rate-input ${sClass} ${missS ? "missing-rate" : ""}"
                 value="${b.sRate || 0}"
                 onchange="handleMEPRateChange(this,'${sheetName}',${rowIndex},${bidderIndex},'s')" />
        </td>
        <td class="amount-cell${isL1 ? ' l1-cell-highlight' : ''}">
          <input type="number" class="rate-input ${lClass} ${missL ? "missing-rate" : ""}"
                 value="${b.lRate || 0}"
                 onchange="handleMEPRateChange(this,'${sheetName}',${rowIndex},${bidderIndex},'l')" />
        </td>
        <td class="amount-cell${isL1 ? ' l1-cell-highlight' : ''}"><span class="${zeroCls(b.sAmount || 0)}">${formatCurrency(b.sAmount || 0)}</span></td>
        <td class="amount-cell${isL1 ? ' l1-cell-highlight' : ''}"><span class="${zeroCls(b.lAmount || 0)}">${formatCurrency(b.lAmount || 0)}${isL1 ? '<span class="l1-badge">L1</span>' : ''}</span></td>
      `;
        });

        tr.innerHTML = SIMPLE ? `
      <td class="sticky-col-1 col-slno">${item.slNo || ""}</td>
      <td class="sticky-col-2 col-desc">${item.description || ""}</td>
      <td>${item.unit || ""}</td>
      <td class="amount-cell ${zeroCls(item.qty || 0)}">${item.qty || ""}</td>
      <td class="amount-cell ${zeroCls(item.estimate.sRate || 0)}">${formatRate(item.estimate.sRate || 0)}</td>
      <td class="amount-cell ${zeroCls(item.estimate.lRate || 0)}">${formatRate(item.estimate.lRate || 0)}</td>
      <td class="amount-cell ${zeroCls(item.estimate.sAmount || 0)}">${formatCurrency(item.estimate.sAmount || 0)}</td>
      <td class="amount-cell ${zeroCls(item.estimate.lAmount || 0)}">${formatCurrency(item.estimate.lAmount || 0)}</td>
      ${bidderCellsHtml}
      <td class="least-amount-cell"><span class="${zeroCls(least.amount)}">${formatCurrency(least.amount)}</span></td>
    ` : `
      <td class="sticky-col-1 col-slno">${item.slNo || ""}</td>
      <td class="sticky-col-2 col-desc">${item.description || ""}</td>
      <td>${item.unit || ""}</td>
      <td class="amount-cell ${zeroCls(item.gfQty || 0)}">${item.gfQty || ""}</td>
      <td class="amount-cell ${zeroCls(item.oneFQty || 0)}">${item.oneFQty || ""}</td>
      <td class="amount-cell ${zeroCls(item.tfQty || 0)}">${item.tfQty || ""}</td>
      <td class="amount-cell ${zeroCls(item.qty || 0)}">${item.qty || ""}</td>
      <td class="amount-cell ${zeroCls(item.estimate.sRate || 0)}">${formatRate(item.estimate.sRate || 0)}</td>
      <td class="amount-cell ${zeroCls(item.estimate.lRate || 0)}">${formatRate(item.estimate.lRate || 0)}</td>
      <td class="amount-cell ${zeroCls(item.estimate.sAmount || 0)}">${formatCurrency(item.estimate.sAmount || 0)}</td>
      <td class="amount-cell ${zeroCls(item.estimate.lAmount || 0)}">${formatCurrency(item.estimate.lAmount || 0)}</td>
      ${bidderCellsHtml}
      <td class="least-amount-cell"><span class="${zeroCls(least.amount)}">${formatCurrency(least.amount)}</span></td>
    `;
        tbody.appendChild(tr);
      });
    }

    /* ===================== Utils ===================== */
    function handleRateChange(input, sheetName) {
      const rowIndex = parseInt(input.dataset.rowIndex);
      const bidderIndex = parseInt(input.dataset.bidderIndex);
      const newRate = parseFloat(input.value) || 0;
      if (consolidatedData[sheetName]?.[rowIndex]) {
        consolidatedData[sheetName][rowIndex].bidders[bidderIndex].rate = newRate;
      }
      calculateAllTotals();
      const activeTab = document.querySelector(".tab-button.active").dataset.sheet;
      renderTableForSheet(activeTab);

      setTimeout(() => {
        const selector = `#tables-container input[data-row-index="${rowIndex}"][data-bidder-index="${bidderIndex}"]`;
        const el = document.querySelector(selector);
        if (el) { el.focus(); el.setSelectionRange(el.value.length, el.value.length); }
      }, 0);
    }


    function handleMEPRateChange(input, sheetName, rowIndex, bidderIndex, kind) {
      const v = parseFloat(input.value) || 0;
      const item = consolidatedData[sheetName]?.[rowIndex];
      if (!item) return;

      const b = item.bidders[bidderIndex];
      if (!b) return;

      if (kind === 's') b.sRate = v; else b.lRate = v;

      // recompute derived fields
      const qty = Number(item.qty || 0);
      b.sAmount = Number(b.sRate || 0) * qty;
      b.lAmount = Number(b.lRate || 0) * qty;
      b.rate = Number(b.sRate || 0) + Number(b.lRate || 0);
      b.amount = Number(b.sAmount || 0) + Number(b.lAmount || 0);

      // refresh totals + rerender current tab
      calculateAllTotals();
      const active = document.querySelector(".tab-button.active")?.dataset.sheet || sheetName;
      renderTableForSheet(active);
    }


    function isPositiveQty(q) { return typeof q === "number" && isFinite(q) && q > 0; }
    function zeroCls(v) { return (Number(v) === 0 ? "zero-text" : ""); }


    function findLeastBid(item) {
      if (!item.bidders || !item.bidders.length) return { rate: 0, amount: 0, l1Index: -1 };

      // MEP: choose by total (S+L) amount
      if (COMPARISON_MODE === 'mep' || item.estimate?.sRate || item.estimate?.sAmount) {
        const valid = item.bidders.map((b, i) => ({ ...b, _i: i })).filter(b => (Number(b.amount || 0) > 0));
        if (!valid.length) return { rate: 0, amount: 0, l1Index: -1 };
        const min = valid.reduce((m, c) => (c.amount < m.amount ? c : m), valid[0]);
        return { rate: 0, amount: min.amount, l1Index: min._i };
      }

      // Civil (original)
      if (item.amountOnly) {
        const valid = item.bidders.map((b, i) => ({ ...b, _i: i })).filter((b) => b.amount > 0);
        if (!valid.length) return { rate: 0, amount: 0, l1Index: -1 };
        const min = valid.reduce((m, c) => (c.amount < m.amount ? c : m), valid[0]);
        return { rate: 0, amount: min.amount, l1Index: min._i };
      } else {
        const considerRate = (item.qty > 0) || !!item.qtyRemark;
        if (!considerRate) return { rate: 0, amount: 0, l1Index: -1 };
        const valid = item.bidders.map((b, i) => ({ ...b, _i: i })).filter((b) => b.rate > 0);
        if (!valid.length) return { rate: 0, amount: 0, l1Index: -1 };
        const min = valid.reduce((m, c) => (c.rate < m.rate ? c : m), valid[0]);
        return { rate: min.rate, amount: (item.qty > 0 ? min.rate * item.qty : 0), l1Index: min._i };
      }
    }

    function getConfigForSheet(sheetName, isEstimate) {
      const set = isEstimate ? ESTIMATE_CONFIG : DATA_CONFIG;
      const lower = String(sheetName || "").toLowerCase();
      for (const key in set) if (lower.includes(key.toLowerCase())) return set[key];
      return null;
    }

    function getVarianceThresholds() {
      const lower = parseFloat(document.getElementById("lower-variance").value) || 0.8;
      const upper = parseFloat(document.getElementById("upper-variance").value) || 1.2;
      return { lower, upper };
    }


    function detectRemarkQty(value) {
      const s = String(value ?? "").trim();
      return /^(?:QRO|RO|R\/O)$/i.test(s) ? s : null;   // return exact text if matches
    }


    function parseQty(value) {
      const s = String(value ?? "").trim().toUpperCase();
      if (/^(QRO|RO|R\/O)$/.test(s)) return 0;          // treat as zero numerically
      const parsedValue = parseFloat(s.replace(/[^0-9.-]+/g, ""));
      return isNaN(parsedValue) ? 0 : parsedValue;
    }


    function formatCurrency(num) {
      if (typeof num !== "number" || !isFinite(num)) return "0";
      return new Intl.NumberFormat("en-IN", { maximumFractionDigits: 0 }).format(Math.round(num));
    }

    function formatRate(num) {
      if (typeof num !== "number" || !isFinite(num)) return "0.00";
      return new Intl.NumberFormat("en-IN", { minimumFractionDigits: 2, maximumFractionDigits: 2 })
        .format(num);
    }



    function extractMEPFields(row, cfg) {
      // Floors (may be absent)
      const gf = (cfg.gfCol != null) ? parseNumber(row[cfg.gfCol]) : 0;
      const one = (cfg.oneFCol != null) ? parseNumber(row[cfg.oneFCol]) : 0;
      const tf = (cfg.tfCol != null) ? parseNumber(row[cfg.tfCol]) : 0;

      // Qty can be: Total Qty, or plain Qty, or sum of floors
      const tqty = (cfg.tqtyCol != null) ? parseNumber(row[cfg.tqtyCol]) : 0;
      const basicQty = (cfg.qtyCol != null) ? parseNumber(row[cfg.qtyCol]) : 0;

      let qty = 0;
      if (tqty > 0) qty = tqty;
      else if ((gf + one + tf) > 0) qty = gf + one + tf;
      else qty = basicQty;

      // Rates / amounts (Installation == Labour)
      const sRate = (cfg.supplyRateCol != null) ? parseNumber(row[cfg.supplyRateCol]) : 0;
      const lRate = (cfg.labourRateCol != null) ? parseNumber(row[cfg.labourRateCol]) : 0;
      const sAmt = (cfg.supplyAmountCol != null) ? parseNumber(row[cfg.supplyAmountCol]) : 0;
      const lAmt = (cfg.labourAmountCol != null) ? parseNumber(row[cfg.labourAmountCol]) : 0;

      const hasAmt = (sAmt + lAmt) > 0;
      const hasRate = (sRate + lRate) > 0;

      let unitRate = 0, amount = 0;
      if (hasAmt) amount = sAmt + lAmt;
      if (!hasAmt && hasRate && qty > 0) amount = qty * (sRate + lRate);
      if (hasRate) unitRate = sRate + lRate;
      if (!hasRate && qty > 0 && amount > 0) unitRate = amount / qty;

      return {
        gfQty: gf, oneFQty: one, tfQty: tf, qty,
        sRate, lRate, sAmt, lAmt,
        unitRate, amount
      };
    }


    /* ===================== Excel export ===================== */
    /* ===================== Excel export ===================== */
    async function handleDownloadExcelJS(projectNameArg, lowArg, highArg, scopeArg) {
      // --- 1) Gather Project Name + Variance (modal > inputs > defaults) ---
      const DEFAULT_PROJECT =
        "Proposed Industrial Building for M/s DGG Exports Pvt. Ltd At Shiggaon, Karnataka";

      let projectName = (projectNameArg ?? "").trim();
      if (!projectName) {
        const modalProject = document.getElementById("modal-project");
        projectName = (modalProject && modalProject.value.trim()) || DEFAULT_PROJECT;
      }

      let projectScope = (scopeArg ?? "").trim();
      if (!projectScope) {
        const modalScope = document.getElementById("modal-scope");
        projectScope = (modalScope && modalScope.value.trim()) || "Not specified";
      }

      let selectedVarianceLow =
        (typeof lowArg === "number" && isFinite(lowArg))
          ? lowArg
          : (parseFloat(document.getElementById("lower-variance")?.value) || 0.8);

      let selectedVarianceHigh =
        (typeof highArg === "number" && isFinite(highArg))
          ? highArg
          : (parseFloat(document.getElementById("upper-variance")?.value) || 1.2);

      // clamp + order
      selectedVarianceLow = Math.max(0, Math.min(selectedVarianceLow, 10));
      selectedVarianceHigh = Math.max(0, Math.min(selectedVarianceHigh, 10));
      if (selectedVarianceLow > selectedVarianceHigh) {
        [selectedVarianceLow, selectedVarianceHigh] = [selectedVarianceHigh, selectedVarianceLow];
      }

      // reflect back into UI labels/inputs
      const lowEl = document.getElementById("lower-variance");
      const highEl = document.getElementById("upper-variance");
      if (lowEl) lowEl.value = selectedVarianceLow.toFixed(2);
      if (highEl) highEl.value = selectedVarianceHigh.toFixed(2);
      const lowLbl = document.getElementById("lower-variance-label");
      const highLbl = document.getElementById("upper-variance-label");
      if (lowLbl) lowLbl.textContent = `Low < ${selectedVarianceLow}`;
      if (highLbl) highLbl.textContent = `High > ${selectedVarianceHigh}`;

      // --- 2) Formatting/constants for Excel ---
      const RATE_FMT = "#,##0.00";
      const AMT_FMT = "#,##0";
      const GREY_200 = "FFE5E7EB";
      const HEADER_PEACH = "FFFCE4D6";
      const TOP_CATEGORY_MIN_HEIGHT = 28;
      const SPACER_ROW_HEIGHT = 15;

      const isSummary = (n) => n === "Summary";
      const isSubtotalText = (txt = "") => /sub[\s-]?total/i.test(String(txt));
      const insertWrapHints = (txt) =>
        txt == null ? "" : String(txt)
          .replace(/\s+/g, " ")
          .replace(/\//g, "/\u200b")
          .replace(/-/g, "-\u200b")
          .trim();
      const formatSrNo = (val) => (val == null ? "" : String(val).trim());

      const estimateRowHeight = (text, colWidth, lineHeight = 16, min = 18, max = 120) => {
        const s = (text || "").toString();
        if (!s) return min;
        const hardLines = s.split(/\r\n|\n/);
        const perLineCap = Math.max(1, Math.floor(colWidth * 1.1));
        let logicalLines = 0;
        for (const ln of hardLines) logicalLines += Math.max(1, Math.ceil(ln.length / perLineCap));
        return Math.min(max, Math.max(min, logicalLines * lineHeight));
      };

      // --- 3) Build workbook ---
      const workbook = new ExcelJS.Workbook();

      const sheetsToDownload = processedSheetNames.filter(
        (name) => consolidatedData[name] && consolidatedData[name].length > 0
      );

      const ANP_LOGO_BASE64 = "";
      let logoId = null;
      if (ANP_LOGO_BASE64 && ANP_LOGO_BASE64.includes("base64")) {
        logoId = workbook.addImage({
          base64: ANP_LOGO_BASE64.replace(/^data:image\/(png|jpeg);base64,/, ""),
          extension: ANP_LOGO_BASE64.includes("png") ? "png" : "jpeg",
        });
      }

      for (const sheetName of sheetsToDownload) {
        const excelName = displayNameFor(sheetName).substring(0, 31);
        const sheet = workbook.addWorksheet(excelName);
        const spacerRowNumbers = new Set();

        // Header block
        sheet.mergeCells("A1", "D1");
        sheet.getCell("A1").value = `Project  : ${projectName}`;
        sheet.getCell("A1").font = { bold: true };
        sheet.getCell("A1").alignment = { horizontal: "left", vertical: "middle" };

        sheet.mergeCells("A2", "D2");
        sheet.getCell("A2").value = `Scope   : ${projectScope}`;
        sheet.getCell("A2").font = { bold: true };
        sheet.getCell("A2").alignment = { horizontal: "left", vertical: "middle" };

        sheet.getCell("E1").value = `Low: ${selectedVarianceLow}`;
        sheet.getCell("E1").fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFBFD7EA" } };
        sheet.getCell("F1").value = `High: ${selectedVarianceHigh}`;
        sheet.getCell("F1").fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFFFD2B3" } };
        sheet.getCell("E2").value = `Date: ${new Date().toLocaleDateString()}`;
        sheet.getCell("F2").value = "Rev: R0";

        sheet.getRow(1).height = 48;
        sheet.getRow(2).height = 44;
        sheet.getColumn("E").width = 18;
        sheet.getColumn("F").width = 18;
        sheet.getColumn("G").width = 20;

        if (logoId) {
          sheet.addImage(logoId, { tl: { col: 6.8, row: 0.2 }, ext: { width: 95, height: 95 } });
        }

        // ---------- SUMMARY ----------
        if (isSummary(sheetName)) {
          sheet.addRow([]);

          const headers = ["Sl. No", "Description", "Estimate", ...bidderNames, "Least Amount", "L1 Bidder"];
          const headerRow = sheet.addRow(headers);
          headerRow.font = { bold: true, color: { argb: "FF000000" } };
          headerRow.fill = { type: "pattern", pattern: "solid", fgColor: { argb: HEADER_PEACH } };
          headerRow.alignment = { horizontal: "center", vertical: "middle", wrapText: true };
          headerRow.height = 28;

          sheet.getColumn(1).width = 14; sheet.getColumn(1).numFmt = "@";
          sheet.getColumn(2).width = 60;
          for (let c = 3; c <= 3 + bidderNames.length; c++) {
            sheet.getColumn(c).width = 18; sheet.getColumn(c).numFmt = AMT_FMT;
          }
          const lastCol = 4 + bidderNames.length;
          sheet.getColumn(lastCol).width = 18; sheet.getColumn(lastCol).numFmt = AMT_FMT;
          const l1Col = lastCol + 1;
          sheet.getColumn(l1Col).width = 18;

          const L1_GREEN = "FFD1FAE5";   // light green fill for L1 cells
          const L1_GREEN_FONT = { bold: true, color: { argb: "FF065F46" } };

          const rows = consolidatedData.Summary || [];
          rows.forEach((row) => {
            const l1Idx = row.l1BidderIndex ?? -1;
            const xlsRow = sheet.addRow([
              formatSrNo(row.slNo ?? ""),
              insertWrapHints(row.description || ""),
              row.estimateAmount || 0,
              ...(row.bidderAmounts || Array(bidderNames.length).fill(0)),
              row.leastAmount || 0,
              l1Idx >= 0 ? bidderNames[l1Idx] : "",
            ]);

            xlsRow.getCell(1).numFmt = "@";
            xlsRow.getCell(1).alignment = { horizontal: "left", vertical: "top", wrapText: true };
            xlsRow.getCell(2).alignment = { horizontal: "left", vertical: "top", wrapText: true };
            for (let c = 3; c <= lastCol; c++) {
              xlsRow.getCell(c).alignment = { vertical: "top", horizontal: "right" };
            }
            xlsRow.getCell(l1Col).alignment = { vertical: "top", horizontal: "center" };
            xlsRow.height = Math.max(28, estimateRowHeight(xlsRow.getCell(2).value, 60));

            // Highlight L1 bidder cell green
            if (l1Idx >= 0) {
              const bidderCellCol = 4 + l1Idx; // bidder amounts start at col 4 (1-indexed: after Sl.No, Desc, Estimate)
              xlsRow.getCell(bidderCellCol).fill = { type: "pattern", pattern: "solid", fgColor: { argb: L1_GREEN } };
              xlsRow.getCell(bidderCellCol).font = L1_GREEN_FONT;
              xlsRow.getCell(l1Col).fill = { type: "pattern", pattern: "solid", fgColor: { argb: L1_GREEN } };
              xlsRow.getCell(l1Col).font = L1_GREEN_FONT;
            }

            if (row.kind === "category" || row.kind === "subtotal" || row.kind === "grand") {
              xlsRow.font = { bold: true };
              xlsRow.eachCell({ includeEmpty: true }, (cell) => {
                if (!cell.fill || cell.fill.fgColor?.argb !== L1_GREEN) {
                  cell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: GREY_200 } };
                }
                cell.alignment = { ...cell.alignment, vertical: "top" };
              });
            }
          });

          // Overall L1 annotation row
          const grandRow = rows.find(r => r.kind === "grand" && /total including gst/i.test(r.description || ""));
          const totalRow = grandRow || rows.find(r => r.kind === "grand");
          if (totalRow && (totalRow.l1BidderIndex ?? -1) >= 0) {
            sheet.addRow([]);
            const annotRow = sheet.addRow([
              "", `Overall L1 Bidder: ${bidderNames[totalRow.l1BidderIndex]}`,
              "", ...Array(bidderNames.length).fill(""),
              totalRow.bidderAmounts[totalRow.l1BidderIndex] || 0,
              bidderNames[totalRow.l1BidderIndex]
            ]);
            annotRow.font = { bold: true, size: 12, color: { argb: "FF065F46" } };
            annotRow.getCell(2).alignment = { horizontal: "left", vertical: "middle" };
            annotRow.getCell(lastCol).numFmt = AMT_FMT;
            annotRow.height = 32;
            annotRow.eachCell({ includeEmpty: true }, (cell) => {
              cell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: L1_GREEN } };
            });
          }

          sheet.views = [{ state: "frozen", ySplit: 4 }];

          sheet.eachRow((row) => {
            row.eachCell({ includeEmpty: true }, (cell) => {
              cell.border = {
                top: { style: "thin" },
                left: { style: "thin" },
                bottom: { style: "thin" },
                right: { style: "thin" },
              };
              if (cell.value == null) cell.value = "";
            });
          });

          continue; // next sheet
        }

        // ---------- MEP SHEETS ----------
        if (!isSummary(sheetName) && COMPARISON_MODE === 'mep') {
          sheet.addRow([]);

          const cfg = consolidatedData[sheetName]?._cfg || {};
          const simpleMEP = !!cfg.simpleQtyOnly || (!cfg.gfCol && !cfg.oneFCol && !cfg.tfCol);

          // 2-row header
          const h1 = sheet.addRow([
            "Sr.No.", "Description of Work",
            "Estimate", ...(simpleMEP ? Array(6 - 1).fill(null) : Array(9 - 1).fill(null)),
            ...bidderNames.flatMap(n => [n, "", "", ""]),
            "Least Amount"
          ]);
          const h2 = sheet.addRow(
            simpleMEP
              ? [null, null,
                "UNIT", "QTY", "SUPPLY RATE", "INSTALLATION RATE", "SUPPLY AMOUNT", "INSTALLATION AMOUNT",
                ...bidderNames.flatMap(() => ["SUPPLY RATE", "INSTALLATION RATE", "SUPPLY AMOUNT", "INSTALLATION AMOUNT"]),
                null]
              : [null, null,
                "UNIT", "GF", "1F", "TF", "TOTAL QTY", "SUPPLY RATE", "INSTALLATION RATE", "SUPPLY AMOUNT", "INSTALLATION AMOUNT",
                ...bidderNames.flatMap(() => ["SUPPLY RATE", "INSTALLATION RATE", "SUPPLY AMOUNT", "INSTALLATION AMOUNT"]),
                null]
          );

          sheet.mergeCells(4, 3, 4, simpleMEP ? 8 : 11);
          bidderNames.forEach((_, i) => {
            const start = (simpleMEP ? 9 : 12) + i * 4;
            sheet.mergeCells(4, start, 4, start + 3);
          });

          [h1, h2].forEach(r => {
            r.font = { bold: true, color: { argb: "FF000000" } };
            r.fill = { type: "pattern", pattern: "solid", fgColor: { argb: HEADER_PEACH } };
            r.alignment = { horizontal: "center", vertical: "middle", wrapText: true };
            r.height = 28;
          });

          const widths = simpleMEP
            ? [14, 90, 10, 12, 12, 12, 14, 14, ...bidderNames.flatMap(() => [12, 12, 14, 14]), 16]
            : [14, 90, 10, 10, 10, 10, 12, 12, 12, 14, 14, ...bidderNames.flatMap(() => [12, 12, 14, 14]), 16];
          widths.forEach((w, i) => (sheet.getColumn(i + 1).width = w));
          sheet.getColumn(1).numFmt = "@";

          const descWidth = 90;
          const seenTop = new Set();

          (consolidatedData[sheetName] || []).forEach(item => {
            const isDetail = !item.isSubtotal && !item.isGrandTotal && !item.isCategory;

            // üîπ do NOT blank ABSTRACT rows
            const isAbstract = /\babstract\b/i.test(String(item.description || ""));
            const estUnitRate = Number(item.estimate?.sRate || 0) + Number(item.estimate?.lRate || 0);
            const blankAllMEP = !isAbstract && isDetail &&
              (Number(item.qty || 0) === 0 || estUnitRate === 0);

            const leastObj = (!blankAllMEP && item.bidders && item.bidders.length)
              ? findLeastBid(item)
              : { amount: 0, l1Index: -1 };
            const least = leastObj.amount || null;
            const mepL1Idx = leastObj.l1Index ?? -1;

            const rowVals = [
              String(item.slNo ?? ""),
              insertWrapHints(item.description || ""),
            ];

            if (simpleMEP) {
              rowVals.push(
                item.unit || "",
                blankAllMEP ? null : (item.qty || 0),
                blankAllMEP ? null : (item.estimate.sRate || 0),
                blankAllMEP ? null : (item.estimate.lRate || 0),
                blankAllMEP ? null : (item.estimate.sAmount || 0),
                blankAllMEP ? null : (item.estimate.lAmount || 0),
                ...item.bidders.flatMap(b => [
                  blankAllMEP ? null : (b.sRate || 0),
                  blankAllMEP ? null : (b.lRate || 0),
                  blankAllMEP ? null : (b.sAmount || 0),
                  blankAllMEP ? null : (b.lAmount || 0),
                ]),
                blankAllMEP ? null : least
              );
            } else {
              rowVals.push(
                item.unit || "",
                blankAllMEP ? null : (item.gfQty || 0),
                blankAllMEP ? null : (item.oneFQty || 0),
                blankAllMEP ? null : (item.tfQty || 0),
                blankAllMEP ? null : (item.qty || 0),
                blankAllMEP ? null : (item.estimate.sRate || 0),
                blankAllMEP ? null : (item.estimate.lRate || 0),
                blankAllMEP ? null : (item.estimate.sAmount || 0),
                blankAllMEP ? null : (item.estimate.lAmount || 0),
                ...item.bidders.flatMap(b => [
                  blankAllMEP ? null : (b.sRate || 0),
                  blankAllMEP ? null : (b.lRate || 0),
                  blankAllMEP ? null : (b.sAmount || 0),
                  blankAllMEP ? null : (b.lAmount || 0),
                ]),
                blankAllMEP ? null : least
              );
            }

            const row = sheet.addRow(rowVals);

            // formats & alignment (unchanged) ...
            row.getCell(1).numFmt = "@";
            row.getCell(1).alignment = { vertical: "top", horizontal: "left", wrapText: true };
            row.getCell(2).alignment = { vertical: "top", horizontal: "left", wrapText: true };

            if (simpleMEP) {
              row.getCell(3).alignment = { vertical: "top", horizontal: "center" };
              row.getCell(4).alignment = { vertical: "top", horizontal: "right" }; row.getCell(4).numFmt = "#,##0";
              row.getCell(5).alignment = { vertical: "top", horizontal: "right" }; row.getCell(5).numFmt = RATE_FMT;
              row.getCell(6).alignment = { vertical: "top", horizontal: "right" }; row.getCell(6).numFmt = RATE_FMT;
              row.getCell(7).alignment = { vertical: "top", horizontal: "right" }; row.getCell(7).numFmt = AMT_FMT;
              row.getCell(8).alignment = { vertical: "top", horizontal: "right" }; row.getCell(8).numFmt = AMT_FMT;

              const startBid = 9;
              const endBid = 9 + 4 * bidderNames.length - 1;
              for (let c = startBid; c <= endBid; c++) {
                const idxInQuad = (c - startBid + 1) % 4;
                row.getCell(c).alignment = { vertical: "top", horizontal: "right" };
                row.getCell(c).numFmt = (idxInQuad === 1 || idxInQuad === 2) ? RATE_FMT : AMT_FMT;
              }
              const leastCol = endBid + 1;
              row.getCell(leastCol).alignment = { vertical: "top", horizontal: "right" };
              row.getCell(leastCol).numFmt = AMT_FMT;

              // ... inside simpleMEP block ...
              if (!blankAllMEP && isDetail) {
                // 1. Get separate Estimate rates
                const sEst = Number(item.estimate.sRate || 0);
                const lEst = Number(item.estimate.lRate || 0);

                for (let i = 0; i < bidderNames.length; i++) {
                  const sCol = startBid + i * 4;
                  const lCol = sCol + 1;
                  const sRate = Number(row.getCell(sCol).value || 0);
                  const lRate = Number(row.getCell(lCol).value || 0);

                  // 2. Apply Supply Variance INDEPENDENTLY
                  if (sEst > 0 && sRate > 0) {
                    const ratio = sRate / sEst;
                    if (ratio < selectedVarianceLow)
                      row.getCell(sCol).fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFBFD7EA" } }; // Blue
                    else if (ratio > selectedVarianceHigh)
                      row.getCell(sCol).fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFFFD2B3" } }; // Orange
                  }

                  // 3. Apply Installation Variance INDEPENDENTLY
                  if (lEst > 0 && lRate > 0) {
                    const ratio = lRate / lEst;
                    if (ratio < selectedVarianceLow)
                      row.getCell(lCol).fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFBFD7EA" } }; // Blue
                    else if (ratio > selectedVarianceHigh)
                      row.getCell(lCol).fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFFFD2B3" } }; // Orange
                  }

                  // 4. Missing Rate Check (Red) - Overrides previous colors if 0
                  if (Number(item.qty || 0) > 0) {
                    if (sRate === 0) {
                      const cell = row.getCell(sCol);
                      cell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FF7F1D1D" } };
                      cell.font = { color: { argb: "FFFFFFFF" }, bold: true };
                    }
                    if (lRate === 0) {
                      const cell = row.getCell(lCol);
                      cell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FF7F1D1D" } };
                      cell.font = { color: { argb: "FFFFFFFF" }, bold: true };
                    }
                  }
                }
              }
            } else {
              // complex (GF/1F/TF/TQTY) formatting ‚Äî unchanged...
              row.getCell(3).alignment = { vertical: "top", horizontal: "center" };
              [4, 5, 6, 7].forEach(c => { row.getCell(c).alignment = { vertical: "top", horizontal: "right" }; row.getCell(c).numFmt = "#,##0"; });
              row.getCell(8).alignment = { vertical: "top", horizontal: "right" }; row.getCell(8).numFmt = RATE_FMT;
              row.getCell(9).alignment = { vertical: "top", horizontal: "right" }; row.getCell(9).numFmt = RATE_FMT;
              row.getCell(10).alignment = { vertical: "top", horizontal: "right" }; row.getCell(10).numFmt = AMT_FMT;
              row.getCell(11).alignment = { vertical: "top", horizontal: "right" }; row.getCell(11).numFmt = AMT_FMT;

              const startBid = 12;
              const endBid = 12 + 4 * bidderNames.length - 1;
              for (let c = startBid; c <= endBid; c++) {
                const idxInQuad = (c - startBid + 1) % 4;
                row.getCell(c).alignment = { vertical: "top", horizontal: "right" };
                row.getCell(c).numFmt = (idxInQuad === 1 || idxInQuad === 2) ? RATE_FMT : AMT_FMT;
              }
              const leastCol = endBid + 1;
              row.getCell(leastCol).alignment = { vertical: "top", horizontal: "right" };
              row.getCell(leastCol).numFmt = AMT_FMT;

              // ... inside the complex MEP block ...
              if (!blankAllMEP && isDetail) {
                // 1. Get separate Estimate rates
                const sEst = Number(item.estimate.sRate || 0);
                const lEst = Number(item.estimate.lRate || 0);

                for (let i = 0; i < bidderNames.length; i++) {
                  const sCol = 12 + i * 4;
                  const lCol = sCol + 1;
                  const sRate = Number(row.getCell(sCol).value || 0);
                  const lRate = Number(row.getCell(lCol).value || 0);

                  // 2. Apply Supply Variance INDEPENDENTLY
                  if (sEst > 0 && sRate > 0) {
                    const ratio = sRate / sEst;
                    if (ratio < selectedVarianceLow)
                      row.getCell(sCol).fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFBFD7EA" } };
                    else if (ratio > selectedVarianceHigh)
                      row.getCell(sCol).fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFFFD2B3" } };
                  }

                  // 3. Apply Installation Variance INDEPENDENTLY
                  if (lEst > 0 && lRate > 0) {
                    const ratio = lRate / lEst;
                    if (ratio < selectedVarianceLow)
                      row.getCell(lCol).fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFBFD7EA" } };
                    else if (ratio > selectedVarianceHigh)
                      row.getCell(lCol).fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFFFD2B3" } };
                  }

                  // 4. Missing Rate Check (Red) - Overrides previous colors if 0
                  if (Number(item.qty || 0) > 0) {
                    if (sRate === 0) {
                      const cell = row.getCell(sCol);
                      cell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FF7F1D1D" } };
                      cell.font = { color: { argb: "FFFFFFFF" }, bold: true };
                    }
                    if (lRate === 0) {
                      const cell = row.getCell(lCol);
                      cell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FF7F1D1D" } };
                      cell.font = { color: { argb: "FFFFFFFF" }, bold: true };
                    }
                  }
                }
              }
            }

            // L1 green highlight in MEP Excel (both simple and complex)
            if (!blankAllMEP && isDetail && mepL1Idx >= 0) {
              const L1_GREEN_XL = "FFD1FAE5";
              const mepStartBid = simpleMEP ? 9 : 12;
              for (let ci = 0; ci < 4; ci++) {
                const col = mepStartBid + mepL1Idx * 4 + ci;
                const cell = row.getCell(col);
                if (!cell.fill || cell.fill.fgColor?.argb !== "FF7F1D1D") {
                  cell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: L1_GREEN_XL } };
                }
              }
            }

            // üîπ treat ABSTRACT like subtotal for styling
            const topKey = String(item.slNo || "").split(".")[0];
            const isTopCategory =
              item.isCategory && /^\d+(?:\.0+)?$/.test(String(item.slNo || "")) && !seenTop.has(topKey);
            const isSubtotal = item.isSubtotal || /sub[\s-]?total/i.test(String(item.description || "")) ||
              /\babstract\b/i.test(String(item.description || ""));

            if (isSubtotal || item.isGrandTotal || isTopCategory) {
              row.font = { bold: true };
              row.eachCell({ includeEmpty: true }, (cell) => {
                cell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: GREY_200 } };
                cell.alignment = { ...cell.alignment, vertical: "top" };
              });
              row.height = Math.max(estimateRowHeight(item.description, descWidth), 28);
              if (isTopCategory) seenTop.add(topKey);
            } else {
              row.height = estimateRowHeight(item.description, descWidth);
            }
          });

          sheet.views = [{ state: "frozen", ySplit: 5 }];
          sheet.eachRow(r => {
            r.eachCell({ includeEmpty: true }, (cell) => {
              cell.border = { top: { style: "thin" }, left: { style: "thin" }, bottom: { style: "thin" }, right: { style: "thin" } };
              if (cell.value == null) cell.value = "";
            });
          });

          continue; // next sheet
        }

        // ---------- CIVIL (BOQ) SHEETS ----------
        sheet.addRow([]);
        const h1 = sheet.addRow([
          "Sl. No.", "Description of Items", "Unit", "Estimated", null, null,
          ...bidderNames.flatMap((n) => [n, null]),
          "Least Bid", null,
        ]);
        const h2 = sheet.addRow([
          null, null, null, "Qty", "Rate", "Amount",
          ...Array(bidderNames.length + 1).fill(null).flatMap(() => ["Rate", "Amount"]),
        ]);

        sheet.mergeCells("D4:F4");
        bidderNames.forEach((_, i) => sheet.mergeCells(4, 7 + i * 2, 4, 8 + i * 2));
        sheet.mergeCells(4, 7 + bidderNames.length * 2, 4, 8 + bidderNames.length * 2);

        [h1, h2].forEach((r) => {
          r.font = { bold: true, color: { argb: "FF000000" } };
          r.fill = { type: "pattern", pattern: "solid", fgColor: { argb: HEADER_PEACH } };
          r.alignment = { horizontal: "center", vertical: "middle", wrapText: true };
          r.height = 28;
        });

        const descWidth = 72;
        [14, descWidth, 10, 12, 12, 14, ...bidderNames.flatMap(() => [12, 14]), 12, 14]
          .forEach((w, i) => (sheet.getColumn(i + 1).width = w));
        sheet.getColumn(1).numFmt = "@";

        const isAmtOnlySheet = !!(consolidatedData[sheetName]?._isAmountOnly);
        const seenTop = new Set();

        consolidatedData[sheetName].forEach((item) => {

          // ‚úÖ START: Special handling for "Not Quoted Item" rows in Excel export
          if (item.isNotQuotedItem) {
            const rowData = [
              formatSrNo(item.slNo),
              insertWrapHints(item.description),
              null, null, null, null, // Empty cells for Unit, Est Qty, Rate, Amount
            ];

            item.bidders.forEach(b => {
              rowData.push(null); // Bidder Rate (empty)
              rowData.push(b.amount || null); // Bidder Amount
            });

            rowData.push(null, null); // Least Rate, Least Amount (empty)

            const newRow = sheet.addRow(rowData);

            // Basic formatting for the special row
            newRow.getCell(1).numFmt = "@";
            newRow.getCell(1).alignment = { vertical: "top", horizontal: "left", wrapText: true };
            newRow.getCell(2).alignment = { vertical: "top", horizontal: "left", wrapText: true };

            for (let i = 0; i < bidderNames.length; i++) {
              const amountCell = newRow.getCell(8 + i * 2);
              amountCell.alignment = { vertical: "top", horizontal: "right" };
              amountCell.numFmt = AMT_FMT;
            }

            newRow.height = estimateRowHeight(item.description, descWidth);
            return; // Skip the rest of the loop for this item
          }
          // ‚úÖ END: Special handling

          const slNoStr = formatSrNo(item.slNo);
          const topKey = String(item.slNo || "").split(".")[0];
          const isTopCategory =
            item.isCategory && /^\d+(?:\.0+)?$/.test(String(item.slNo || "")) && !seenTop.has(topKey);

          const isDetail = !item.isSubtotal && !item.isGrandTotal && !item.isCategory;

          const isAbstract = /\babstract\b/i.test(String(item.description || ""));
          const blankAll = !isAbstract && isDetail &&
            (Number(item.qty || 0) === 0 || Number(item.estimate?.rate || 0) === 0) &&
            !item.qtyRemark;

          const leastBid = blankAll
            ? { rate: null, amount: null }
            : findLeastBid(item);

          const rowVals = [
            slNoStr,
            insertWrapHints(item.description),
            item.unit,
            item.qtyRemark ? (item.qtyText || "0") : (blankAll ? null : (item.qty ?? null)),
            (isAmtOnlySheet || !isDetail || blankAll) ? null : item.estimate.rate,
            blankAll ? null : item.estimate.amount,
            ...item.bidders.flatMap((b) => [
              (isAmtOnlySheet || !isDetail || blankAll) ? null : b.rate,
              blankAll ? null : b.amount
            ]),
            (isAmtOnlySheet || blankAll) ? null : leastBid.rate,
            blankAll ? null : leastBid.amount,
          ];

          const newRow = sheet.addRow(rowVals);

          if (item.qtyRemark) {
            newRow.eachCell({ includeEmpty: true }, (cell) => {
              cell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFF5F3FF" } };; // violet-200
            });
          }

          // align/format
          newRow.getCell(1).numFmt = "@";
          newRow.getCell(1).alignment = { vertical: "top", horizontal: "left", wrapText: true };
          newRow.getCell(2).alignment = { vertical: "top", horizontal: "left", wrapText: true };
          newRow.getCell(3).alignment = { vertical: "top", horizontal: "center", wrapText: true };
          newRow.getCell(4).alignment = { vertical: "top", horizontal: "right" }; newRow.getCell(4).numFmt = AMT_FMT;
          newRow.getCell(5).alignment = { vertical: "top", horizontal: "right" }; newRow.getCell(5).numFmt = RATE_FMT;
          newRow.getCell(6).alignment = { vertical: "top", horizontal: "right" }; newRow.getCell(6).numFmt = AMT_FMT;

          for (let i = 0; i < bidderNames.length; i++) {
            newRow.getCell(7 + i * 2).alignment = { vertical: "top", horizontal: "right" };
            newRow.getCell(7 + i * 2).numFmt = RATE_FMT;
            newRow.getCell(8 + i * 2).alignment = { vertical: "top", horizontal: "right" };
            newRow.getCell(8 + i * 2).numFmt = AMT_FMT;
          }
          const leastStartCol = 7 + bidderNames.length * 2;
          newRow.getCell(leastStartCol).alignment = { vertical: "top", horizontal: "right" };
          newRow.getCell(leastStartCol + 1).alignment = { vertical: "top", horizontal: "right" };
          newRow.getCell(leastStartCol).numFmt = RATE_FMT;
          newRow.getCell(leastStartCol + 1).numFmt = AMT_FMT;

          // variance / missing-rate shading (skip for amount-only & when blank)
          if (!isAmtOnlySheet && isDetail && !blankAll) {
            item.bidders.forEach((b, i) => {
              const rateCell = newRow.getCell(7 + i * 2);
              if (item.estimate?.rate && b.rate) {
                const variance = b.rate / item.estimate.rate;
                if (variance < selectedVarianceLow) {
                  rateCell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFBFD7EA" } };
                } else if (variance > selectedVarianceHigh) {
                  rateCell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFFFD2B3" } };
                }
              }
              if (Number(item.qty || 0) > 0 && (!b.rate || b.rate === 0)) {
                rateCell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FF7F1D1D" } };
                rateCell.font = { color: { argb: "FFFFFFFF" }, bold: true };
              }
            });
          }

          // L1 green highlight in Excel
          if (isDetail && !blankAll && leastBid.l1Index >= 0) {
            const l1i = leastBid.l1Index;
            const l1RateCell = newRow.getCell(7 + l1i * 2);
            const l1AmtCell = newRow.getCell(8 + l1i * 2);
            const L1_GREEN_XL = "FFD1FAE5";
            // Only apply if the cell doesn't already have missing-rate (red) fill
            if (!l1RateCell.fill || l1RateCell.fill.fgColor?.argb !== "FF7F1D1D") {
              l1RateCell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: L1_GREEN_XL } };
            }
            l1AmtCell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: L1_GREEN_XL } };
          }

          // üîπ treat ABSTRACT like subtotal for styling
          const isSubtotal = item.isSubtotal || isSubtotalText(item.description) ||
            /\babstract\b/i.test(String(item.description || ""));
          if (isSubtotal || item.isGrandTotal || isTopCategory) {
            newRow.font = { bold: true };
            newRow.eachCell({ includeEmpty: true }, (cell) => {
              cell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: GREY_200 } };
              cell.alignment = { ...cell.alignment, vertical: "top" };
            });
            newRow.height = Math.max(estimateRowHeight(item.description, descWidth), TOP_CATEGORY_MIN_HEIGHT);
            if (isTopCategory) seenTop.add(String(item.slNo));
            if (isSubtotal) {
              const spacer = sheet.addRow([]); spacer.height = SPACER_ROW_HEIGHT; spacerRowNumbers.add(spacer.number);
            }
          } else {
            newRow.height = estimateRowHeight(item.description, descWidth);
          }
        });

        sheet.views = [{ state: "frozen", ySplit: 5 }];

        sheet.eachRow((row) => {
          if (spacerRowNumbers.has(row.number)) return;
          row.eachCell({ includeEmpty: true }, (cell) => {
            cell.border = {
              top: { style: "thin" }, left: { style: "thin" },
              bottom: { style: "thin" }, right: { style: "thin" },
            };
            if (cell.value == null) cell.value = "";
          });
        });
      }

      // --- 4) Save file ---
      const outName = "CS_Consolidated_Output.xlsx";
      const buffer = await workbook.xlsx.writeBuffer();
      saveAs(
        new Blob([buffer], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" }),
        outName
      );
    }


    document.getElementById("reload-page").addEventListener("click", () => {
      window.location.reload();
    });

  </script>



  <div id="export-modal" class="fixed inset-0 z-[100] hidden">
    <div class="absolute inset-0 bg-black/70" onclick="closeExportModal()"></div>

    <div class="absolute inset-0 flex items-center justify-center p-4">
      <div class="w-full max-w-lg rounded-2xl bg-slate-900 text-gray-100 shadow-2xl border border-slate-700">
        <div class="flex items-center justify-between px-6 py-4 border-b border-slate-700">
          <h3 class="text-lg font-semibold">Export options</h3>
          <button class="text-gray-400 hover:text-gray-200" onclick="closeExportModal()"
            aria-label="Close">&times;</button>
        </div>

        <div class="px-6 py-4 space-y-5">
          <div>
            <label for="modal-project" class="block text-sm font-medium text-gray-300">
              Project name
            </label>
            <input id="modal-project" type="text" class="mt-1 w-full rounded-lg border border-slate-600 bg-slate-800/70 px-3 py-2
                        text-gray-100 placeholder-gray-400
                        focus:outline-none focus:ring-2 focus:ring-indigo-500/50 focus:border-indigo-400" />
            <p class="mt-1 text-xs text-gray-400">
              This appears at the top of every exported sheet.
            </p>
          </div>

          <div>
            <label class="block text-sm font-medium text-gray-300 mb-1">Scope</label>
            <input type="text" id="modal-scope"
              class="w-full px-3 py-2 rounded-md bg-gray-800 border border-gray-600 text-gray-100"
              placeholder="Enter scope of work" />
            <p class="text-xs text-gray-400 mt-1">This will also appear in the exported Excel file.</p>
          </div>
          <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
            <div>
              <label for="modal-low" class="block text-sm font-medium text-gray-300">Lower variance</label>
              <input id="modal-low" type="number" step="0.01" min="0" max="10" class="mt-1 w-full rounded-lg border border-slate-600 bg-slate-800/70 px-3 py-2
                          text-gray-100 placeholder-gray-400
                          focus:outline-none focus:ring-2 focus:ring-indigo-500/50 focus:border-indigo-400" />
              <p class="mt-1 text-xs text-gray-400">e.g. <strong class="text-gray-200">0.80</strong> highlights rates
                &lt; 80% of estimate.</p>
            </div>
            <div>
              <label for="modal-high" class="block text-sm font-medium text-gray-300">Upper variance</label>
              <input id="modal-high" type="number" step="0.01" min="0" max="10" class="mt-1 w-full rounded-lg border border-slate-600 bg-slate-800/70 px-3 py-2
                          text-gray-100 placeholder-gray-400
                          focus:outline-none focus:ring-2 focus:ring-indigo-500/50 focus:border-indigo-400" />
              <p class="mt-1 text-xs text-gray-400">e.g. <strong class="text-gray-200">1.20</strong> highlights rates
                &gt; 120% of estimate.</p>
            </div>
          </div>

          <div id="modal-error"
            class="hidden rounded-lg bg-red-900/40 border border-red-700 px-3 py-2 text-sm text-red-200"></div>
        </div>

        <div class="flex items-center justify-end gap-3 px-6 py-4 border-t border-slate-700">
          <button class="rounded-lg border border-slate-600 px-4 py-2 text-gray-200 hover:bg-slate-800"
            onclick="closeExportModal()">Cancel</button>
          <button class="rounded-lg bg-indigo-600 px-4 py-2 font-semibold text-white hover:bg-indigo-500
                       disabled:opacity-60 disabled:cursor-not-allowed" onclick="submitExportModal()">Export</button>
        </div>
      </div>
    </div>
  </div>


  <div id="mode-modal" class="fixed inset-0 z-[90] hidden">
    <div class="absolute inset-0 bg-black/70" onclick="closeModeModal()"></div>
    <div class="absolute inset-0 flex items-center justify-center p-4">
      <div class="w-full max-w-md rounded-2xl bg-slate-900 text-gray-100 shadow-2xl border border-slate-700">
        <div class="px-6 py-4 border-b border-slate-700">
          <h3 class="text-lg font-semibold">Choose comparison type</h3>
          <p class="text-sm text-gray-400 mt-1">Pick the structure that matches your files.</p>
        </div>
        <div class="px-6 py-6 grid grid-cols-1 gap-4">
          <button class="rounded-lg bg-indigo-600 hover:bg-indigo-500 px-4 py-3 font-semibold"
            onclick="startProcessing('civil')">CIVIL (Qty √ó Rate = Amount)</button>
          <button class="rounded-lg bg-emerald-600 hover:bg-emerald-500 px-4 py-3 font-semibold"
            onclick="startProcessing('mep')">MEP (Supply/Labour Rates & Amounts)</button>
        </div>
        <div class="px-6 py-4 border-t border-slate-700 flex justify-end">
          <button class="rounded-lg border border-slate-600 px-4 py-2 text-gray-200 hover:bg-slate-800"
            onclick="closeModeModal()">Cancel</button>
        </div>
      </div>
    </div>
  </div>




  <!-- ERROR DILOUGE BOX -->
  <div id="error-modal" class="fixed inset-0 z-[110] hidden">
    <div class="absolute inset-0 bg-black/80 backdrop-blur-sm" onclick="closeErrorModal()"></div>
    <div class="absolute inset-0 flex items-center justify-center p-4">
      <div class="w-full max-w-2xl rounded-2xl bg-slate-900 text-gray-100 shadow-2xl border border-red-500">

        <div class="flex items-center justify-between px-6 py-4 border-b border-red-900 bg-red-900/20">
          <h3 class="text-xl font-bold text-red-100 flex items-center gap-2">
            ‚ö†Ô∏è Application Error
          </h3>
          <button class="text-gray-400 hover:text-white text-2xl" onclick="closeErrorModal()">&times;</button>
        </div>

        <div class="px-6 py-6 space-y-4">
          <div>
            <p class="text-gray-300">The application encountered a problem. Here is exactly what went wrong:</p>
          </div>

          <div class="bg-red-950/40 border border-red-900 rounded-lg p-4">
            <label class="block text-xs font-bold text-red-400 uppercase mb-1">Problem Description</label>
            <p id="error-msg-text" class="text-red-100 font-mono text-sm whitespace-pre-wrap break-words"></p>
          </div>

          <div class="bg-slate-950 border border-slate-700 rounded-lg p-4">
            <label class="block text-xs font-bold text-indigo-400 uppercase mb-1">Error Location / Tip</label>
            <p id="error-tip-text" class="text-indigo-200 text-sm"></p>
          </div>
        </div>

        <div class="px-6 py-4 border-t border-slate-700 flex justify-end">
          <button onclick="closeErrorModal()"
            class="bg-slate-700 hover:bg-slate-600 text-white px-5 py-2 rounded-lg">Close</button>
        </div>
      </div>
    </div>
  </div>


  <div id="validation-modal" class="fixed inset-0 z-[120] hidden">
    <div class="absolute inset-0 bg-black/90 backdrop-blur-sm"></div>
    <div class="absolute inset-0 flex items-center justify-center p-4">
      <div
        class="w-full max-w-5xl h-[80vh] flex flex-col rounded-2xl bg-slate-900 text-gray-100 shadow-2xl border border-orange-500/50">

        <div class="flex items-center justify-between px-6 py-4 border-b border-slate-700 bg-slate-800">
          <h3 class="text-xl font-bold text-orange-400 flex items-center gap-2">
            <span>‚ö†Ô∏è</span> Data Mismatches Found
          </h3>
          <button class="text-gray-400 hover:text-white text-2xl" onclick="closeValidationModal()">&times;</button>
        </div>

        <div class="p-6 bg-slate-900/50 flex-none">
          <p class="text-gray-300 text-sm">
            The following discrepancies were found between the Estimate and Bidder files.
            Please review and fix these issues in the Excel files to ensure an accurate comparison.
          </p>
        </div>

        <div class="flex-1 overflow-auto px-6 pb-6">
          <table class="w-full text-left border-collapse">
            <thead class="bg-slate-950 text-gray-400 sticky top-0 shadow-lg">
              <tr>
                <th class="p-3 text-xs font-bold uppercase tracking-wider border-b border-slate-700">Bidder Name</th>
                <th class="p-3 text-xs font-bold uppercase tracking-wider border-b border-slate-700">Sheet</th>
                <th class="p-3 text-xs font-bold uppercase tracking-wider border-b border-slate-700">Issue Type</th>
                <th class="p-3 text-xs font-bold uppercase tracking-wider border-b border-slate-700">Location (Sl.No)
                </th>
                <th class="p-3 text-xs font-bold uppercase tracking-wider border-b border-slate-700 w-1/2">Details</th>
              </tr>
            </thead>
            <tbody id="validation-table-body" class="text-sm divide-y divide-slate-800">
            </tbody>
          </table>
        </div>

        <div class="px-6 py-4 border-t border-slate-700 flex justify-end gap-3 bg-slate-800 rounded-b-2xl">
          <button onclick="closeValidationModal()"
            class="bg-slate-700 hover:bg-slate-600 text-white px-5 py-2 rounded-lg font-medium transition">
            Go Back & Fix
          </button>
          <button id="btn-force-proceed" onclick="forceProceedComparison()"
            class="bg-orange-600 hover:bg-orange-500 text-white px-5 py-2 rounded-lg font-medium transition hidden">
            Ignore & Proceed Anyway
          </button>
        </div>
      </div>
    </div>
  </div>



</body>

</html>
