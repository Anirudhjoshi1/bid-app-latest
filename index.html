<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Bid Comparison Application</title>

  <!-- Tailwind (utility) + Excel libs (parsing + export) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/exceljs/dist/exceljs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver/dist/FileSaver.min.js"></script>

  <!-- Inter font -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet"/>

  <!-- ====== FULL CSS (web view fixes) ====== -->
  <style>

    /* 🔴 missing bidder rate (qty > 0 & rate not quoted) */
.missing-rate {
  background-color: #7f1d1d !important;  /* red-900-ish */
  border-color: #ef4444 !important;      /* red-500 */
  color: #ffffff !important;
}

/* 0-value text treatment (web) */
.zero-text { color: #ffffff !important; opacity: .95; }
.rate-input.zero-value { color: #ffffff !important; }
    /* --- Page base --- */
    body { font-family: "Inter", sans-serif; background: #0f172a; color: #f9fafb; }

    /* --- Variance inputs --- */
    .variance-input-group { display: flex; flex-direction: column; gap: 0.25rem; }
    .variance-input-label { font-size: 0.875rem; font-weight: 500; color: #d1d5db; }
    .variance-input {
      padding: 0.5rem 0.75rem; border: 1px solid #4b5563; border-radius: 0.375rem;
      font-size: 0.875rem; color: #f9fafb; background-color: #1f2937; outline: none;
      transition: border-color .2s, box-shadow .2s;
    }
    .variance-input:focus { border-color: #6366f1; box-shadow: 0 0 0 2px rgba(99,102,241,.4); }

    /* --- Variance legend --- */
    .variance-legend {
      display: flex; justify-content: flex-end; align-items: center;
      gap: 1.5rem; margin: 1rem 1rem 0 0; font-size: 0.875rem; font-weight: 600; color: #d1d5db;
    }
    .variance-box { width: 1.5rem; height: 1.5rem; border: 2px solid; border-radius: 0.375rem; }
    .variance-low  { background-color: #cce5ff; border-color: #007bff; }
    .variance-high { background-color: #ffe5b4; border-color: #ff9900; }

    /* --- Tabs --- */
    .tab-button.active { border-color: #4f46e5; background-color: #312e81; color: #c7d2fe; font-weight: 600; }

    /* --- Scroll wrappers --- */
    .table-container {
  max-width: 1600px;    /* adjust to your liking (1200–1400px works well) */
  margin: 0 auto;       /* centers the table */
  padding: 0 1rem;      /* add side padding */
  padding-bottom: 100px;

}
    .top-scrollbar {
      overflow-x: auto; overflow-y: hidden; height: 14px; position: sticky; top: 0; z-index: 50;
      background: #111827; border-bottom: 1px solid #374151;
    }
    .top-scrollbar-inner { height: 1px; }
    .table-viewport {
      max-height: 70vh; overflow: auto; background: transparent; border: 1px solid #374151; border-top: 0;
    }
    

    /* --- Table base --- */
    table { table-layout: fixed; width: max-content; min-width: 100%; border-collapse: collapse; color: #f9fafb; }
    th, td { border: 1px solid #374151; padding: 8px; font-size: 12px; white-space: nowrap; }
    th {
      background-color: #111827; color: #f3f4f6; font-weight: 600;
      position: sticky; top: 0; z-index: 10;
    }

    /* --- Sticky first two columns --- */
    .col-slno { width: 90px; min-width: 90px; }
    .col-desc { width: 420px; min-width: 420px; }
    .sticky-col-1 { position: sticky; left: 0; z-index: 12; background: #1f2937; }
    .sticky-col-2 { position: sticky; left: 90px; z-index: 12; background: #1f2937; }

    /* --- Description wraps --- */
    td:nth-child(2), th:nth-child(2) { white-space: normal; line-height: 1.3; }

    /* --- Numeric alignment --- */
    .amount-cell, .total-cell, .least-amount-cell { text-align: right; }

    /* --- Compact stacked Rate/Amount cell --- */
    .compact-cell { white-space: normal; padding: 6px 8px; }
    .compact-cell .label { display: block; font-size: 10px; color: #9ca3af; line-height: 1.1; }
    .compact-cell .val   { display: block; text-align: right; }

    /* --- Inputs --- */
    .rate-input {
      width: 100%; max-width: 90px; padding: 4px; border: 1px solid #4b5563; border-radius: 4px;
      text-align: right; background-color: #111827; color: #f9fafb;
    }
    .rate-input:disabled { background-color: #374151; border-color: transparent; color: #9ca3af; }

    /* --- Variance colors --- */
    .bg-blue-100   { background-color: #cce5ff; }
    .bg-orange-100 { background-color: #ffe5b4; }
    .rate-input.bg-blue-100   { border: 1px solid #007bff; }
    .rate-input.bg-orange-100 { border: 1px solid #ff9900; }

    /* --- Row highlights --- */
    .subtotal-row { font-weight: bold; background-color: #4b5563; }
    .grand-total-row { font-weight: bold; background-color: #047857; font-size: 14px; }
    .category-header { font-weight: bold; background-color: #374151; }
    .least-rate-cell, .least-amount-cell { background-color: #065f46 !important; font-weight: bold; }


    /* ✅ make highlighted inputs readable */
    .rate-input.bg-blue-100,
    .rate-input.bg-orange-100 {
      color: #111827 !important;     /* dark text */
      caret-color: #111827 !important;
      font-weight: 600;
    }

    /* consistent backgrounds for the two variance states */
    .rate-input.bg-blue-100 {
      background-color: #DBEAFE !important; /* Tailwind blue-100 */
      border-color: #3B82F6 !important;      /* blue-500 */
    }
    .rate-input.bg-orange-100 {
      background-color: #FFEDD5 !important; /* Tailwind orange-100 */
      border-color: #F59E0B !important;     /* amber-500 / orange-500 */
    }

    /* readable placeholder when inputs are empty */
    .rate-input.bg-blue-100::placeholder,
    .rate-input.bg-orange-100::placeholder {
      color: #6B7280; /* gray-500 */
      opacity: 1;
    }

    /* if you ever disable highlighted inputs, keep them readable too */
    .rate-input.bg-blue-100:disabled,
    .rate-input.bg-orange-100:disabled {
      color: #111827 !important;
      background-color: #E5E7EB !important;  /* gray-200 */
      border-color: #9CA3AF !important;      /* gray-400 */
    }


.file-chip {
  display: flex; align-items: center; justify-content: space-between;
  background: #1e293b;
  color: #f3f4f6;
  border: 1px solid #4b5563;
  border-radius: 14px;
  padding: 8px 14px;
  font-size: 0.90rem;
  min-width: 240px;
  max-width: 340px;
  margin: 6px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  transition: transform 0.2s ease, background 0.2s ease;
}
.file-chip:hover { background: #2c3a52; transform: translateY(-2px); }
.file-chip .file-info { display: flex; flex-direction: column; gap: 2px; }
.file-chip .file-name { font-weight: 600; color: #e5e7eb; }
.file-chip .file-size { font-size: 0.8rem; color: #9ca3af; }
.file-chip button {
  background: #ef4444; color: #fff; border: none;
  border-radius: 6px; padding: 6px 10px;
  margin-left: 14px; cursor: pointer; font-size: 0.8rem; font-weight: bold;
  transition: background 0.2s ease;
}
.file-chip button:hover { background: #dc2626; }


.reload-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: 1px solid #4b5563;
  background: #1e293b;
  color: #f9fafb;
  font-size: 1rem;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 2px 6px rgba(0,0,0,0.4);
}
.reload-btn:hover {
  background: #374151;
  border-color: #6366f1;
  color: #c7d2fe;
  transform: rotate(90deg);
}
  </style>
</head>

<body class="text-gray-100">
  <div class="container mx-auto p-4 md:p-8">
    <header class="text-center mb-10">
      <h1 class="text-4xl font-extrabold tracking-tight sm:text-5xl">📊 Bid Comparison Tool</h1>
      <p class="mt-4 text-lg text-gray-300">Upload your estimate and bidder Excel sheets to generate a detailed comparative statement.</p>
    </header>

    <!-- Upload Section -->
   <!-- Upload Section -->
<div id="upload-section" class="bg-gray-800 p-8 rounded-2xl shadow-lg mb-10 border border-gray-700">
  <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
    <!-- Estimate -->
    <div class="space-y-2">
      <label for="estimate-file" class="block text-sm font-medium text-gray-200">📄 Estimate File (Baseline)</label>
      <input type="file" id="estimate-file" accept=".xlsx"
        class="block w-full text-sm text-gray-200 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:bg-indigo-200/20 file:text-indigo-200 hover:file:bg-indigo-200/30"/>
      
      <!-- Show selected Estimate -->
      <div class="mt-3">
        <div class="text-xs text-gray-400 mb-1">Selected:</div>
        <div id="estimate-file-list" class="flex flex-wrap gap-2"></div>
      </div>
    </div>

    <!-- Bidders -->
    <div class="space-y-2">
      <label for="bidder-files" class="block text-sm font-medium text-gray-200">👥 Bidder Files (Max 7)</label>
      <input type="file" id="bidder-files" accept=".xlsx" multiple
        class="block w-full text-sm text-gray-200 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:bg-violet-200/20 file:text-violet-200 hover:file:bg-violet-200/30"/>
      
      <!-- Show selected Bidders -->
      <div class="mt-3">
        <div class="text-xs text-gray-400 mb-1">
          Selected Bidders (max 7):
          <span id="bidder-count" class="text-gray-300">0/7</span>
        </div>
        <div id="bidder-file-list" class="flex flex-wrap gap-2"></div>
      </div>
    </div>
  </div>


      <!-- Variance Controls -->
      <div class="mt-8 grid grid-cols-1 md:grid-cols-2 gap-6">
        <div class="variance-input-group">
          <label for="lower-variance" class="variance-input-label">📉 Lower Variance Factor</label>
          <input type="number" id="lower-variance" step="0.01" min="0" max="1" value="0.8" class="variance-input"/>
          <small class="text-gray-400 mt-1">e.g., 0.8 means -20% below estimate</small>
        </div>
        <div class="variance-input-group">
          <label for="upper-variance" class="variance-input-label">📈 Upper Variance Factor</label>
          <input type="number" id="upper-variance" step="0.01" min="1" max="2" value="1.2" class="variance-input"/>
          <small class="text-gray-400 mt-1">e.g., 1.2 means +20% above estimate</small>
        </div>
      </div>
      </div>

      <!-- Action Buttons -->
      <div class="mt-10 flex flex-wrap justify-center gap-6">
        <button id="process-button"
          class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
          🚀 Generate Comparison
        </button>
        <button id="download-button"
          class="bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-6 rounded-lg shadow-md hidden focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500">
          📥 Download as Excel
        </button>
            <button id="reload-page" class="reload-btn hidden" title="Reload Page">⟳</button>
      </div>

      <!-- Loader -->
      <div id="loader" class="text-center mt-6 hidden">
        <div role="status" class="flex flex-col items-center gap-2">
          <svg class="w-8 h-8 text-indigo-400 animate-spin" viewBox="0 0 100 101" fill="none" xmlns="http://www.w3.org/2000/svg">
            <circle cx="50" cy="50" r="45" stroke="currentColor" stroke-width="10" opacity=".2"/>
            <path d="M95 50a45 45 0 10-45 45" fill="currentColor"/>
          </svg>
          <p class="text-sm text-gray-400">Processing files, please wait...</p>
        </div>
      </div>
    </div>

    <!-- Output Section -->
    <div id="output-section" class="hidden">
      <div class="border-b border-gray-700">
        <nav id="tabs-container" class="-mb-px flex space-x-4 overflow-x-auto" aria-label="Tabs"></nav>
      </div>

      <div class="variance-legend">
        <div class="flex items-center gap-2">
          <div class="variance-box variance-low"></div>
          <span id="lower-variance-label">0.8</span>
        </div>
        <div class="flex items-center gap-2">
          <div class="variance-box variance-high"></div>
          <span id="upper-variance-label">1.2</span>
        </div>
      </div>

      <div id="tables-container" class="mt-4 bg-gray-800 rounded-lg shadow-md"></div>
    </div>
  </div>

  <!-- ====== JAVASCRIPT LOGIC ====== -->
<script>



let selectedEstimateFile = null;
let selectedBidderFiles = [];

const estimateListEl = document.getElementById("estimate-file-list");
const bidderListEl = document.getElementById("bidder-file-list");
const bidderCountEl = document.getElementById("bidder-count");

function renderFileLists() {
  // Estimate
  estimateListEl.innerHTML = "";
  if (selectedEstimateFile) {
    const chip = document.createElement("div");
    chip.className = "file-chip";
    chip.innerHTML = `${selectedEstimateFile.name}
      <button onclick="removeEstimateFile()">×</button>`;
    estimateListEl.appendChild(chip);
  }

  // Bidders
  bidderListEl.innerHTML = "";
  selectedBidderFiles.forEach((file, idx) => {
    const chip = document.createElement("div");
    chip.className = "file-chip";
    chip.innerHTML = `${file.name}
      <button onclick="removeBidderFile(${idx})">×</button>`;
    bidderListEl.appendChild(chip);
  });
  bidderCountEl.textContent = `${selectedBidderFiles.length}/7`;
}

function removeEstimateFile() {
  selectedEstimateFile = null;
  document.getElementById("estimate-file").value = "";
  renderFileLists();
}

function removeBidderFile(index) {
  selectedBidderFiles.splice(index, 1);
  renderFileLists();
}

document.getElementById("estimate-file").addEventListener("change", (e) => {
  selectedEstimateFile = e.target.files[0] || null;
  renderFileLists();
});

document.getElementById("bidder-files").addEventListener("change", (e) => {
  const newFiles = Array.from(e.target.files);
  selectedBidderFiles = [...selectedBidderFiles, ...newFiles].slice(0, 7); // limit 7
  renderFileLists();
});



// ---- Professional modal flow for export ----
const defaultProjectName =
  "Proposed Industrial Building for M/s DGG Exports Pvt. Ltd At Shiggaon, Karnataka";

function openExportModal() {
  const modal  = document.getElementById("export-modal");
  const lowIn  = document.getElementById("modal-low");
  const highIn = document.getElementById("modal-high");
  const projIn = document.getElementById("modal-project");
  const scopeIn = document.getElementById("modal-scope");   // 🔥 new
  const errBox = document.getElementById("modal-error");

  // prefill from current UI values
  lowIn.value  = document.getElementById("lower-variance").value || "0.80";
  highIn.value = document.getElementById("upper-variance").value || "1.20";
  projIn.value = projIn.value || defaultProjectName;
  scopeIn.value = scopeIn.value || "";   // 🔥 prefill empty or last scope if you want

  errBox.classList.add("hidden");
  errBox.textContent = "";

  modal.classList.remove("hidden");
  projIn.focus();
}

function closeExportModal() {
  document.getElementById("export-modal").classList.add("hidden");
}

function showModalError(msg) {
  const errBox = document.getElementById("modal-error");
  errBox.textContent = msg;
  errBox.classList.remove("hidden");
}

async function submitExportModal() {
  const projIn   = document.getElementById("modal-project");
  const projectScope = document.getElementById("modal-scope").value || "Not specified"; // 🔥 new
  const lowInput = document.getElementById("modal-low");
  const highInput= document.getElementById("modal-high");

  let low  = parseFloat(lowInput.value);
  let high = parseFloat(highInput.value);

  // --- basic validation ---
  const name = (projIn.value || "").trim();
  if (!name) return showModalError("Please enter a project name.");
  if (!isFinite(low) || !isFinite(high)) {
    return showModalError("Enter valid numbers for variance (e.g., 0.80 and 1.20).");
  }

  // clamp & normalize
  low  = Math.max(0, Math.min(low, 10));
  high = Math.max(0, Math.min(high, 10));
  if (low > high) [low, high] = [high, low];

  // reflect variance into the on-screen legend/inputs
  const lowEl  = document.getElementById("lower-variance");
  const highEl = document.getElementById("upper-variance");
  if (lowEl)  lowEl.value  = low.toFixed(2);
  if (highEl) highEl.value = high.toFixed(2);
  const lowLbl  = document.getElementById("lower-variance-label");
  const highLbl = document.getElementById("upper-variance-label");
  if (lowLbl)  lowLbl.textContent  = `Low < ${low.toFixed(2)}`;
  if (highLbl) highLbl.textContent = `High > ${high.toFixed(2)}`;

  // must have generated a comparison first
  if (!Array.isArray(processedSheetNames) || processedSheetNames.length === 0) {
    return showModalError("Generate the comparison first, then export.");
  }

  // --- kick off the export with the chosen values ---
   const exportBtn = document.querySelector('#export-modal button[onclick="submitExportModal()"]');
  try {
    if (exportBtn) exportBtn.disabled = true;
    setUiBusy(true);                    // show spinner during export
    closeExportModal();                 // close the modal right away (optional)
    await handleDownloadExcelJS(name, low, high , projectScope);
  } catch (err) {
    console.error(err);
    showModalError("Export failed. See console for details.");
  } finally {
    setUiBusy(false);                   // hide spinner
    if (exportBtn) exportBtn.disabled = false;
  }
}



/* ===================== Compatibility & helpers ===================== */


// map normalized key -> real Excel sheet name (for display/export)
let sheetDisplayNameMap = {};
// ordered list of normalized keys from the Estimate workbook
let estimateSheetKeysOrdered = [];

function displayNameFor(key){
  return (key === "Summary") ? "Summary" : (sheetDisplayNameMap[key] || key);
}



// recognises the Roads & Drains sheet
const RD_BREAK_LABELS = {
  roads: [
    /\binternal\s*roads?\b/i,
    /\broads?\b/i
  ],
  swd: [
    /\bstorm\s*water\s*(?:drain|drains)\b/i,
    /\bswd\b/i,
    /\bs\/?\s*w\s*\/?\s*d\b/i
  ]
};


const EXCLUDE_SHEETS = [/^summary$/i, /^measure/i];

const HEADER_SYNONYMS = {
  slNo: [
    /^(sr|sl)\.?\s*no\.?$/i,          // Sr.No. / Sl.No.
    /^s\.?\s*no\.?$/i,                // S.No.
    /^s\s*no/i,
    /^serial/i,
    /^(?:item\s*)?no\.?$/i,           // Item No. / No.
    /^item\s*no/i
  ],
  desc:   [/^description/i, /^item\s*description/i, /^desc$/i],
  unit:   [/^unit$/i, /^uom$/i, /^units?$/i],
  qty:    [/^qty$/i, /^quantity$/i, /^qtty$/i],
  rate:   [/^rate$/i, /^unit\s*rate$/i, /^quoted\s*rate$/i, /^basic\s*rate$/i],
  // ⬇️ no bare ^total$ here to avoid matching "TOTAL", "TOTAL QTY", etc.
  amount: [
    /^amount(?:\s*\(rs\.?\))?$/i,
    /^amt\.?$/i,
    /^line\s*amount$/i,
    /^total\s*amount$/i,
    /^amount\s*total$/i
  ]
};


const MEP_HEADER_SYNONYMS = {
  gf:   [/^gf$/i, /ground\s*floor/i],
  oneF: [/^(1f|1\s*floor)$/i],
  tf:   [/^(tf|top\s*floor|terrace\s*floor)$/i],
  tqty: [/^total\s*q(?:ty)?$/i, /^t\s*qty$/i, /^qty\s*total$/i],
  qtyAlt: [/^academic\s*qty$/i],   // <— add this

  supplyRate:   [/^supply\s*rate$/i, /^s\.?\s*rate$/i],
  labourRate:   [/^labou?r\s*rate$/i, /^installation\s*rate$/i, /^install(?:ation)?\s*rate$/i],
  supplyAmount: [/^supply\s*amount$/i, /^s\.?\s*amt$/i, /^supply\s*amt\.?$/i],
  labourAmount: [/^labou?r\s*amount$/i, /^installation\s*amount$/i, /^install(?:ation)?\s*amount$/i],
};


// Detect both the “Qty” (simple) and “Total Qty” (TQTY) styles.
function inferSheetConfigFromWorksheetMEP(worksheet) {
  const rows = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: false, defval: "" });

  const looks = (v, re) => re.test(String(v || "").trim());
  const findIdx = (arr, re) => arr.findIndex(v => looks(v, re));

  // ---------- Two-row header: Row A has RATE/AMOUNT, Row B has SUPPLY/INSTALLATION ----------
  for (let r = 0; r < Math.min(30, rows.length - 1); r++) {
    const A = rows[r] || [];
    const B = rows[r + 1] || [];

    // Core labels on row A
    const sl   = findIdx(A, /^(sr|sl)\.?\s*no\.?$/i) >= 0 ? findIdx(A, /^(sr|sl)\.?\s*no\.?$/i) : findIdx(A, /^s\.?\s*no\.?$/i);
    const desc = findIdx(A, /^d(?:escr|escription)/i);   // “Description”, “D E S C R I P T I O N”
    const unit = findIdx(A, /^unit$/i);
    let   qty  = findIdx(A, /^(qty|quantity|qtty|total\s*q(?:ty)?|t\s*qty|academic\s*qty)$/i);
    const rate = findIdx(A, /^rate$/i);
    const amt  = findIdx(A, /^amount/i);

    // Subheaders on row B (must sit under RATE/AMOUNT columns)
    const supRateCol = B.findIndex((v, i) => looks(v, /supply/i) && i >= 0 && looks(A[i], /^rate$/i));
    const insRateCol = B.findIndex((v, i) => looks(v, /install/i) && i >= 0 && looks(A[i], /^rate$/i));
    const supAmtCol  = B.findIndex((v, i) => looks(v, /supply/i) && i >= 0 && looks(A[i], /^amount/i));
    const insAmtCol  = B.findIndex((v, i) => looks(v, /install/i) && i >= 0 && looks(A[i], /^amount/i));

    // Also allow qty label to live in row B sometimes
    if (qty < 0) qty = findIdx(B, /^(qty|quantity|qtty|total\s*q(?:ty)?|t\s*qty|academic\s*qty)$/i);

    const hasCore = (desc >= 0) && (qty >= 0 || supRateCol >= 0 || supAmtCol >= 0);
    const hasAnyRatesAmts = (supRateCol >= 0 || insRateCol >= 0 || supAmtCol >= 0 || insAmtCol >= 0);

    if (hasCore && hasAnyRatesAmts) {
      return {
        isMEP: true,
        startRow: r + 2,           // data starts after the subheader row
        simpleQtyOnly: true,       // no GF/1F/TF in this layout
        slNoCol: (sl >= 0 ? sl : undefined),
        descCol: desc,
        unitCol: (unit >= 0 ? unit : undefined),
        qtyCol: (qty >= 0 ? qty : undefined),
        supplyRateCol: (supRateCol >= 0 ? supRateCol : undefined),
        labourRateCol: (insRateCol >= 0 ? insRateCol : undefined),
        supplyAmountCol: (supAmtCol >= 0 ? supAmtCol : undefined),
        labourAmountCol: (insAmtCol >= 0 ? insAmtCol : undefined),
      };
    }
  }

  // ---------- One-row MEP header fallback (plain “Supply Rate”, “Installation Amount”, etc.) ----------
  for (let r = 0; r < Math.min(30, rows.length); r++) {
    const row = rows[r] || [];
    const found = {};

    for (let c = 0; c < row.length; c++) {
      const cell = String(row[c]).trim();
      if (!cell) continue;

      if (/^(sr|sl)\.?\s*no\.?$|^s\.?\s*no\.?$/i.test(cell)) found.slNoCol = c;
      if (/^d(?:escr|escription)/i.test(cell))               found.descCol = c;
      if (/^unit$/i.test(cell))                              found.unitCol = c;
      if (/^(qty|quantity|qtty|total\s*q(?:ty)?|t\s*qty|academic\s*qty)$/i.test(cell)) found.qtyCol = c;

      if (/^supply\s*rate$/i.test(cell) || /^s\.?\s*rate$/i.test(cell))        found.supplyRateCol = c;
      if (/^labou?r\s*rate$/i.test(cell) || /^install(?:ation)?\s*rate$/i.test(cell)) found.labourRateCol = c;
      if (/^supply\s*amount$/i.test(cell) || /^s\.?\s*amt$/i.test(cell))       found.supplyAmountCol = c;
      if (/^labou?r\s*amount$/i.test(cell) || /^install(?:ation)?\s*amount$/i.test(cell)) found.labourAmountCol = c;
    }

    const hasQtyOrRates = (found.qtyCol != null) || (found.supplyRateCol != null) || (found.supplyAmountCol != null);
    if (found.descCol != null && hasQtyOrRates) {
      return { startRow: r + 1, ...found, isMEP: true, simpleQtyOnly: true };
    }
  }

  return null; // let the civil detector try next
}



function looksLike(name, patterns){ return patterns.some(re => re.test(String(name||"").trim())); }
function normalizeDesc(s){
  return String(s ?? "")
    .toLowerCase()
    .replace(/\s+/g, " ")
    .replace(/[^\p{L}\p{N}\s]/gu, "")
    .trim();
}

function inferSheetConfigFromWorksheet(worksheet) {
  const rows = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: false, defval: "" });

  // ---- single-row header pass ----
  let best = null;
  for (let r = 0; r < Math.min(30, rows.length); r++) {
    const row = rows[r] || [];
    const found = {};

    for (let c = 0; c < row.length; c++) {
      const cell = String(row[c]).trim();
      if (!cell) continue;

      if (looksLike(cell, HEADER_SYNONYMS.slNo)) found.slNoCol = c;
      if (looksLike(cell, HEADER_SYNONYMS.desc)) found.descCol = c;
      if (looksLike(cell, HEADER_SYNONYMS.unit)) found.unitCol = c;
      if (looksLike(cell, HEADER_SYNONYMS.qty))  found.qtyCol  = c;
      if (looksLike(cell, HEADER_SYNONYMS.rate)) found.rateCol = c;

      if (looksLike(cell, HEADER_SYNONYMS.amount)) {
        (found.amountCandidates ||= []).push(c);
      }
    }
    if (found.amountCandidates && found.amountCandidates.length) {
      found.amountCol = Math.max(...found.amountCandidates); // rightmost "Amount"
      delete found.amountCandidates;
    }

    const hasCore   = found.slNoCol != null && found.descCol != null;
    const hasValues = found.qtyCol != null || found.rateCol != null || found.amountCol != null;
    if (!hasCore) continue;

    const score =
      (hasValues ? 10 : 0) +
      (found.unitCol  != null ? 2 : 0) +
      (found.qtyCol   != null ? 3 : 0) +
      (found.rateCol  != null ? 3 : 0) +
      (found.amountCol!= null ? 3 : 0);

    if (!best || score > best.score) best = { row: r, cols: found, score };
  }

  // ---- two-row header fallback (row r has Sl.No/Desc; row r+1 has Qty/Rate/Amount) ----
  if (!best || !(best.cols.qtyCol != null || best.cols.rateCol != null || best.cols.amountCol != null)) {
    for (let r = 0; r < Math.min(30, rows.length - 1); r++) {
      const rowA = rows[r] || [];
      const rowB = rows[r + 1] || [];
      const A = {}, B = {};

      for (let c = 0; c < rowA.length; c++) {
        const cell = String(rowA[c]).trim();
        if (!cell) continue;
        if (looksLike(cell, HEADER_SYNONYMS.slNo)) A.slNoCol = c;
        if (looksLike(cell, HEADER_SYNONYMS.desc)) A.descCol = c;
        if (looksLike(cell, HEADER_SYNONYMS.unit)) A.unitCol = c;
      }
      for (let c = 0; c < rowB.length; c++) {
        const cell = String(rowB[c]).trim();
        if (!cell) continue;
        if (looksLike(cell, HEADER_SYNONYMS.qty))    B.qtyCol = c;
        if (looksLike(cell, HEADER_SYNONYMS.rate))   B.rateCol = c;
        if (looksLike(cell, HEADER_SYNONYMS.amount)) (B.amountCandidates ||= []).push(c);
      }
      if (B.amountCandidates && B.amountCandidates.length) {
        B.amountCol = Math.max(...B.amountCandidates);
      }

      const hasCore   = A.slNoCol != null && A.descCol != null;
      const hasValues = B.qtyCol != null || B.rateCol != null || B.amountCol != null;

      if (hasCore && hasValues) {
        return { startRow: r + 2, ...A, ...B }; // data starts after the subheader row
      }
    }
  }

  // ---- use best single-row header if we found one ----
  if (best) {
    const cols = { ...best.cols };

    // amount-only abstracts (no Rate/Qty but have Amount)
    if (cols.rateCol == null && cols.amountCol != null && cols.qtyCol == null) {
      cols.rateCol = cols.amountCol;
      cols.assumeQty1 = true;
      cols.amountAsRate = true;
      cols.amountOnly = true;
    }
    return { startRow: best.row + 1, ...cols };
  }

  // last resort
  return DEFAULT_BOQ_CONFIG;
}






// Wrapper used by parseExcelFile:
function inferSheetConfigAuto(worksheet){
  if (COMPARISON_MODE === 'mep') {
    const mep = inferSheetConfigFromWorksheetMEP(worksheet);
    if (mep) return mep;
  }
  // fallback to your existing logic
  return inferSheetConfigFromWorksheet(worksheet);
}


/* ===================== Config ===================== */
const DEFAULT_BOQ_CONFIG = { startRow: 5, slNoCol: 0, descCol: 1, unitCol: 2, qtyCol: 3, rateCol: 4, amountCol: 5 };
const DATA_CONFIG = {
  "BOQ-Compound Wall": { startRow: 3, slNoCol: 0, descCol: 1, unitCol: 2, qtyCol: 3, rateCol: 4, amountCol: 5 }
};
const ESTIMATE_CONFIG = {
  "BOQ-Compound Wall": { startRow: 4, slNoCol: 0, descCol: 1, unitCol: 2, qtyCol: 3, rateCol: 4, amountCol: 5 }
};

/* ===================== State & DOM ===================== */
let consolidatedData = {};
let bidderNames = [];
let processedSheetNames = [];

const processButton = document.getElementById("process-button");
const downloadButton = document.getElementById("download-button");
const estimateFileInput = document.getElementById("estimate-file");
const bidderFilesInput = document.getElementById("bidder-files");
const outputSection = document.getElementById("output-section");
const loader = document.getElementById("loader");

document.addEventListener("keydown", (e) => {
  if (e.key === "Escape") closeExportModal();
});


let COMPARISON_MODE = 'civil'; // or 'mep'

function openModeModal(){ document.getElementById('mode-modal').classList.remove('hidden'); }
function closeModeModal(){ document.getElementById('mode-modal').classList.add('hidden'); }
function startProcessing(mode){
  COMPARISON_MODE = (mode === 'mep') ? 'mep' : 'civil';
  closeModeModal();
  handleProcessFiles(); // continues your original flow
}



function setUiBusy(busy) {
  // Show/hide the same loader used by "Generate Comparison"
  loader.classList.toggle("hidden", !busy);
  // Optionally prevent double clicks
  processButton.disabled = busy;
  downloadButton.disabled = busy;
}

function delayedOpenExportModal(delayMs = 800) {
  // Make sure data is ready (so we don't show a modal with empty state)
  if (!Array.isArray(processedSheetNames) || processedSheetNames.length === 0) {
    alert("Generate the comparison first, then export.");
    return;
  }

  setUiBusy(true);                // show spinner
  requestAnimationFrame(() => {   // ensure the spinner paints
    setTimeout(() => {            // keep it visible for a short moment
      setUiBusy(false);           // hide spinner
      openExportModal();          // then open your modal
    }, delayMs);
  });
}


processButton.addEventListener("click", openModeModal);



downloadButton.addEventListener("click", () => delayedOpenExportModal(900)); // tweak delay as you like


function parseNumber(v) {
  if (v === null || typeof v === "undefined") return 0;
  const num = parseFloat(String(v).replace(/,/g, ""));
  return isNaN(num) ? 0 : num;
}

/* ===================== Main processing ===================== */
async function handleProcessFiles() {
  const estimateFile = estimateFileInput.files[0];
  const bidderFiles = bidderFilesInput.files;

  if (!estimateFile || bidderFiles.length === 0) {
    alert("Please select an estimate file and at least one bidder file.");
    return;
  }
  if (bidderFiles.length > 7) {
    alert("You can select a maximum of 7 bidder files.");
    return;
  }

  loader.classList.remove("hidden");
  outputSection.classList.add("hidden");

  try {
    bidderNames = Array.from(bidderFiles).map((f) =>
      f.name.split(".")[0].replace(/DGG_BIDDER_/i, "BIDDER ").trim()
    );

    const estimateData = await parseExcelFile(estimateFile, true);
    const biddersData = await Promise.all(Array.from(bidderFiles).map((file) => parseExcelFile(file, false)));

    // const boqSheetNames = Object.keys(estimateData);
    // processedSheetNames = ["Summary", ...boqSheetNames];

    processedSheetNames = [
  "Summary",
  ...estimateSheetKeysOrdered.filter((key) => !!estimateData[key])
];

    consolidateAllData(estimateData, biddersData);

    const { lower, upper } = getVarianceThresholds();
    document.getElementById("lower-variance-label").textContent = `Low < ${lower}`;
    document.getElementById("upper-variance-label").textContent = `High > ${upper}`;

    renderUI();
    outputSection.classList.remove("hidden");
    downloadButton.classList.remove("hidden");
    document.getElementById("reload-page").classList.remove("hidden");
    processButton.classList.add("hidden"); 
  } catch (e) {
    console.error("Error during file processing:", e);
    alert("An error occurred while processing the files. Please check the console for details.");
  } finally {
    loader.classList.add("hidden");
  }
}

document.getElementById("reload-page").addEventListener("click", () => {
  window.location.reload();
});


function normalizeName(s) {
  return String(s || "").toLowerCase().replace(/\s+/g, " ").trim();
}



// read excel (formatted text, blanks -> "")

// read excel (formatted text, blanks -> "")
function parseExcelFile(file, isEstimate) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();

    reader.onload = (e) => {
      try {
        const workbook = XLSX.read(new Uint8Array(e.target.result), { type: "array" });
        const parsed = {};

        // keep the estimate sheet order from this workbook, but only after filtering
        const seenEstimateKeys = new Set();

        workbook.SheetNames.forEach((sheetName) => {
          const norm = normalizeName(sheetName);

          // ⛔ skip summary/measurement tabs entirely
          if (EXCLUDE_SHEETS.some((re) => re.test(norm))) return;

          // remember original display name (proper case) for UI/Excel
          sheetDisplayNameMap[norm] = sheetName;

          // for the estimate file, remember order of *only* kept sheets
          if (isEstimate && !seenEstimateKeys.has(norm)) {
            seenEstimateKeys.add(norm);
          }

          const worksheet = workbook.Sheets[sheetName];
          if (!worksheet) return;

          const cfg =
            getConfigForSheet(sheetName, isEstimate) ||
            inferSheetConfigAuto(worksheet);

          const rows = XLSX.utils.sheet_to_json(worksheet, {
            header: 1,
            range: Math.max(0, (cfg.startRow ?? 1) - 1),
            raw: false,
            defval: "",
          });
          rows._cfg = cfg;

          parsed[norm] = rows; // store using normalized key
        });

        // update the global order list only after we’ve filtered
        if (isEstimate) {
          estimateSheetKeysOrdered = Array.from(seenEstimateKeys);
        }

        resolve(parsed);
      } catch (err) {
        reject(err);
      }
    };

    reader.onerror = reject;
    reader.readAsArrayBuffer(file);
  });
}




function normalizeSrNo(value) {
  const s = String(value ?? "").trim();
  if (!s) return "";
  const cleaned = s.replace(/[^\d.]/g, "");
  if (!cleaned) return "";
  if (!cleaned.includes(".")) return cleaned.replace(/^0+/, "") || "0";
  const [intPart, decPartRaw] = cleaned.split(".");
  const dec = (decPartRaw || "").replace(/[^0-9]/g, "");
  if (dec && /^0+$/.test(dec)) return (intPart.replace(/^0+/, "") || "0");
  return `${intPart.replace(/^0+/, "") || "0"}.${dec}`;
}

/* ---------- Build consolidated structure ---------- */

/* ---------- Build consolidated structure (FIXED isCategory for MEP too) ---------- */

/* ---------- Build consolidated structure (fixed bcfg typo + MEP category/abstract handling) ---------- */
function consolidateAllData(estimateData, biddersData) {
  consolidatedData = {};

  // local regexes for markers
  const SUBTOTAL_RE     = /sub[\s-]?total/i;
  const TOTAL_AMOUNT_RE = /total\s*amount/i;
  const TOTAL_OF_RE     = /^total\s+of/i;
  const GRAND_RE        = /\bgrand\s*total\b|^total\s+including\s+gst/i;

  for (const sheetName in estimateData) {
    const estimateRows = estimateData[sheetName];
    if (!estimateRows) continue;

    const cfg =
      (estimateRows && estimateRows._cfg) ||
      getConfigForSheet(sheetName, true) ||
      DEFAULT_BOQ_CONFIG;

    // is this an MEP-style sheet?
    const isMEPSheet = !!(cfg.isMEP || COMPARISON_MODE === "mep");

    // amount-only (CIVIL only)
    const isAmountOnlySheet =
      isMEPSheet
        ? false
        : !!(
            cfg.amountOnly ||
            cfg.amountAsRate ||
            (cfg.slNoCol == null && cfg.qtyCol == null && cfg.rateCol === cfg.amountCol)
          );

    const items = (estimateRows || [])
      .map((row) => {
        const slNoRaw     = cfg.slNoCol != null ? row[cfg.slNoCol] : "";
        const slNo        = String(slNoRaw || "").trim();
        const description = row[cfg.descCol] || "";
        if (!slNo && !description) return null;

        const label = String(description || "").trim();

        // Roads & Drains summary rows
        const isRoadsLine = RD_BREAK_LABELS.roads.some(re => re.test(label));
        const isSWDLine   = RD_BREAK_LABELS.swd.some(re => re.test(label));
        const isRDSummaryLine = isRoadsLine || isSWDLine;

        // detect ABSTRACT anywhere
        const isAbstractRow = /\babstract\b/i.test(label);

        // ------------------- read estimate side -------------------
        let qty = 0;
        let rateFromFile = 0;
        let rawAmountFromFile = 0;

        // MEP extras
        let estSRate=0, estLRate=0, estSAmt=0, estLAmt=0;
        let gfQty=0, oneFQty=0, tfQty=0;

        if (isMEPSheet) {
          const f = extractMEPFields(row, cfg);
          qty               = f.qty;
          rateFromFile      = f.unitRate;
          rawAmountFromFile = f.amount;
          estSRate = f.sRate;  estLRate = f.lRate;
          estSAmt  = f.sAmt;   estLAmt  = f.lAmt;
          gfQty    = f.gfQty;  oneFQty  = f.oneFQty;  tfQty = f.tfQty;
        } else {
          // CIVIL (Qty × Rate)
          qty = parseQty(cfg.qtyCol != null ? row[cfg.qtyCol] : "");
          if (cfg.assumeQty1) qty = 1;

          // treat ABSTRACT + R/D summary as amount-only lines
          if (isRDSummaryLine || isAbstractRow) {
            const byAmount = (cfg.amountCol != null) ? parseNumber(row[cfg.amountCol]) : 0;
            const byCalc   = (qty || 0) * (parseNumber(row[cfg.rateCol]) || 0);
            rateFromFile      = 0;
            rawAmountFromFile = byAmount > 0 ? byAmount : byCalc;
          } else {
            const useAmtAsRate = cfg.amountAsRate;
            rateFromFile       = useAmtAsRate ? parseNumber(row[cfg.amountCol]) : parseNumber(row[cfg.rateCol]);
            rawAmountFromFile  = isAmountOnlySheet ? parseNumber(row[cfg.amountCol]) : 0;
          }
        }

        // mark top-level numbers (1/2/3/…) as category for BOTH Civil & MEP
        const isTopNumber = /^\d+(?:\.0+)?$/.test(slNo);

        const item = {
          slNo,
          description,
          unit: row[cfg.unitCol] || "",
          qty,
          gfQty:   gfQty || 0,
          oneFQty: oneFQty || 0,
          tfQty:   tfQty || 0,
          estimate: {
            rate:      (isMEPSheet || isRDSummaryLine || isAbstractRow) ? 0 : (isAmountOnlySheet ? 0 : rateFromFile),
            amount:    0,
            rawAmount: rawAmountFromFile,
            sRate:   estSRate || 0,
            lRate:   estLRate || 0,
            sAmount: estSAmt  || 0,
            lAmount: estLAmt  || 0
          },
          bidders: [],
          isSubtotal:   SUBTOTAL_RE.test(description) || TOTAL_AMOUNT_RE.test(description) || TOTAL_OF_RE.test(description),
          isGrandTotal: GRAND_RE.test(description),
          isCategory:   (!isAmountOnlySheet && isTopNumber),
          amountOnly:   isMEPSheet ? false : (isAmountOnlySheet || isRDSummaryLine || isAbstractRow),
          isSummaryRow: !!isRDSummaryLine,
          isAbstract:   !!isAbstractRow
        };

        const estimateKeySr   = normalizeSrNo(slNo);
        const estimateKeyDesc = normalizeDesc(description);

        // ------------------- read bidders side -------------------
        biddersData.forEach((bidder, index) => {
          const bidderSheet = bidder[sheetName];
          let bRate = 0, bRawAmt = 0;
          let bSRate=0, bLRate=0, bSAmt=0, bLAmt=0;

          if (bidderSheet) {
            const bcfg =
              (bidderSheet && bidderSheet._cfg) ||
              getConfigForSheet(sheetName, false) ||
              cfg;

            const estTopPrefix = (estimateKeySr && estimateKeySr.includes("."))
              ? estimateKeySr.split(".")[0] + "."
              : "";

            // 1) strict Sr.No match
            let match = bidderSheet.find((bRow) => {
              const keySr = (bcfg.slNoCol != null) ? normalizeSrNo(bRow[bcfg.slNoCol]) : "";
              return (estimateKeySr && keySr && keySr === estimateKeySr);
            });

            // 2) fallback description match (⚠️ fixed bcfg typo here)
            if (!match) {
              match = bidderSheet.find((bRow) => {
                const keyDesc = (bcfg.descCol != null) ? normalizeDesc(bRow[bcfg.descCol]) : "";
                const keySr   = (bcfg.slNoCol  != null) ? normalizeSrNo(bRow[bcfg.slNoCol]) : "";
                if (estimateKeyDesc && keyDesc && keyDesc === estimateKeyDesc) {
                  if (estTopPrefix && keySr) return keySr.startsWith(estTopPrefix);
                  return true;
                }
                return false;
              });
            }

            if (match) {
              if (bcfg.isMEP || COMPARISON_MODE === "mep") {
                const f = extractMEPFields(match, bcfg);
                bRawAmt = f.amount;
                bRate   = f.unitRate;
                bSRate  = f.sRate;  bLRate = f.lRate;
                bSAmt   = f.sAmt;   bLAmt  = f.lAmt;
              } else {
                // for ABSTRACT and R/D summary, prefer amount
                if (isAbstractRow || isRDSummaryLine) {
                  const byAmount = (bcfg.amountCol != null) ? parseNumber(match[bcfg.amountCol]) : 0;
                  const byCalc   = (qty || 0) * (parseNumber(match[bcfg.rateCol]) || 0);
                  bRawAmt = byAmount > 0 ? byAmount : byCalc;
                  bRate   = 0;
                } else {
                  const useAmount = bcfg.amountAsRate || (bcfg.rateCol == null && bcfg.amountCol != null);
                  if (useAmount) {
                    bRawAmt = parseNumber(match[bcfg.amountCol]) || 0;
                    bRate   = 0;
                  } else {
                    bRate   = parseNumber(match[bcfg.rateCol]) || 0;
                  }
                }
              }
            }
          }

          item.bidders.push({
            name: bidderNames[index],
            rate: bRate,
            amount: 0,
            rawAmount: bRawAmt,
            sRate: bSRate || 0, lRate: bLRate || 0, sAmount: bSAmt || 0, lAmount: bLAmt || 0
          });
        });

        return item;
      })
      .filter(Boolean);

    items._cfg = cfg;
    items._isAmountOnly = isAmountOnlySheet;

    consolidatedData[sheetName] = items;
  }

  // compute all totals & summary
  calculateAllTotals();
}


/* ---------- Totals ---------- */



/* ---------- Totals (FIXED category totals for MEP S/L + ABSTRACT behavior) ---------- */
function calculateAllTotals() {
  const summarySheetData = {};

  // -------- helper: if an ABSTRACT has no values, sum its following details --------
  function fillAbstractAmounts(sheetData) {
    for (let i = 0; i < sheetData.length; i++) {
      const row = sheetData[i];
      if (!row) continue;

      const label = String(row.description || "").trim();
      if (!/\babstract\b/i.test(label)) continue;

      // already has numbers? keep them
      const hasAny =
        Number(row.estimate?.amount || 0) > 0 ||
        (row.bidders || []).some((b) => Number(b.amount || 0) > 0);
      if (hasAny) continue;

      let est = 0;
      const bids = Array(bidderNames.length).fill(0);

      for (let j = i + 1; j < sheetData.length; j++) {
        const r = sheetData[j];
        if (!r) break;

        const rLabel = String(r.description || "").trim();

        // stop conditions
        if (r.isGrandTotal) break;
        if (/^total\s*amount/i.test(rLabel)) break;
        if (/\babstract\b/i.test(rLabel)) break;

        // skip headings & subtotals; still keep summing details
        if (r.isCategory || r.isSubtotal) continue;

        est += Number(r.estimate?.amount || 0);
        (r.bidders || []).forEach((b, k) => (bids[k] += Number(b.amount || 0)));
      }

      row.estimate.amount = est;
      (row.bidders || []).forEach((b, k) => (b.amount = bids[k]));
    }
  }

  // -------- helper: tie ABSTRACTS to the nearest neighbor SUB-TOTALS --------
  function linkAbstractsToNeighborSubtotals(sheetData) {
    if (!Array.isArray(sheetData)) return;

    // pass 1: copy the NEAREST SUB-TOTAL *above* each ABSTRACT
    let lastSubtotal = null; // {est:number, bids:number[]}
    for (let i = 0; i < sheetData.length; i++) {
      const row = sheetData[i];
      if (!row) continue;

      const label = String(row.description || "");
      const isTotalAmt = /^total\s*amount/i.test(label);

      if (row.isSubtotal && !isTotalAmt && !row.isGrandTotal) {
        lastSubtotal = {
          est: Number(row?.estimate?.amount || 0),
          bids: (row?.bidders || []).map((b) => Number(b.amount || 0)),
        };
        continue;
      }

      if (/\babstract\b/i.test(label)) {
        const abs = row;
        const alreadyHas =
          Number(abs?.estimate?.amount || 0) > 0 ||
          (abs?.bidders || []).some((b) => Number(b.amount || 0) > 0);

        if (!alreadyHas && lastSubtotal) {
          abs.estimate.amount = lastSubtotal.est || 0;
          (abs.bidders || []).forEach((b, k) => {
            b.amount = lastSubtotal.bids?.[k] || 0;
          });
        }

        // use each subtotal at most once (typical layout)
        lastSubtotal = null;
      }
    }

    // pass 2: if an ABSTRACT still has nothing, copy the FIRST SUB-TOTAL *below* it
    let pendingAbstractIdx = -1;
    for (let i = 0; i < sheetData.length; i++) {
      const row = sheetData[i];
      if (!row) continue;

      const label = String(row.description || "");
      const isAbstract = /\babstract\b/i.test(label);
      const isTotalAmt = /^total\s*amount/i.test(label);
      const isRegularSub = row.isSubtotal && !isTotalAmt && !row.isGrandTotal;

      if (isAbstract) {
        pendingAbstractIdx = i;
        continue;
      }
      if (pendingAbstractIdx >= 0 && isRegularSub) {
        const abs = sheetData[pendingAbstractIdx];
        const alreadyHas =
          Number(abs?.estimate?.amount || 0) > 0 ||
          (abs?.bidders || []).some((b) => Number(b.amount || 0) > 0);
        if (!alreadyHas) {
          abs.estimate.amount = Number(row?.estimate?.amount || 0);
          (abs.bidders || []).forEach((b, k) => {
            b.amount = Number(row?.bidders?.[k]?.amount || 0);
          });
        }
        pendingAbstractIdx = -1; // done for this ABSTRACT
      }
    }
  }

  // -------- per-sheet processing --------
  for (const sheetName of Object.keys(consolidatedData)) {
    const sheetData = consolidatedData[sheetName];
    if (!Array.isArray(sheetData)) continue;

    // ---- 1) row amounts ----
    sheetData.forEach((item) => {
      if (item.isSubtotal || item.isGrandTotal || item.isCategory) return;

      const isMEPSheet =
        COMPARISON_MODE === "mep" ||
        (consolidatedData[sheetName]?._cfg && consolidatedData[sheetName]._cfg.isMEP);

      if (!item.amountOnly) {
        const q = Number(item.qty || 0);
        if (q === 0 && !isMEPSheet) {
          item.estimate.rate = "";
          item.estimate.amount = "";
          item.estimate.rawAmount = "";
          if (isMEPSheet) {
            item.estimate.sRate = "";
            item.estimate.lRate = "";
            item.estimate.sAmount = "";
            item.estimate.lAmount = "";
          }
          item.bidders.forEach((b) => {
            b.rate = "";
            b.amount = "";
            b.rawAmount = "";
            if (isMEPSheet) {
              b.sRate = "";
              b.lRate = "";
              b.sAmount = "";
              b.lAmount = "";
            }
          });
          return;
        }
      }

      if (isMEPSheet) {
        const qty      = Number(item.qty || 0);
        const sRateEst = Number(item.estimate?.sRate || 0);
        const lRateEst = Number(item.estimate?.lRate || 0);
        let   sAmtEst  = Number(item.estimate?.sAmount || 0);
        let   lAmtEst  = Number(item.estimate?.lAmount || 0);

        if (sAmtEst <= 0 && sRateEst > 0 && qty > 0) sAmtEst = sRateEst * qty;
        if (lAmtEst <= 0 && lRateEst > 0 && qty > 0) lAmtEst = lRateEst * qty;

        item.estimate.sAmount = sAmtEst;
        item.estimate.lAmount = lAmtEst;

        if (!item.estimate.rate || item.estimate.rate === 0) {
          const comb = sRateEst + lRateEst;
          if (comb > 0) item.estimate.rate = comb;
          else if (qty > 0 && (sAmtEst + lAmtEst) > 0)
            item.estimate.rate = (sAmtEst + lAmtEst) / qty;
        }

        const estRaw = Number(item.estimate?.rawAmount || 0);
        if (estRaw > 0) item.estimate.amount = estRaw;
        else if (sAmtEst + lAmtEst > 0) item.estimate.amount = sAmtEst + lAmtEst;
        else item.estimate.amount = qty * Number(item.estimate.rate || 0);

        item.bidders.forEach((b) => {
          const bQty   = qty;
          const sRateB = Number(b.sRate || 0);
          const lRateB = Number(b.lRate || 0);
          let   sAmtB  = Number(b.sAmount || 0);
          let   lAmtB  = Number(b.lAmount || 0);

          if (sAmtB <= 0 && sRateB > 0 && bQty > 0) sAmtB = sRateB * bQty;
          if (lAmtB <= 0 && lRateB > 0 && bQty > 0) lAmtB = lRateB * bQty;

          b.sAmount = sAmtB;
          b.lAmount = lAmtB;

          if (!b.rate || b.rate === 0) {
            const r = sRateB + lRateB;
            if (r > 0) b.rate = r;
            else if (bQty > 0 && (sAmtB + lAmtB) > 0) b.rate = (sAmtB + lAmtB) / bQty;
          }

          const raw = Number(b.rawAmount || 0);
          if (raw > 0) b.amount = raw;
          else if (sAmtB + lAmtB > 0) b.amount = sAmtB + lAmtB;
          else b.amount = bQty * Number(b.rate || 0);
        });
      } else if (item.amountOnly) {
        item.estimate.amount = Number(item.estimate.rawAmount || 0);
        item.bidders.forEach((b) => (b.amount = Number(b.rawAmount || 0)));
      } else {
        const qty = Number(item.qty || 0);
        item.estimate.amount = qty * Number(item.estimate.rate || 0);
        item.bidders.forEach((b) => (b.amount = qty * Number(b.rate || 0)));
      }
    });

    // ---- 2) running subtotals ----
    let running = { estimate: 0, bidders: Array(bidderNames.length).fill(0) };

    sheetData.forEach((item) => {
      const isMEPSheet =
        COMPARISON_MODE === "mep" ||
        (sheetData?._cfg && sheetData._cfg.isMEP);

      if (item.isCategory) {
        running = { estimate: 0, bidders: Array(bidderNames.length).fill(0) };
        return;
      }

      if (item.isSubtotal) {
        const isTotalAmountLine = /^total\s*amount/i.test(String(item.description || ""));

        if (isMEPSheet && isTotalAmountLine) {
          const estFromFile =
            Number(item.estimate?.rawAmount || 0) ||
            (Number(item.estimate?.sAmount || 0) + Number(item.estimate?.lAmount || 0));
          item.estimate.amount = estFromFile > 0 ? estFromFile : running.estimate;

          item.bidders.forEach((b, i) => {
            const bidFromFile =
              Number(b.rawAmount || 0) ||
              (Number(b.sAmount || 0) + Number(b.lAmount || 0));
            b.amount = bidFromFile > 0 ? bidFromFile : running.bidders[i];
          });
        } else {
          item.estimate.amount = running.estimate;
          item.bidders.forEach((b, i) => (b.amount = running.bidders[i]));
        }

        running = { estimate: 0, bidders: Array(bidderNames.length).fill(0) };
        return;
      }

      // NOTE: do not add ABSTRACT rows to running totals
      if (!item.isGrandTotal && !item.isAbstract) {
        running.estimate += Number(item.estimate.amount || 0);
        item.bidders.forEach((b, i) => (running.bidders[i] += Number(b.amount || 0)));
      }
    });

    // ➕ bind ABSTRACT rows to neighbor subtotals (above or below)
    linkAbstractsToNeighborSubtotals(sheetData);

    // ---- 3) category totals (FIXED: also fill MEP S/L splits) ----
    const isMEPSheet_here =
      COMPARISON_MODE === "mep" || (sheetData?._cfg && sheetData._cfg.isMEP);

    const categoryTotals = {};

    sheetData.forEach((item) => {
      const sr = String(item.slNo || "");

      const contributes =
        sr.includes(".") &&
        !item.isCategory &&
        !item.isSubtotal &&
        !item.isGrandTotal &&
        !item.isAbstract;

      if (!contributes) return;

      const top = sr.split(".")[0];
      if (!categoryTotals[top]) {
        categoryTotals[top] = {
          estimate: 0,
          bidders: Array(bidderNames.length).fill(0),
          // S/L splits for MEP views
          sEst: 0,
          lEst: 0,
          sBidders: Array(bidderNames.length).fill(0),
          lBidders: Array(bidderNames.length).fill(0),
        };
      }

      // Combined (works for both Civil & MEP)
      const estAmt = Number(item.estimate?.amount || 0);
      categoryTotals[top].estimate += estAmt;
      item.bidders.forEach((b, i) => {
        categoryTotals[top].bidders[i] += Number(b.amount || 0);
      });

      // S/L split for MEP so category rows show amounts in S/L columns
      if (isMEPSheet_here) {
        categoryTotals[top].sEst += Number(item.estimate?.sAmount || 0);
        categoryTotals[top].lEst += Number(item.estimate?.lAmount || 0);
        item.bidders.forEach((b, i) => {
          categoryTotals[top].sBidders[i] += Number(b.sAmount || 0);
          categoryTotals[top].lBidders[i] += Number(b.lAmount || 0);
        });
      }
    });

    // write totals back into the category header rows
    sheetData.forEach((item) => {
      const key = String(item.slNo || "").split(".")[0];
      const cat = categoryTotals[key];
      if (!item.isCategory || !cat) return;

      // always set combined totals
      item.estimate.amount = cat.estimate;
      item.bidders.forEach((b, i) => (b.amount = cat.bidders[i]));

      // if MEP, also set S/L split so they render in S/L columns
      if (isMEPSheet_here) {
        item.estimate.sAmount = cat.sEst;
        item.estimate.lAmount = cat.lEst;
        item.bidders.forEach((b, i) => {
          b.sAmount = cat.sBidders[i];
          b.lAmount = cat.lBidders[i];
        });
      }
    });

    // 🔹 if any ABSTRACT still has no numbers, fill by summing its details
    fillAbstractAmounts(sheetData);

    // ---- 4) grand & summary pick ----
    const isMEPSheet =
      COMPARISON_MODE === "mep" ||
      (sheetData?._cfg && sheetData._cfg.isMEP);

    const grand = { estimate: 0, bidders: Array(bidderNames.length).fill(0) };
    sheetData.forEach((item) => {
      const isDetail =
        !item.isSubtotal && !item.isGrandTotal && !item.isCategory && !item.isAbstract;
      if (isDetail) {
        grand.estimate += Number(item.estimate.amount || 0);
        item.bidders.forEach((b, i) => (grand.bidders[i] += Number(b.amount || 0)));
      }
    });

    if (!isMEPSheet) {
      let grandRow = sheetData.find((r) => r.isGrandTotal);
      if (!grandRow) {
        grandRow = {
          slNo: "",
          description: "GRAND TOTAL",
          unit: "",
          qty: "",
          estimate: { rate: 0, amount: 0 },
          bidders: bidderNames.map((n) => ({ name: n, rate: 0, amount: 0 })),
          isSubtotal: false,
          isGrandTotal: true,
          isCategory: false,
          amountOnly: sheetData._isAmountOnly,
        };
        sheetData.push(grandRow);
      }
      grandRow.estimate.amount = grand.estimate;
      grandRow.bidders.forEach((b, i) => (b.amount = grand.bidders[i]));
    } else {
      const idx = sheetData.findIndex((r) => r.isGrandTotal);
      if (idx >= 0) sheetData.splice(idx, 1);
    }

    let summaryEst = grand.estimate;
    let summaryBids = grand.bidders;

    if (isMEPSheet) {
      const totalAmtRow = sheetData.find(
        (r) => r.isSubtotal && /^total\s*amount/i.test(String(r.description || ""))
      );
      if (totalAmtRow) {
        summaryEst  = Number(totalAmtRow.estimate?.amount || 0);
        summaryBids = totalAmtRow.bidders.map((b) => Number(b.amount || 0));
      }
    }

    summarySheetData[sheetName] = {
      estimateAmount: summaryEst,
      bidderAmounts: summaryBids,
    };

    // Roads/Drains breakdown (unchanged)
    const rdRows = sheetData.filter((r) => r.isSummaryRow);
    if (rdRows.length) {
      const breakdown = {};
      rdRows.forEach((r) => {
        breakdown[String(r.description).trim()] = {
          estimateAmount: Number(r.estimate.amount || 0),
          bidderAmounts: r.bidders.map((b) => Number(b.amount || 0)),
        };
      });
      summarySheetData.__roadsBreakdown = breakdown;
    }
  }

  // ---- 5) build summary sheet ----
  buildSummarySheet(summarySheetData);
}


/* ---------- Summary builder ---------- */

function buildSummarySheet(summaryData) {
  const rows = [];
  const bidderZero = () => Array(bidderNames.length).fill(0);
  const addArr = (a, b) => a.map((v, i) => v + (b[i] || 0));

  // one row per sheet from the Estimate file, exact names, same order
  let serial = 1;
  let running = { estimateAmount: 0, bidderAmounts: bidderZero() };

  estimateSheetKeysOrdered.forEach((key) => {
    const d = summaryData[key];
    if (!d) return;
    const bids = d.bidderAmounts || bidderZero();
    const least = Math.min(...bids.filter(v => v > 0), Infinity);
    rows.push({
      kind: "item",
      slNo: serial++,
      description: displayNameFor(key),     // e.g., "CIVIL & FINISHES"
      estimateAmount: d.estimateAmount || 0,
      bidderAmounts: bids,
      leastAmount: isFinite(least) ? least : 0
    });
    running.estimateAmount += d.estimateAmount || 0;
    running.bidderAmounts = addArr(running.bidderAmounts, bids);
  });

  // TOTAL
  const totalLeast = Math.min(...running.bidderAmounts.filter(v => v > 0), Infinity);
  rows.push({
    kind: "grand",
    slNo: "",
    description: "TOTAL",
    estimateAmount: running.estimateAmount,
    bidderAmounts: running.bidderAmounts,
    leastAmount: isFinite(totalLeast) ? totalLeast : 0
  });

  // GST @ 18%
  const GST_RATE = 0.18;
  const gstRow = {
    kind: "item",
    slNo: "",
    description: "GST @ 18%",
    estimateAmount: running.estimateAmount * GST_RATE,
    bidderAmounts: running.bidderAmounts.map(v => v * GST_RATE),
    leastAmount: 0
  };
  rows.push(gstRow);

  // Total including GST
  rows.push({
    kind: "grand",
    slNo: "",
    description: "Total including GST Rs.",
    estimateAmount: running.estimateAmount + gstRow.estimateAmount,
    bidderAmounts: running.bidderAmounts.map((v, i) => v + gstRow.bidderAmounts[i]),
    leastAmount: 0
  });

  consolidatedData.Summary = rows;
}


/* ===================== UI ===================== */

// Friendly display names for sheets (fallback: strip "BOQ-" only)
const SHEET_NAME_ALIASES = [
  { test: /main\s*bldg/i,           name: "Main Building" },
  { test: /admin.*other.*building/i, name: "Admin–Guest and Other Buildings" },
  { test: /admin.*&.*other/i,        name: "Admin–Guest and Other Buildings" },
  { test: /roads.*drains?|internal\s*roads?/i, name: "Internal Roads" },
  { test: /storm\s*water/i,          name: "Storm Water Drain" },
  { test: /compound\s*wall/i,        name: "Compound wall – Chain Link Fence" },
  { test: /ug\s*sump/i,              name: "UG Sump" }
];

function prettySheetName(sheetName) {
  const raw = String(sheetName || "");
  const cleaned = raw.replace(/^\s*BOQ-?\s*/i, "");
  const hit = SHEET_NAME_ALIASES.find(a => a.test.test(cleaned));
  return hit ? hit.name : cleaned;
}


function renderUI() {
  renderTabs();
  const firstSheet = processedSheetNames[0];
  renderTableForSheet(firstSheet);
  const firstTab = document.querySelector(".tab-button");
  if (firstTab) firstTab.classList.add("active");
}

function renderTabs() {
  const tabsContainer = document.getElementById("tabs-container");
  tabsContainer.innerHTML = "";

  processedSheetNames
    .filter((key) => key === "Summary" || consolidatedData[key]) // 👈 guard
    .forEach((sheetKey) => {
      const btn = document.createElement("button");
      btn.textContent = displayNameFor(sheetKey);
      btn.className =
        "tab-button border-b-2 border-transparent py-2 px-4 text-sm font-medium text-gray-300 hover:text-gray-100 hover:border-gray-500";
      btn.dataset.sheet = sheetKey;
      btn.addEventListener("click", (e) => {
        document.querySelectorAll(".tab-button").forEach((b) => b.classList.remove("active"));
        e.target.classList.add("active");
        renderTableForSheet(sheetKey);
      });
      tabsContainer.appendChild(btn);
    });
}



function renderTableForSheet(sheetName) {
  const tablesContainer = document.getElementById("tables-container");
  tablesContainer.innerHTML = "";
  const data = consolidatedData[sheetName];
  if (!data) {
    tablesContainer.innerHTML = `<p class="p-4">No data available for ${sheetName}.</p>`;
    return;
  }

  const tableContainer = document.createElement("div");
  tableContainer.className = "table-container";
  const topBar = document.createElement("div"); topBar.className = "top-scrollbar";
  const topInner = document.createElement("div"); topInner.className = "top-scrollbar-inner";
  topBar.appendChild(topInner);
  const viewport = document.createElement("div"); viewport.className = "table-viewport";
  const table = document.createElement("table"); table.id = `table-${sheetName.replace(/[\s&]/g, "-")}`;
  const thead = document.createElement("thead");
  const tbody = document.createElement("tbody");

if (sheetName === "Summary") {
  renderSummaryTable(thead, tbody, data);
} else {
  if (COMPARISON_MODE === 'mep') renderBoqTableMEP(thead, tbody, data, sheetName);
  else renderBoqTable(thead, tbody, data, sheetName); // your existing Civil layout
}

  table.append(thead, tbody);
  viewport.appendChild(table);
  tableContainer.appendChild(topBar);
  tableContainer.appendChild(viewport);
  tablesContainer.appendChild(tableContainer);

  topInner.style.width = table.scrollWidth + "px";
  let syncing = false;
  topBar.addEventListener("scroll", () => {
    if (syncing) return; syncing = true; viewport.scrollLeft = topBar.scrollLeft; syncing = false;
  });
  viewport.addEventListener("scroll", () => {
    if (syncing) return; syncing = true; topBar.scrollLeft = viewport.scrollLeft; syncing = false;
  });
}

function renderSummaryTable(thead, tbody, data) {
  const headerRow = document.createElement("tr");
  const cols = ["Sl. No", "Description", "Estimate", ...bidderNames, "Least Amount"];
  cols.forEach((c, i) => {
    const th = document.createElement("th");
    th.textContent = c;
    if (i === 0) th.classList.add("sticky-col-1", "col-slno");
    if (i === 1) th.classList.add("sticky-col-2", "col-desc");
    headerRow.appendChild(th);
  });
  thead.appendChild(headerRow);

  data.forEach((row) => {
    const tr = document.createElement("tr");
    if (row.kind === "category") tr.className = "category-header";
    else if (row.kind === "subtotal") tr.className = "subtotal-row";
    else if (row.kind === "grand") tr.className = "grand-total-row";

    const est = row.estimateAmount || 0;
    const least = row.leastAmount || 0;

    tr.innerHTML = `
      <td class="sticky-col-1 col-slno">${row.slNo || ""}</td>
      <td class="sticky-col-2 col-desc">${row.description || ""}</td>
      <td class="amount-cell"><span class="${zeroCls(est)}">${formatCurrency(est)}</span></td>
      ${bidderNames
        .map((_, i) => {
          const v = ((row.bidderAmounts || [])[i] || 0);
          return `<td class="amount-cell"><span class="${zeroCls(v)}">${formatCurrency(v)}</span></td>`;
        })
        .join("")}
      <td class="least-amount-cell"><span class="${zeroCls(least)}">${formatCurrency(least)}</span></td>
    `;
    tbody.appendChild(tr);
  });
}


function renderBoqTable(thead, tbody, data, sheetName) {
  const amountOnlySheet = !!data._isAmountOnly;

  // (header creation is unchanged in your file)

  const { lower, upper } = getVarianceThresholds();

  data.forEach((item, rowIndex) => {
    const tr = document.createElement("tr");
    if (item.isSubtotal) tr.className = "subtotal-row";
    else if (item.isGrandTotal) tr.className = "grand-total-row";
    else if (item.isCategory) tr.className = "category-header";

    const isEditable = !item.isSubtotal && !item.isGrandTotal && !item.isCategory;

    // 🔹 do NOT blank ABSTRACT rows
    const isAbstractRow = /\babstract\b/i.test(String(item.description || ""));
    const showBlank = isEditable && !isAbstractRow && Number(item.qty || 0) === 0;
    if (isAbstractRow && !tr.className) tr.className = "subtotal-row";

    const least = isEditable ? findLeastBid(item) : { rate: 0, amount: 0 };

    let bidderCellsHtml = "";
    item.bidders.forEach((b, i) => {
      let varianceClass = "";
      if (!amountOnlySheet && isEditable && item.estimate.rate > 0 && b.rate > 0) {
        const ratio = b.rate / item.estimate.rate;
        if (ratio < lower) varianceClass = "bg-blue-100";
        else if (ratio > upper) varianceClass = "bg-orange-100";
      }

      const missing = (!amountOnlySheet && isEditable && !showBlank && isPositiveQty(item.qty) && (!b.rate || b.rate === 0));

      const rateHtml = amountOnlySheet
        ? `<span class="val"></span>`
        : (isEditable
            ? `<input type="number"
                     class="rate-input ${varianceClass} ${missing ? "missing-rate" : ""} ${(b.rate||0)===0 ? "zero-value" : ""}"
                     value="${showBlank ? "" : (b.rate || 0)}"
                     data-row-index="${rowIndex}" data-bidder-index="${i}"
                     onchange="handleRateChange(this, '${sheetName}')" />`
            : `<span class="val ${showBlank ? "" : zeroCls(b.rate || 0)}">${showBlank ? "" : formatCurrency(b.rate || 0)}</span>`);

      bidderCellsHtml += `
        <td class="compact-cell" colspan="2">
          <span class="label">Rate</span>${rateHtml}
          <span class="label">Amt</span><span class="val ${showBlank ? "" : zeroCls(b.amount || 0)}">${showBlank ? "" : formatCurrency(b.amount || 0)}</span>
        </td>`;
    });

    const estRate = amountOnlySheet ? "" : (showBlank ? "" : formatCurrency(item.estimate.rate || 0));
    const estAmt  = showBlank ? "" : formatCurrency(item.estimate.amount || 0);

    tr.innerHTML = `
      <td class="sticky-col-1 col-slno">${item.slNo || ""}</td>
      <td class="sticky-col-2 col-desc">${item.description || ""}</td>
      <td>${item.unit || ""}</td>

      <!-- Qty -->
      <td class="amount-cell ${showBlank ? "" : zeroCls(item.qty || 0)}">${showBlank ? "" : (item.qty || "")}</td>

      <!-- Estimate -->
      <td class="compact-cell" colspan="2">
        <span class="label">Rate</span><span class="val ${showBlank ? "" : zeroCls(item.estimate.rate || 0)}">${amountOnlySheet ? "" : estRate}</span>
        <span class="label">Amt</span><span class="val ${showBlank ? "" : zeroCls(item.estimate.amount || 0)}">${estAmt}</span>
      </td>

      ${bidderCellsHtml}

      <!-- Least Bid -->
      <td class="compact-cell least-rate-cell" colspan="2">
        <span class="label">Rate</span><span class="val ${showBlank ? "" : zeroCls(least.rate)}">${amountOnlySheet ? "" : (showBlank ? "" : formatCurrency(least.rate))}</span>
        <span class="label">Amt</span><span class="val ${showBlank ? "" : zeroCls(least.amount)}">${showBlank ? "" : formatCurrency(least.amount)}</span>
      </td>
    `;
    tbody.appendChild(tr);
  });
}


function renderBoqTableMEP(thead, tbody, data, sheetName) {
  const cfg = data._cfg || {};
  const SIMPLE = !!cfg.simpleQtyOnly || (!cfg.gfCol && !cfg.oneFCol && !cfg.tfCol);

  const h1 = document.createElement("tr");
  const h2 = document.createElement("tr");

  if (SIMPLE) {
    h1.innerHTML = `
      <th rowspan="2" class="sticky-col-1 col-slno">Sr.No.</th>
      <th rowspan="2" class="sticky-col-2 col-desc">Description of Work</th>
      <th colspan="6">Estimate</th>
      ${bidderNames.map(n => `<th colspan="4">${n}</th>`).join("")}
      <th rowspan="2">Least Amount</th>`;
    h2.innerHTML = `
      <th>Unit</th><th>Qty</th>
      <th>Supply Rate</th><th>Installation Rate</th>
      <th>Supply Amount</th><th>Installation Amount</th>
      ${bidderNames.map(()=>`<th>Supply Rate</th><th>Installation Rate</th><th>Supply Amount</th><th>Installation Amount</th>`).join("")}
    `;
  } else {
    h1.innerHTML = `
      <th rowspan="2" class="sticky-col-1 col-slno">Sr.No.</th>
      <th rowspan="2" class="sticky-col-2 col-desc">Description of Work</th>
      <th colspan="9">Estimate</th>
      ${bidderNames.map(n => `<th colspan="4">${n}</th>`).join("")}
      <th rowspan="2">Least Amount</th>`;
    h2.innerHTML = `
      <th>UNIT</th><th>GF</th><th>1F</th><th>TF</th><th>TOTAL QTY</th>
      <th>Supply Rate</th><th>Installation Rate</th>
      <th>Supply Amount</th><th>Installation Amount</th>
      ${bidderNames.map(()=>`<th>Supply Rate</th><th>Installation Rate</th><th>Supply Amount</th><th>Installation Amount</th>`).join("")}
    `;
  }
  thead.append(h1, h2);

  const { lower, upper } = getVarianceThresholds();

  data.forEach((item, rowIndex) => {
    const tr = document.createElement("tr");
    if (item.isSubtotal) tr.className = "subtotal-row";
    else if (item.isGrandTotal) tr.className = "grand-total-row";
    else if (item.isCategory) tr.className = "category-header";

    const isDetail = !item.isSubtotal && !item.isGrandTotal && !item.isCategory;

    // 🔹 do NOT blank ABSTRACT rows
    const isAbstractRow = /\babstract\b/i.test(String(item.description || ""));
    const estUnitRate = Number(item.estimate?.sRate || 0) + Number(item.estimate?.lRate || 0);
    const blankAllMEP = (!isAbstractRow) && isDetail &&
                        (Number(item.qty || 0) === 0 || estUnitRate === 0);
    if (isAbstractRow && !tr.className) tr.className = "subtotal-row";

    const least = (!item.isSubtotal && !item.isGrandTotal && !item.isCategory) ? findLeastBid(item) : { amount: 0 };

    let bidderCellsHtml = "";
    item.bidders.forEach((b, bidderIndex) => {
      const unitEst = Number(item.estimate.sRate || 0) + Number(item.estimate.lRate || 0);
      const unitBid = Number(b.sRate || 0) + Number(b.lRate || 0);
      let sClass = "", lClass = "";
      if (unitEst > 0 && unitBid > 0) {
        const ratio = unitBid / unitEst;
        if (ratio < lower) { sClass = "bg-blue-100"; lClass = "bg-blue-100"; }
        else if (ratio > upper) { sClass = "bg-orange-100"; lClass = "bg-orange-100"; }
      }
      const missS = (Number(item.qty || 0) > 0) && !b.sRate;
      const missL = (Number(item.qty || 0) > 0) && !b.lRate;

      bidderCellsHtml += `
        <td class="amount-cell">
          <input type="number" class="rate-input ${sClass} ${missS ? "missing-rate":""}"
                 value="${b.sRate || 0}"
                 onchange="handleMEPRateChange(this,'${sheetName}',${rowIndex},${bidderIndex},'s')" />
        </td>
        <td class="amount-cell">
          <input type="number" class="rate-input ${lClass} ${missL ? "missing-rate":""}"
                 value="${b.lRate || 0}"
                 onchange="handleMEPRateChange(this,'${sheetName}',${rowIndex},${bidderIndex},'l')" />
        </td>
        <td class="amount-cell"><span class="${zeroCls(b.sAmount||0)}">${formatCurrency(b.sAmount||0)}</span></td>
        <td class="amount-cell"><span class="${zeroCls(b.lAmount||0)}">${formatCurrency(b.lAmount||0)}</span></td>
      `;
    });

    tr.innerHTML = SIMPLE ? `
      <td class="sticky-col-1 col-slno">${item.slNo || ""}</td>
      <td class="sticky-col-2 col-desc">${item.description || ""}</td>
      <td>${item.unit || ""}</td>
      <td class="amount-cell ${zeroCls(item.qty||0)}">${item.qty || ""}</td>
      <td class="amount-cell ${zeroCls(item.estimate.sRate||0)}">${formatRate(item.estimate.sRate||0)}</td>
      <td class="amount-cell ${zeroCls(item.estimate.lRate||0)}">${formatRate(item.estimate.lRate||0)}</td>
      <td class="amount-cell ${zeroCls(item.estimate.sAmount||0)}">${formatCurrency(item.estimate.sAmount||0)}</td>
      <td class="amount-cell ${zeroCls(item.estimate.lAmount||0)}">${formatCurrency(item.estimate.lAmount||0)}</td>
      ${bidderCellsHtml}
      <td class="least-amount-cell"><span class="${zeroCls(least.amount)}">${formatCurrency(least.amount)}</span></td>
    ` : `
      <td class="sticky-col-1 col-slno">${item.slNo || ""}</td>
      <td class="sticky-col-2 col-desc">${item.description || ""}</td>
      <td>${item.unit || ""}</td>
      <td class="amount-cell ${zeroCls(item.gfQty||0)}">${item.gfQty || ""}</td>
      <td class="amount-cell ${zeroCls(item.oneFQty||0)}">${item.oneFQty || ""}</td>
      <td class="amount-cell ${zeroCls(item.tfQty||0)}">${item.tfQty || ""}</td>
      <td class="amount-cell ${zeroCls(item.qty||0)}">${item.qty || ""}</td>
      <td class="amount-cell ${zeroCls(item.estimate.sRate||0)}">${formatRate(item.estimate.sRate||0)}</td>
      <td class="amount-cell ${zeroCls(item.estimate.lRate||0)}">${formatRate(item.estimate.lRate||0)}</td>
      <td class="amount-cell ${zeroCls(item.estimate.sAmount||0)}">${formatCurrency(item.estimate.sAmount||0)}</td>
      <td class="amount-cell ${zeroCls(item.estimate.lAmount||0)}">${formatCurrency(item.estimate.lAmount||0)}</td>
      ${bidderCellsHtml}
      <td class="least-amount-cell"><span class="${zeroCls(least.amount)}">${formatCurrency(least.amount)}</span></td>
    `;
    tbody.appendChild(tr);
  });
}


/* ===================== Utils ===================== */
function handleRateChange(input, sheetName) {
  const rowIndex = parseInt(input.dataset.rowIndex);
  const bidderIndex = parseInt(input.dataset.bidderIndex);
  const newRate = parseFloat(input.value) || 0;
  if (consolidatedData[sheetName]?.[rowIndex]) {
    consolidatedData[sheetName][rowIndex].bidders[bidderIndex].rate = newRate;
  }
  calculateAllTotals();
  const activeTab = document.querySelector(".tab-button.active").dataset.sheet;
  renderTableForSheet(activeTab);

  setTimeout(() => {
    const selector = `#tables-container input[data-row-index="${rowIndex}"][data-bidder-index="${bidderIndex}"]`;
    const el = document.querySelector(selector);
    if (el) { el.focus(); el.setSelectionRange(el.value.length, el.value.length); }
  }, 0);
}


function handleMEPRateChange(input, sheetName, rowIndex, bidderIndex, kind) {
  const v = parseFloat(input.value) || 0;
  const item = consolidatedData[sheetName]?.[rowIndex];
  if (!item) return;

  const b = item.bidders[bidderIndex];
  if (!b) return;

  if (kind === 's') b.sRate = v; else b.lRate = v;

  // recompute derived fields
  const qty = Number(item.qty || 0);
  b.sAmount = Number(b.sRate || 0) * qty;
  b.lAmount = Number(b.lRate || 0) * qty;
  b.rate    = Number(b.sRate || 0) + Number(b.lRate || 0);
  b.amount  = Number(b.sAmount || 0) + Number(b.lAmount || 0);

  // refresh totals + rerender current tab
  calculateAllTotals();
  const active = document.querySelector(".tab-button.active")?.dataset.sheet || sheetName;
  renderTableForSheet(active);
}


function isPositiveQty(q){ return typeof q === "number" && isFinite(q) && q > 0; }
function zeroCls(v){ return (Number(v) === 0 ? "zero-text" : ""); }


function findLeastBid(item) {
  if (!item.bidders || !item.bidders.length) return { rate: 0, amount: 0 };

  // MEP: choose by total (S+L) amount
  if (COMPARISON_MODE === 'mep' || item.estimate?.sRate || item.estimate?.sAmount) {
    const valid = item.bidders.filter(b => (Number(b.amount || 0) > 0));
    if (!valid.length) return { rate: 0, amount: 0 };
    const min = valid.reduce((m, c) => (c.amount < m.amount ? c : m), valid[0]);
    return { rate: 0, amount: min.amount };
  }

  // Civil (original)
  if (item.amountOnly) {
    const valid = item.bidders.filter((b) => b.amount > 0);
    if (!valid.length) return { rate: 0, amount: 0 };
    const min = valid.reduce((m, c) => (c.amount < m.amount ? c : m), valid[0]);
    return { rate: 0, amount: min.amount };
  } else {
    if (!item.qty) return { rate: 0, amount: 0 };
    const valid = item.bidders.filter((b) => b.rate > 0);
    if (!valid.length) return { rate: 0, amount: 0 };
    const min = valid.reduce((m, c) => (c.rate < m.rate ? c : m), valid[0]);
    return { rate: min.rate, amount: min.rate * item.qty };
  }
}

function getConfigForSheet(sheetName, isEstimate) {
  const set = isEstimate ? ESTIMATE_CONFIG : DATA_CONFIG;
  const lower = String(sheetName || "").toLowerCase();
  for (const key in set) if (lower.includes(key.toLowerCase())) return set[key];
  return null;
}

function getVarianceThresholds() {
  const lower = parseFloat(document.getElementById("lower-variance").value) || 0.8;
  const upper = parseFloat(document.getElementById("upper-variance").value) || 1.2;
  return { lower, upper };
}

function parseQty(value) {
  if (typeof value === "string" && value.toUpperCase() === "QRO") return 0;
  const parsedValue = parseFloat(String(value).replace(/[^0-9.-]+/g, ""));
  return isNaN(parsedValue) ? 0 : parsedValue;
}

function formatCurrency(num) {
  if (typeof num !== "number" || !isFinite(num)) return "0";
  return new Intl.NumberFormat("en-IN", { maximumFractionDigits: 0 }).format(Math.round(num));
}

function formatRate(num) {
  if (typeof num !== "number" || !isFinite(num)) return "0.00";
  return new Intl.NumberFormat("en-IN", { minimumFractionDigits: 2, maximumFractionDigits: 2 })
    .format(num);
}



function extractMEPFields(row, cfg) {
  // Floors (may be absent)
  const gf  = (cfg.gfCol   != null) ? parseNumber(row[cfg.gfCol])   : 0;
  const one = (cfg.oneFCol != null) ? parseNumber(row[cfg.oneFCol]) : 0;
  const tf  = (cfg.tfCol   != null) ? parseNumber(row[cfg.tfCol])   : 0;

  // Qty can be: Total Qty, or plain Qty, or sum of floors
  const tqty     = (cfg.tqtyCol != null) ? parseNumber(row[cfg.tqtyCol]) : 0;
  const basicQty = (cfg.qtyCol   != null) ? parseNumber(row[cfg.qtyCol])   : 0;

  let qty = 0;
  if (tqty > 0) qty = tqty;
  else if ((gf + one + tf) > 0) qty = gf + one + tf;
  else qty = basicQty;

  // Rates / amounts (Installation == Labour)
  const sRate = (cfg.supplyRateCol   != null) ? parseNumber(row[cfg.supplyRateCol])   : 0;
  const lRate = (cfg.labourRateCol   != null) ? parseNumber(row[cfg.labourRateCol])   : 0;
  const sAmt  = (cfg.supplyAmountCol != null) ? parseNumber(row[cfg.supplyAmountCol]) : 0;
  const lAmt  = (cfg.labourAmountCol != null) ? parseNumber(row[cfg.labourAmountCol]) : 0;

  const hasAmt  = (sAmt + lAmt) > 0;
  const hasRate = (sRate + lRate) > 0;

  let unitRate = 0, amount = 0;
  if (hasAmt) amount = sAmt + lAmt;
  if (!hasAmt && hasRate && qty > 0) amount = qty * (sRate + lRate);
  if (hasRate) unitRate = sRate + lRate;
  if (!hasRate && qty > 0 && amount > 0) unitRate = amount / qty;

  return {
    gfQty: gf, oneFQty: one, tfQty: tf, qty,
    sRate, lRate, sAmt, lAmt,
    unitRate, amount
  };
}


/* ===================== Excel export ===================== */
/* ===================== Excel export ===================== */
async function handleDownloadExcelJS(projectNameArg, lowArg, highArg, scopeArg) {
  // --- 1) Gather Project Name + Variance (modal > inputs > defaults) ---
  const DEFAULT_PROJECT =
    "Proposed Industrial Building for M/s DGG Exports Pvt. Ltd At Shiggaon, Karnataka";

  let projectName = (projectNameArg ?? "").trim();
  if (!projectName) {
    const modalProject = document.getElementById("modal-project");
    projectName = (modalProject && modalProject.value.trim()) || DEFAULT_PROJECT;
  }

  let projectScope = (scopeArg ?? "").trim();
  if (!projectScope) {
    const modalScope = document.getElementById("modal-scope");
    projectScope = (modalScope && modalScope.value.trim()) || "Not specified";
  }

  let selectedVarianceLow =
    (typeof lowArg === "number" && isFinite(lowArg))
      ? lowArg
      : (parseFloat(document.getElementById("lower-variance")?.value) || 0.8);

  let selectedVarianceHigh =
    (typeof highArg === "number" && isFinite(highArg))
      ? highArg
      : (parseFloat(document.getElementById("upper-variance")?.value) || 1.2);

  // clamp + order
  selectedVarianceLow  = Math.max(0, Math.min(selectedVarianceLow, 10));
  selectedVarianceHigh = Math.max(0, Math.min(selectedVarianceHigh, 10));
  if (selectedVarianceLow > selectedVarianceHigh) {
    [selectedVarianceLow, selectedVarianceHigh] = [selectedVarianceHigh, selectedVarianceLow];
  }

  // reflect back into UI labels/inputs
  const lowEl  = document.getElementById("lower-variance");
  const highEl = document.getElementById("upper-variance");
  if (lowEl)  lowEl.value  = selectedVarianceLow.toFixed(2);
  if (highEl) highEl.value = selectedVarianceHigh.toFixed(2);
  const lowLbl  = document.getElementById("lower-variance-label");
  const highLbl = document.getElementById("upper-variance-label");
  if (lowLbl)  lowLbl.textContent  = `Low < ${selectedVarianceLow}`;
  if (highLbl) highLbl.textContent = `High > ${selectedVarianceHigh}`;

  // --- 2) Formatting/constants for Excel ---
  const RATE_FMT = "#,##0.00";
  const AMT_FMT  = "#,##0";
  const GREY_200 = "FFE5E7EB";
  const HEADER_PEACH = "FFFCE4D6";
  const TOP_CATEGORY_MIN_HEIGHT = 28;
  const SPACER_ROW_HEIGHT = 15;

  const isSummary = (n) => n === "Summary";
  const isSubtotalText = (txt = "") => /sub[\s-]?total/i.test(String(txt));
  const insertWrapHints = (txt) =>
    txt == null ? "" : String(txt)
      .replace(/\s+/g, " ")
      .replace(/\//g, "/\u200b")
      .replace(/-/g, "-\u200b")
      .trim();
  const formatSrNo = (val) => (val == null ? "" : String(val).trim());

  const estimateRowHeight = (text, colWidth, lineHeight = 16, min = 18, max = 120) => {
    const s = (text || "").toString();
    if (!s) return min;
    const hardLines = s.split(/\r\n|\n/);
    const perLineCap = Math.max(1, Math.floor(colWidth * 1.1));
    let logicalLines = 0;
    for (const ln of hardLines) logicalLines += Math.max(1, Math.ceil(ln.length / perLineCap));
    return Math.min(max, Math.max(min, logicalLines * lineHeight));
  };

  // --- 3) Build workbook ---
  const workbook = new ExcelJS.Workbook();

  const sheetsToDownload = processedSheetNames.filter(
    (name) => consolidatedData[name] && consolidatedData[name].length > 0
  );

  const ANP_LOGO_BASE64 = "";
  let logoId = null;
  if (ANP_LOGO_BASE64 && ANP_LOGO_BASE64.includes("base64")) {
    logoId = workbook.addImage({
      base64: ANP_LOGO_BASE64.replace(/^data:image\/(png|jpeg);base64,/, ""),
      extension: ANP_LOGO_BASE64.includes("png") ? "png" : "jpeg",
    });
  }

  for (const sheetName of sheetsToDownload) {
    const excelName = displayNameFor(sheetName).substring(0, 31);
    const sheet = workbook.addWorksheet(excelName);
    const spacerRowNumbers = new Set();

    // Header block
    sheet.mergeCells("A1", "D1");
    sheet.getCell("A1").value = `Project  : ${projectName}`;
    sheet.getCell("A1").font = { bold: true };
    sheet.getCell("A1").alignment = { horizontal: "left", vertical: "middle" };

    sheet.mergeCells("A2","D2");
    sheet.getCell("A2").value = `Scope   : ${projectScope}`;
    sheet.getCell("A2").font = { bold: true };
    sheet.getCell("A2").alignment = { horizontal: "left", vertical: "middle" };

    sheet.getCell("E1").value = `Low: ${selectedVarianceLow}`;
    sheet.getCell("E1").fill  = { type: "pattern", pattern: "solid", fgColor: { argb: "FFBFD7EA" } };
    sheet.getCell("F1").value = `High: ${selectedVarianceHigh}`;
    sheet.getCell("F1").fill  = { type: "pattern", pattern: "solid", fgColor: { argb: "FFFFD2B3" } };
    sheet.getCell("E2").value = `Date: ${new Date().toLocaleDateString()}`;
    sheet.getCell("F2").value = "Rev: R0";

    sheet.getRow(1).height = 48;
    sheet.getRow(2).height = 44;
    sheet.getColumn("E").width = 18;
    sheet.getColumn("F").width = 18;
    sheet.getColumn("G").width = 20;

    if (logoId) {
      sheet.addImage(logoId, { tl: { col: 6.8, row: 0.2 }, ext: { width: 95, height: 95 } });
    }

    // ---------- SUMMARY ----------
    if (isSummary(sheetName)) {
      sheet.addRow([]);

      const headers = ["Sl. No", "Description", "Estimate", ...bidderNames, "Least Amount"];
      const headerRow = sheet.addRow(headers);
      headerRow.font = { bold: true, color: { argb: "FF000000" } };
      headerRow.fill = { type: "pattern", pattern: "solid", fgColor: { argb: HEADER_PEACH } };
      headerRow.alignment = { horizontal: "center", vertical: "middle", wrapText: true };
      headerRow.height = 28;

      sheet.getColumn(1).width = 14;  sheet.getColumn(1).numFmt = "@";
      sheet.getColumn(2).width = 60;
      for (let c = 3; c <= 3 + bidderNames.length; c++) {
        sheet.getColumn(c).width = 18; sheet.getColumn(c).numFmt = AMT_FMT;
      }
      const lastCol = 4 + bidderNames.length;
      sheet.getColumn(lastCol).width = 18; sheet.getColumn(lastCol).numFmt = AMT_FMT;

      const rows = consolidatedData.Summary || [];
      rows.forEach((row) => {
        const xlsRow = sheet.addRow([
          formatSrNo(row.slNo ?? ""),
          insertWrapHints(row.description || ""),
          row.estimateAmount || 0,
          ...(row.bidderAmounts || Array(bidderNames.length).fill(0)),
          row.leastAmount || 0,
        ]);

        xlsRow.getCell(1).numFmt = "@";
        xlsRow.getCell(1).alignment = { horizontal: "left", vertical: "top", wrapText: true };
        xlsRow.getCell(2).alignment = { horizontal: "left", vertical: "top", wrapText: true };
        for (let c = 3; c <= lastCol; c++) {
          xlsRow.getCell(c).alignment = { vertical: "top", horizontal: "right" };
        }
        xlsRow.height = Math.max(28, estimateRowHeight(xlsRow.getCell(2).value, 60));

        if (row.kind === "category" || row.kind === "subtotal" || row.kind === "grand") {
          xlsRow.font = { bold: true };
          xlsRow.eachCell({ includeEmpty: true }, (cell) => {
            cell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: GREY_200 } };
            cell.alignment = { ...cell.alignment, vertical: "top" };
          });
        }
      });

      sheet.views = [{ state: "frozen", ySplit: 4 }];

      sheet.eachRow((row) => {
        row.eachCell({ includeEmpty: true }, (cell) => {
          cell.border = {
            top: { style: "thin" },
            left: { style: "thin" },
            bottom: { style: "thin" },
            right: { style: "thin" },
          };
          if (cell.value == null) cell.value = "";
        });
      });

      continue; // next sheet
    }

    // ---------- MEP SHEETS ----------
    if (!isSummary(sheetName) && COMPARISON_MODE === 'mep') {
      sheet.addRow([]);

      const cfg = consolidatedData[sheetName]?._cfg || {};
      const simpleMEP = !!cfg.simpleQtyOnly || (!cfg.gfCol && !cfg.oneFCol && !cfg.tfCol);

      // 2-row header
      const h1 = sheet.addRow([
        "Sr.No.", "Description of Work",
        "Estimate", ...(simpleMEP ? Array(6 - 1).fill(null) : Array(9 - 1).fill(null)),
        ...bidderNames.flatMap(() => ["", "", "", ""]),
        "Least Amount"
      ]);
      const h2 = sheet.addRow(
        simpleMEP
          ? [null, null,
             "UNIT", "QTY", "SUPPLY RATE", "INSTALLATION RATE", "SUPPLY AMOUNT", "INSTALLATION AMOUNT",
             ...bidderNames.flatMap(() => ["SUPPLY RATE", "INSTALLATION RATE", "SUPPLY AMOUNT", "INSTALLATION AMOUNT"]),
             null]
          : [null, null,
             "UNIT", "GF", "1F", "TF", "TOTAL QTY", "SUPPLY RATE", "INSTALLATION RATE", "SUPPLY AMOUNT", "INSTALLATION AMOUNT",
             ...bidderNames.flatMap(() => ["SUPPLY RATE", "INSTALLATION RATE", "SUPPLY AMOUNT", "INSTALLATION AMOUNT"]),
             null]
      );

      sheet.mergeCells(4, 3, 4, simpleMEP ? 8 : 11);
      bidderNames.forEach((_, i) => {
        const start = (simpleMEP ? 9 : 12) + i*4;
        sheet.mergeCells(4, start, 4, start + 3);
      });

      [h1, h2].forEach(r => {
        r.font = { bold: true, color: { argb: "FF000000" } };
        r.fill = { type: "pattern", pattern: "solid", fgColor: { argb: HEADER_PEACH } };
        r.alignment = { horizontal: "center", vertical: "middle", wrapText: true };
        r.height = 28;
      });

      const widths = simpleMEP
        ? [14, 90, 10, 12, 12, 12, 14, 14, ...bidderNames.flatMap(() => [12,12,14,14]), 16]
        : [14, 90, 10, 10, 10, 10, 12, 12, 12, 14, 14, ...bidderNames.flatMap(() => [12,12,14,14]), 16];
      widths.forEach((w, i) => (sheet.getColumn(i + 1).width = w));
      sheet.getColumn(1).numFmt = "@";

      const descWidth = 90;
      const seenTop = new Set();

      (consolidatedData[sheetName] || []).forEach(item => {
        const isDetail = !item.isSubtotal && !item.isGrandTotal && !item.isCategory;

        // 🔹 do NOT blank ABSTRACT rows
        const isAbstract = /\babstract\b/i.test(String(item.description || ""));
        const estUnitRate = Number(item.estimate?.sRate || 0) + Number(item.estimate?.lRate || 0);
        const blankAllMEP = !isAbstract && isDetail &&
                            (Number(item.qty || 0) === 0 || estUnitRate === 0);

        const least = (!blankAllMEP && item.bidders && item.bidders.length)
          ? (Math.min(...item.bidders.map(b => Number(b.amount || 0)).filter(v => v > 0)) || 0)
          : null;

        const rowVals = [
          String(item.slNo ?? ""),
          insertWrapHints(item.description || ""),
        ];

        if (simpleMEP) {
          rowVals.push(
            item.unit || "",
            blankAllMEP ? null : (item.qty || 0),
            blankAllMEP ? null : (item.estimate.sRate || 0),
            blankAllMEP ? null : (item.estimate.lRate || 0),
            blankAllMEP ? null : (item.estimate.sAmount || 0),
            blankAllMEP ? null : (item.estimate.lAmount || 0),
            ...item.bidders.flatMap(b => [
              blankAllMEP ? null : (b.sRate || 0),
              blankAllMEP ? null : (b.lRate || 0),
              blankAllMEP ? null : (b.sAmount || 0),
              blankAllMEP ? null : (b.lAmount || 0),
            ]),
            blankAllMEP ? null : least
          );
        } else {
          rowVals.push(
            item.unit || "",
            blankAllMEP ? null : (item.gfQty || 0),
            blankAllMEP ? null : (item.oneFQty || 0),
            blankAllMEP ? null : (item.tfQty || 0),
            blankAllMEP ? null : (item.qty || 0),
            blankAllMEP ? null : (item.estimate.sRate || 0),
            blankAllMEP ? null : (item.estimate.lRate || 0),
            blankAllMEP ? null : (item.estimate.sAmount || 0),
            blankAllMEP ? null : (item.estimate.lAmount || 0),
            ...item.bidders.flatMap(b => [
              blankAllMEP ? null : (b.sRate || 0),
              blankAllMEP ? null : (b.lRate || 0),
              blankAllMEP ? null : (b.sAmount || 0),
              blankAllMEP ? null : (b.lAmount || 0),
            ]),
            blankAllMEP ? null : least
          );
        }

        const row = sheet.addRow(rowVals);

        // formats & alignment (unchanged) ...
        row.getCell(1).numFmt = "@";
        row.getCell(1).alignment = { vertical: "top", horizontal: "left", wrapText: true };
        row.getCell(2).alignment = { vertical: "top", horizontal: "left", wrapText: true };

        if (simpleMEP) {
          row.getCell(3).alignment = { vertical:"top", horizontal:"center" };
          row.getCell(4).alignment = { vertical:"top", horizontal:"right" }; row.getCell(4).numFmt = "#,##0";
          row.getCell(5).alignment = { vertical:"top", horizontal:"right" }; row.getCell(5).numFmt = RATE_FMT;
          row.getCell(6).alignment = { vertical:"top", horizontal:"right" }; row.getCell(6).numFmt = RATE_FMT;
          row.getCell(7).alignment = { vertical:"top", horizontal:"right" }; row.getCell(7).numFmt = AMT_FMT;
          row.getCell(8).alignment = { vertical:"top", horizontal:"right" }; row.getCell(8).numFmt = AMT_FMT;

          const startBid = 9;
          const endBid   = 9 + 4*bidderNames.length - 1;
          for (let c = startBid; c <= endBid; c++) {
            const idxInQuad = (c - startBid + 1) % 4;
            row.getCell(c).alignment = { vertical: "top", horizontal: "right" };
            row.getCell(c).numFmt = (idxInQuad === 1 || idxInQuad === 2) ? RATE_FMT : AMT_FMT;
          }
          const leastCol = endBid + 1;
          row.getCell(leastCol).alignment = { vertical: "top", horizontal: "right" };
          row.getCell(leastCol).numFmt = AMT_FMT;

          // variance + missing-rate shading (unchanged)
          if (!blankAllMEP && isDetail) {
            const unitEst = Number(item.estimate.sRate || 0) + Number(item.estimate.lRate || 0);
            for (let i = 0; i < bidderNames.length; i++) {
              const sCol = startBid + i*4;
              const lCol = sCol + 1;
              const sRate = Number(row.getCell(sCol).value || 0);
              const lRate = Number(row.getCell(lCol).value || 0);
              const unitBid = sRate + lRate;

              if (Number(item.qty || 0) > 0 && (sRate === 0 || lRate === 0)) {
                [sCol, lCol].forEach(c => {
                  const cell = row.getCell(c);
                  cell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FF7F1D1D" } };
                  cell.font = { color: { argb: "FFFFFFFF" }, bold: true };
                });
                continue;
              }
              if (unitEst > 0 && unitBid > 0) {
                const ratio = unitBid / unitEst;
                let argb = null;
                if (ratio < selectedVarianceLow)       argb = "FFBFD7EA";
                else if (ratio > selectedVarianceHigh) argb = "FFFFD2B3";
                if (argb) [sCol, lCol].forEach(c => {
                  row.getCell(c).fill = { type: "pattern", pattern: "solid", fgColor: { argb } };
                });
              }
            }
          }
        } else {
          // complex (GF/1F/TF/TQTY) formatting — unchanged...
          row.getCell(3).alignment = { vertical:"top", horizontal:"center" };
          [4,5,6,7].forEach(c => { row.getCell(c).alignment = { vertical:"top", horizontal:"right" }; row.getCell(c).numFmt = "#,##0"; });
          row.getCell(8).alignment = { vertical:"top", horizontal:"right" }; row.getCell(8).numFmt = RATE_FMT;
          row.getCell(9).alignment = { vertical:"top", horizontal:"right" }; row.getCell(9).numFmt = RATE_FMT;
          row.getCell(10).alignment = { vertical:"top", horizontal:"right" }; row.getCell(10).numFmt = AMT_FMT;
          row.getCell(11).alignment = { vertical:"top", horizontal:"right" }; row.getCell(11).numFmt = AMT_FMT;

          const startBid = 12;
          const endBid   = 12 + 4*bidderNames.length - 1;
          for (let c = startBid; c <= endBid; c++) {
            const idxInQuad = (c - startBid + 1) % 4;
            row.getCell(c).alignment = { vertical: "top", horizontal: "right" };
            row.getCell(c).numFmt = (idxInQuad === 1 || idxInQuad === 2) ? RATE_FMT : AMT_FMT;
          }
          const leastCol = endBid + 1;
          row.getCell(leastCol).alignment = { vertical: "top", horizontal: "right" };
          row.getCell(leastCol).numFmt = AMT_FMT;

          if (!blankAllMEP && isDetail) {
            const unitEst = Number(item.estimate.sRate || 0) + Number(item.estimate.lRate || 0);
            for (let i = 0; i < bidderNames.length; i++) {
              const sCol = 12 + i*4;
              const lCol = sCol + 1;
              const sRate = Number(row.getCell(sCol).value || 0);
              const lRate = Number(row.getCell(lCol).value || 0);
              const unitBid = sRate + lRate;

              if (Number(item.qty || 0) > 0 && (sRate === 0 || lRate === 0)) {
                [sCol, lCol].forEach(c => {
                  const cell = row.getCell(c);
                  cell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FF7F1D1D" } };
                  cell.font = { color: { argb: "FFFFFFFF" }, bold: true };
                });
                continue;
              }
              if (unitEst > 0 && unitBid > 0) {
                const ratio = unitBid / unitEst;
                let argb = null;
                if (ratio < selectedVarianceLow)       argb = "FFBFD7EA";
                else if (ratio > selectedVarianceHigh) argb = "FFFFD2B3";
                if (argb) [sCol, lCol].forEach(c => {
                  row.getCell(c).fill = { type: "pattern", pattern: "solid", fgColor: { argb } };
                });
              }
            }
          }
        }

        // 🔹 treat ABSTRACT like subtotal for styling
        const topKey = String(item.slNo || "").split(".")[0];
        const isTopCategory =
          item.isCategory && /^\d+(?:\.0+)?$/.test(String(item.slNo || "")) && !seenTop.has(topKey);
        const isSubtotal = item.isSubtotal || /sub[\s-]?total/i.test(String(item.description || "")) ||
                           /\babstract\b/i.test(String(item.description || ""));

        if (isSubtotal || item.isGrandTotal || isTopCategory) {
          row.font = { bold: true };
          row.eachCell({ includeEmpty: true }, (cell) => {
            cell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: GREY_200 } };
            cell.alignment = { ...cell.alignment, vertical: "top" };
          });
          row.height = Math.max(estimateRowHeight(item.description, descWidth), 28);
          if (isTopCategory) seenTop.add(topKey);
        } else {
          row.height = estimateRowHeight(item.description, descWidth);
        }
      });

      sheet.views = [{ state: "frozen", ySplit: 5 }];
      sheet.eachRow(r => {
        r.eachCell({ includeEmpty: true }, (cell) => {
          cell.border = { top:{style:"thin"}, left:{style:"thin"}, bottom:{style:"thin"}, right:{style:"thin"} };
          if (cell.value == null) cell.value = "";
        });
      });

      continue; // next sheet
    }

    // ---------- CIVIL (BOQ) SHEETS ----------
    sheet.addRow([]);
    const h1 = sheet.addRow([
      "Sl. No.", "Description of Items", "Unit", "Estimated", null, null,
      ...bidderNames.flatMap((n) => [n, null]),
      "Least Bid", null,
    ]);
    const h2 = sheet.addRow([
      null, null, null, "Qty", "Rate", "Amount",
      ...Array(bidderNames.length + 1).fill(null).flatMap(() => ["Rate", "Amount"]),
    ]);

    sheet.mergeCells("D4:F4");
    bidderNames.forEach((_, i) => sheet.mergeCells(4, 7 + i * 2, 4, 8 + i * 2));
    sheet.mergeCells(4, 7 + bidderNames.length * 2, 4, 8 + bidderNames.length * 2);

    [h1, h2].forEach((r) => {
      r.font = { bold: true, color: { argb: "FF000000" } };
      r.fill = { type: "pattern", pattern: "solid", fgColor: { argb: HEADER_PEACH } };
      r.alignment = { horizontal: "center", vertical: "middle", wrapText: true };
      r.height = 28;
    });

    const descWidth = 72;
    [14, descWidth, 10, 12, 12, 14, ...bidderNames.flatMap(() => [12, 14]), 12, 14]
      .forEach((w, i) => (sheet.getColumn(i + 1).width = w));
    sheet.getColumn(1).numFmt = "@";

    const isAmtOnlySheet = !!(consolidatedData[sheetName]?._isAmountOnly);
    const seenTop = new Set();

    consolidatedData[sheetName].forEach((item) => {
      const slNoStr = formatSrNo(item.slNo);
      const topKey  = String(item.slNo || "").split(".")[0];
      const isTopCategory =
        item.isCategory && /^\d+(?:\.0+)?$/.test(String(item.slNo || "")) && !seenTop.has(topKey);

      const isDetail = !item.isSubtotal && !item.isGrandTotal && !item.isCategory;

      // 🔹 do NOT blank ABSTRACT rows
      const isAbstract = /\babstract\b/i.test(String(item.description || ""));
      const blankAll = !isAbstract && isDetail &&
                       (Number(item.qty || 0) === 0 || Number(item.estimate?.rate || 0) === 0);

      const leastBid = blankAll
        ? { rate: null, amount: null }
        : findLeastBid(item);

      const rowVals = [
        slNoStr,
        insertWrapHints(item.description),
        item.unit,
        blankAll ? null : (item.qty ?? null),
        (isAmtOnlySheet || !isDetail || blankAll) ? null : item.estimate.rate,
        blankAll ? null : item.estimate.amount,
        ...item.bidders.flatMap((b) => [
          (isAmtOnlySheet || !isDetail || blankAll) ? null : b.rate,
          blankAll ? null : b.amount
        ]),
        (isAmtOnlySheet || blankAll) ? null : leastBid.rate,
        blankAll ? null : leastBid.amount,
      ];

      const newRow = sheet.addRow(rowVals);

      // align/format
      newRow.getCell(1).numFmt = "@";
      newRow.getCell(1).alignment = { vertical: "top", horizontal: "left", wrapText: true };
      newRow.getCell(2).alignment = { vertical: "top", horizontal: "left", wrapText: true };
      newRow.getCell(3).alignment = { vertical: "top", horizontal: "center", wrapText: true };
      newRow.getCell(4).alignment = { vertical: "top", horizontal: "right" }; newRow.getCell(4).numFmt = AMT_FMT;
      newRow.getCell(5).alignment = { vertical: "top", horizontal: "right" }; newRow.getCell(5).numFmt = RATE_FMT;
      newRow.getCell(6).alignment = { vertical: "top", horizontal: "right" }; newRow.getCell(6).numFmt = AMT_FMT;

      for (let i = 0; i < bidderNames.length; i++) {
        newRow.getCell(7 + i * 2).alignment = { vertical: "top", horizontal: "right" };
        newRow.getCell(7 + i * 2).numFmt = RATE_FMT;
        newRow.getCell(8 + i * 2).alignment = { vertical: "top", horizontal: "right" };
        newRow.getCell(8 + i * 2).numFmt = AMT_FMT;
      }
      const leastStartCol = 7 + bidderNames.length * 2;
      newRow.getCell(leastStartCol).alignment = { vertical: "top", horizontal: "right" };
      newRow.getCell(leastStartCol + 1).alignment = { vertical: "top", horizontal: "right" };
      newRow.getCell(leastStartCol).numFmt = RATE_FMT;
      newRow.getCell(leastStartCol + 1).numFmt = AMT_FMT;

      // variance / missing-rate shading (skip for amount-only & when blank)
      if (!isAmtOnlySheet && isDetail && !blankAll) {
        item.bidders.forEach((b, i) => {
          const rateCell = newRow.getCell(7 + i * 2);
          if (item.estimate?.rate && b.rate) {
            const variance = b.rate / item.estimate.rate;
            if (variance < selectedVarianceLow) {
              rateCell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFBFD7EA" } };
            } else if (variance > selectedVarianceHigh) {
              rateCell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFFFD2B3" } };
            }
          }
          if (Number(item.qty || 0) > 0 && (!b.rate || b.rate === 0)) {
            rateCell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FF7F1D1D" } };
            rateCell.font = { color: { argb: "FFFFFFFF" }, bold: true };
          }
        });
      }

      // 🔹 treat ABSTRACT like subtotal for styling
      const isSubtotal = item.isSubtotal || isSubtotalText(item.description) ||
                         /\babstract\b/i.test(String(item.description || ""));
      if (isSubtotal || item.isGrandTotal || isTopCategory) {
        newRow.font = { bold: true };
        newRow.eachCell({ includeEmpty: true }, (cell) => {
          cell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: GREY_200 } };
          cell.alignment = { ...cell.alignment, vertical: "top" };
        });
        newRow.height = Math.max(estimateRowHeight(item.description, descWidth), TOP_CATEGORY_MIN_HEIGHT);
        if (isTopCategory) seenTop.add(String(item.slNo));
        if (isSubtotal) {
          const spacer = sheet.addRow([]); spacer.height = SPACER_ROW_HEIGHT; spacerRowNumbers.add(spacer.number);
        }
      } else {
        newRow.height = estimateRowHeight(item.description, descWidth);
      }
    });

    sheet.views = [{ state: "frozen", ySplit: 5 }];

    sheet.eachRow((row) => {
      if (spacerRowNumbers.has(row.number)) return;
      row.eachCell({ includeEmpty: true }, (cell) => {
        cell.border = {
          top: { style: "thin" }, left: { style: "thin" },
          bottom: { style: "thin" }, right: { style: "thin" },
        };
        if (cell.value == null) cell.value = "";
      });
    });
  }

  // --- 4) Save file ---
  const outName = "CS_Consolidated_Output.xlsx";
  const buffer = await workbook.xlsx.writeBuffer();
  saveAs(
    new Blob([buffer], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" }),
    outName
  );
}


document.getElementById("reload-page").addEventListener("click", () => {
  window.location.reload();
});

</script>



<!-- Export Options Modal -->
<!-- Export Options Modal (DARK) -->
<div id="export-modal" class="fixed inset-0 z-[100] hidden">
  <!-- backdrop -->
  <div class="absolute inset-0 bg-black/70" onclick="closeExportModal()"></div>

  <!-- modal -->
  <div class="absolute inset-0 flex items-center justify-center p-4">
    <div class="w-full max-w-lg rounded-2xl bg-slate-900 text-gray-100 shadow-2xl border border-slate-700">
      <!-- header -->
      <div class="flex items-center justify-between px-6 py-4 border-b border-slate-700">
        <h3 class="text-lg font-semibold">Export options</h3>
        <button
          class="text-gray-400 hover:text-gray-200"
          onclick="closeExportModal()"
          aria-label="Close">&times;</button>
      </div>

      <!-- body -->
      <div class="px-6 py-4 space-y-5">
        <!-- Project name -->
        <div>
          <label for="modal-project" class="block text-sm font-medium text-gray-300">
            Project name
          </label>
          <input id="modal-project" type="text"
                 class="mt-1 w-full rounded-lg border border-slate-600 bg-slate-800/70 px-3 py-2
                        text-gray-100 placeholder-gray-400
                        focus:outline-none focus:ring-2 focus:ring-indigo-500/50 focus:border-indigo-400"/>
          <p class="mt-1 text-xs text-gray-400">
            This appears at the top of every exported sheet.
          </p>
        </div>
        
        <div>
  <label class="block text-sm font-medium text-gray-300 mb-1">Scope</label>
  <input type="text" id="modal-scope"
    class="w-full px-3 py-2 rounded-md bg-gray-800 border border-gray-600 text-gray-100"
    placeholder="Enter scope of work" />
  <p class="text-xs text-gray-400 mt-1">This will also appear in the exported Excel file.</p>
</div>
        <!-- Variance -->
        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
          <div>
            <label for="modal-low" class="block text-sm font-medium text-gray-300">Lower variance</label>
            <input id="modal-low" type="number" step="0.01" min="0" max="10"
                   class="mt-1 w-full rounded-lg border border-slate-600 bg-slate-800/70 px-3 py-2
                          text-gray-100 placeholder-gray-400
                          focus:outline-none focus:ring-2 focus:ring-indigo-500/50 focus:border-indigo-400"/>
            <p class="mt-1 text-xs text-gray-400">e.g. <strong class="text-gray-200">0.80</strong> highlights rates &lt; 80% of estimate.</p>
          </div>
          <div>
            <label for="modal-high" class="block text-sm font-medium text-gray-300">Upper variance</label>
            <input id="modal-high" type="number" step="0.01" min="0" max="10"
                   class="mt-1 w-full rounded-lg border border-slate-600 bg-slate-800/70 px-3 py-2
                          text-gray-100 placeholder-gray-400
                          focus:outline-none focus:ring-2 focus:ring-indigo-500/50 focus:border-indigo-400"/>
            <p class="mt-1 text-xs text-gray-400">e.g. <strong class="text-gray-200">1.20</strong> highlights rates &gt; 120% of estimate.</p>
          </div>
        </div>

        <!-- Inline validation -->
        <div id="modal-error"
             class="hidden rounded-lg bg-red-900/40 border border-red-700 px-3 py-2 text-sm text-red-200"></div>
      </div>

      <!-- footer -->
      <div class="flex items-center justify-end gap-3 px-6 py-4 border-t border-slate-700">
        <button class="rounded-lg border border-slate-600 px-4 py-2 text-gray-200 hover:bg-slate-800"
                onclick="closeExportModal()">Cancel</button>
        <button class="rounded-lg bg-indigo-600 px-4 py-2 font-semibold text-white hover:bg-indigo-500
                       disabled:opacity-60 disabled:cursor-not-allowed"
                onclick="submitExportModal()">Export</button>
      </div>
    </div>
  </div>
</div>


<!-- Mode Picker Modal -->
<div id="mode-modal" class="fixed inset-0 z-[90] hidden">
  <div class="absolute inset-0 bg-black/70" onclick="closeModeModal()"></div>
  <div class="absolute inset-0 flex items-center justify-center p-4">
    <div class="w-full max-w-md rounded-2xl bg-slate-900 text-gray-100 shadow-2xl border border-slate-700">
      <div class="px-6 py-4 border-b border-slate-700">
        <h3 class="text-lg font-semibold">Choose comparison type</h3>
        <p class="text-sm text-gray-400 mt-1">Pick the structure that matches your files.</p>
      </div>
      <div class="px-6 py-6 grid grid-cols-1 gap-4">
        <button class="rounded-lg bg-indigo-600 hover:bg-indigo-500 px-4 py-3 font-semibold"
                onclick="startProcessing('civil')">CIVIL (Qty × Rate = Amount)</button>
        <button class="rounded-lg bg-emerald-600 hover:bg-emerald-500 px-4 py-3 font-semibold"
                onclick="startProcessing('mep')">MEP (Supply/Labour Rates & Amounts)</button>
      </div>
      <div class="px-6 py-4 border-t border-slate-700 flex justify-end">
        <button class="rounded-lg border border-slate-600 px-4 py-2 text-gray-200 hover:bg-slate-800"
                onclick="closeModeModal()">Cancel</button>
      </div>
    </div>
  </div>
</div>



</body>
</html>
